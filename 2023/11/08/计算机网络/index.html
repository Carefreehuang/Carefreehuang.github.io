

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/topLogo.png">
  <link rel="icon" href="/img/topLogo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Carefreehuang">
  <meta name="keywords" content="">
  
    <meta name="description" content="概览物理层 物理层基本概念 物理层关注的是如何在连接各种计算机的传输媒体上传输数据。 物理层的任务是尽可能的屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异 为什么要进行屏蔽呢？ 不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。 所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。 简单来说就是：物理">
<meta property="og:type" content="article">
<meta property="og:title" content="Carefreehaung的个人博客">
<meta property="og:url" content="http://example.com/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Carefreehaung的个人博客">
<meta property="og:description" content="概览物理层 物理层基本概念 物理层关注的是如何在连接各种计算机的传输媒体上传输数据。 物理层的任务是尽可能的屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异 为什么要进行屏蔽呢？ 不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。 所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。 简单来说就是：物理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\Blog\source\img\%E5%8C%85%E5%90%AB%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93%E5%92%8C%E5%B9%B6%E8%A1%8C%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%8D%95%E5%90%91%E9%80%9A%E8%A1%8C%E7%AD%89.png">
<meta property="og:image" content="d:\Blog\source\img\%E8%B0%83%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%A7%E7%A4%BA%E6%84%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png">
<meta property="og:image" content="http://example.com/source/img/%E8%A7%A3%E5%86%B3%E5%B8%A7%E7%95%8C%E9%99%90%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="d:\Blog\source\img\%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%9B%9E%E9%80%80n%E5%B8%A7%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%9B%9E%E9%80%80n%E5%B8%A7%E7%A4%BA%E6%84%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%BD%91%E5%8D%A1%E7%9A%84%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="d:\Blog\source\img\mac%E5%9C%B0%E5%9D%80%E4%BD%9C%E7%94%A8.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%BF%A1%E5%8F%B7%E7%A2%B0%E6%92%9E.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BB%A5%E5%A4%AA%E7%BD%91.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%85%89%E7%BA%A4%E6%89%A9%E5%B1%95%E8%B7%9D%E7%A6%BB.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%9B%86%E7%BA%BF%E5%99%A8%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E5%92%8C%E6%95%B0%E9%87%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E7%9A%84%E7%A2%B0%E6%92%9E%E5%9F%9F.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%BD%91%E6%A1%A5%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C.png">
<meta property="og:image" content="d:\Blog\source\img\CSMACA%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png">
<meta property="og:image" content="d:\Blog\source\img\ip%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8.png">
<meta property="og:image" content="d:\Blog\source\img\IPv4%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="d:\Blog\source\img\A%E7%B1%BB%E5%9C%B0%E5%9D%80.png">
<meta property="og:image" content="d:\Blog\source\img\B%E7%B1%BB%E5%9C%B0%E5%9D%80.png">
<meta property="og:image" content="d:\Blog\source\img\C%E7%B1%BB%E7%BD%91%E7%BB%9C.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%90%84%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E6%B5%AA%E8%B4%B9.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BD%91%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%BE%8B%E9%A2%98.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%97%A0%E5%88%86%E7%B1%BB%E6%8E%A9%E7%A0%81%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88.png">
<meta property="og:image" content="d:\Blog\source\img\Ip%E5%9C%B0%E5%9D%80%E4%B8%8Emac%E5%9C%B0%E5%9D%80%E7%9A%84%E5%B0%81%E8%A3%85.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E9%80%81ipmac%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png">
<meta property="og:image" content="d:\Blog\source\img\arp%E5%8D%8F%E8%AE%AE%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="d:\Blog\source\img\IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%88%86%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="d:\Blog\source\img\ospf%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F.png">
<meta property="og:image" content="d:\Blog\source\img\%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="d:\Blog\source\img\NAT%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BD%AC%E6%8D%A2.png">
<meta property="og:image" content="d:\Blog\source\img\ip%E5%A4%9A%E6%92%AD.png">
<meta property="og:image" content="d:\Blog\source\img\ipv4%E5%AF%B9%E6%AF%94ipv6.png">
<meta property="og:image" content="d:\Blog\source\img\%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D.png">
<meta property="og:image" content="d:\Blog\source\img\tcp%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="d:\Blog\source\img\TCP%E4%B8%AD%E7%9A%84%E7%A1%AE%E8%AE%A4%E5%8F%B7%E5%92%8C%E5%BA%8F%E5%88%97%E5%8F%B7.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E9%81%BF%E5%85%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85%E4%BD%9C%E7%94%A8.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%8B%A5%E5%A1%9E%E5%90%9E%E5%90%90%E9%87%8F.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93.png">
<meta property="og:image" content="d:\Blog\source\img\%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E.png">
<meta property="og:image" content="d:\Blog\source\img\%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88.png">
<meta property="og:image" content="d:\Blog\source\img\%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%AE%E5%BF%99%E5%A4%84%E7%90%86%E9%87%8D%E5%AE%9A%E5%90%91.png">
<meta property="og:image" content="d:\Blog\source\img\https%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png">
<meta property="og:image" content="d:\Blog\source\img\http2%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="d:\Blog\source\img\http3%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B.png">
<meta property="og:image" content="d:/Blog/source/img/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE.png">
<meta property="og:image" content="d:/Blog/source/img/session%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="d:/Blog/source/img/cookie%EF%BC%8Csession%EF%BC%8C%E4%BB%A4%E7%89%8C%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="d:\Blog\source\img\%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="d:\Blog\source\img\%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5.png">
<meta property="article:published_time" content="2023-11-08T13:00:09.172Z">
<meta property="article:modified_time" content="2023-11-27T15:05:56.409Z">
<meta property="article:author" content="Carefreehuang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:\Blog\source\img\%E5%8C%85%E5%90%AB%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84.png">
  
  
  
  <title>Carefreehaung的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"java"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Carefreehaung</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-08 21:00" pubdate>
          2023年11月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          287 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><hr>
<h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul>
<li>物理层关注的是如何在连接各种计算机的传输媒体上传输数据。</li>
<li>物理层的任务是尽可能的<strong>屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异</strong><ul>
<li>为什么要进行屏蔽呢？<ul>
<li>不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。</li>
<li>所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。</li>
<li>简单来说就是：物理层使不同设备不同条件 的情况下让上层感受不到差异，因此使得不需要“因地制宜”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="物理层之下的传输媒体"><a href="#物理层之下的传输媒体" class="headerlink" title="物理层之下的传输媒体"></a>物理层之下的传输媒体</h3><ul>
<li><p>传输媒体是计算机网络设备之间的<strong>物理通路</strong>，也称为传输介质或传输媒介。</p>
<ul>
<li>传输媒体在物理层之下，并且不包含在计算机网络体系结构之中。<br><img src="D:\Blog\source\img\包含传输媒体的结构.png" srcset="/img/loading.gif" lazyload alt="包含传输媒体结构"></li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li>导向型传输媒体：<ul>
<li>导向型传输媒体是一种物理传输媒体，它提供了一个明确的路径，以引导信号或数据传输。<ul>
<li>同轴电缆</li>
<li>双绞线</li>
<li>光纤</li>
</ul>
</li>
</ul>
</li>
<li>非导向型传输媒体：<ul>
<li>也称为无线传输媒体，不提供明确的物理路径来引导信号传输。相反，它们使用无线信号（通常是电磁波或无线电波）来传输数据。<ul>
<li>无线电波</li>
<li>红外线</li>
<li>激光</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输方式</p>
<ul>
<li>串行传输和并行传输：<ul>
<li>串行传输：<ul>
<li>串行传输是一种将数据位按照顺序一个接一个地传输的方式</li>
<li>在串行传输中，每个数据位都依次发送或接收，而且它们之间通常使用一个单独的信号线来传输。</li>
<li>通常用于长距离通信，因为它能够更好地保持数据的完整性，减少干扰和数据丢失的可能性。</li>
</ul>
</li>
<li>并行传输<ul>
<li>并行传输是一种同时传输多个数据位的方式。</li>
<li>在并行传输中，每个数据位都有自己的信号线，它们可以同时传输，因此在同一时间段内可以传输多个数据位。</li>
<li>并行传输同时传输多个数据位，适用于高速数据传输，但通常在短距离内使用。<br><img src="D:\Blog\source\img\串行传输和并行传输.png" srcset="/img/loading.gif" lazyload alt="串行传输和并行传输"></li>
</ul>
</li>
</ul>
</li>
<li>同步传输和异步传输：<ul>
<li>同步传输<ul>
<li>同步传输是一种以固定的时间间隔或时钟信号来传输数据的方式。</li>
<li>在同步传输中，数据被划分为块（帧）并以固定的速率传输，通常使用一个时钟信号来同步发送和接收端的数据传输。这样，接收端知道何时开始接收和解析数据，因为它可以根据时钟信号的节奏来同步数据位。</li>
</ul>
</li>
<li>异步传输<ul>
<li>异步传输是一种在数据帧之间没有固定的时间间隔或时钟信号的传输方式。</li>
<li>在异步传输中，数据帧的开始和结束由特殊的控制字符（称为起始位和停止位）标识，而不是通过定期的时钟信号。</li>
</ul>
</li>
</ul>
</li>
<li>单向通信、双向交替通信和双向同时通信<ul>
<li>单向通信：</li>
<li>双向交替通信：</li>
<li>双向同时通信：<br><img src="D:\Blog\source\img\单向通行等.png" srcset="/img/loading.gif" lazyload alt="单向通信等"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调制与编码"><a href="#调制与编码" class="headerlink" title="调制与编码"></a>调制与编码</h3><ul>
<li>调制与编码的作用<ul>
<li>编码：编码是将数字数据（0和1）转换为适合于传输媒体的信号的过程。</li>
<li>调制：调制是将数字信号转换为模拟信号（通常是电磁波）的过程。这是为了在无线通信或光纤通信等介质中传输数据。<br><img src="D:\Blog\source\img\调值与编码基本概念.png" srcset="/img/loading.gif" lazyload alt="调制与编码的作用"></li>
</ul>
</li>
<li>码元：在使用时间域的波形表示信号时，代表不同离散数值的<strong>基本波形</strong>称为码元。</li>
</ul>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul>
<li>信道复用技术：<ul>
<li>是一种用于在通信系统中有效地共享和利用通信信道的方法。它允许多个通信设备或数据流共享同一个物理信道，从而提高了通信系统的效率和资源利用率。</li>
<li>就是在一条传输媒体上同时传输多路用户的信号。</li>
</ul>
</li>
<li>常用技术：<ul>
<li>频分复用：<ul>
<li>频分复用将频率范围划分为多个不重叠的子信道，每个子信道用于一个通信设备或数据流。每个设备在其分配的频率带宽内进行通信。</li>
</ul>
</li>
<li>时分复用：<ul>
<li>时分复用将时间划分为若干个时隙（time slots），每个时隙用于一个通信设备或数据流。多个设备按时间顺序轮流使用信道，以便在不同的时间间隙内进行通信。</li>
</ul>
</li>
<li>波分复用：<ul>
<li>WDM是光纤通信中的一种频分复用技术，它利用不同波长（颜色）的光信号来传输多个数据流。每个波长对应一个不同的通信通道。</li>
</ul>
</li>
<li>码分复用：<ul>
<li>类似于一句话可以有不同的解释，每个设备都有自己的解释理论，因此实现一句话传输多种信息（每种设备根据自己的解密方式获取一种信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><hr>
<h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><ul>
<li>链路层<ul>
<li>它的主要功能是在物理介质上<strong>可靠地传输数据帧</strong>，并提供一些基本的<strong>错误检测</strong>和<strong>纠正机制</strong>。</li>
<li>它负责在物理层提供的传输介质上实现可靠的数据传输，同时进行<strong>地址解析</strong>、<strong>错误检测</strong>和<strong>流量控制</strong>等操作，以确保数据正确、高效地传输。</li>
</ul>
</li>
<li>与物理层的联动<ul>
<li>物理层和链路层共同协同工作，以实现端到端的数据传输。</li>
<li>物理层提供了将比特从一台计算机传输到另一台计算机的物理手段，而链路层在这些物理媒体上创建了数据帧，并确保这些数据帧能够准确无误地从一个节点传输到另一个节点。</li>
</ul>
</li>
<li>链路，数据链路，帧<ul>
<li>链路<ul>
<li>链路（Link）是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</li>
</ul>
</li>
<li>数据链路<ul>
<li>数据链路（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li>
</ul>
</li>
<li>帧<ul>
<li>帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。<br><img src="D:\Blog\source\img\链路层帧示意.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h3><ul>
<li><p>封装成帧和透明传输</p>
<ul>
<li>封装成帧<ul>
<li>封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加一个首部和一个尾部，使之成为帧。</li>
<li>帧是数据单元，那么传输的时候是以一连串的比特流进行传输，一次可能传输若干个帧，所以我们如何确定帧呢？<ul>
<li>我们可以在帧的首部和尾部添加标识进行定界<br><img src="D:\Blog\source\img\封装成帧.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>此时会面临一些问题<ul>
<li>当我们传输的数据里面有和定界标识符一样的数据怎么办呢？接收方如何确定该帧的界限呢？</li>
</ul>
</li>
<li>透明传输<ul>
<li>透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在一样。<ul>
<li>如何理解呢？<ul>
<li>首先，我们为什么要使用帧呢？<ul>
<li>前面已经说了，将数据封装成帧后，可以在链路层实现错误的检测，纠正以及地址的解析。</li>
</ul>
</li>
<li>但是有了帧就会出现一些负面问题，如我们上面所说的，对帧的界限识别出现差错。<ul>
<li>所以为了得到帧的好处消除帧的坏处，我们就要实现透明传输：实现链路层的功能，但是好像数据链路层不存在一样（消除副作用）。</li>
</ul>
</li>
</ul>
</li>
<li>解决帧的界限问题<ul>
<li>面向字节的物理链路使用字节填充的方法实现透明传输<ul>
<li>我们发送时对数据进行扫描，在界限符前面，以及转义符前面添加转义符。</li>
</ul>
</li>
<li>面向比特的物理链路使用比特填充的方法实现透明传输<ul>
<li>即挑选比较特别的码作为帧的界限符（如0111110），我们发送时对数据进行扫描，每5个1就在其中插入一个0，由此实现了数据区不会出现帧的界限符的情况，在接收时，我们再按照指定的方法将数据区的0删除即可还原为原数据。<br><img src="/source/img/%E8%A7%A3%E5%86%B3%E5%B8%A7%E7%95%8C%E9%99%90%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>差错检测</p>
<ul>
<li>误码的相关概念<ul>
<li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为比特差错）。<ul>
<li>比特0 -&gt; 比特1，比特1 -&gt; 比特0</li>
</ul>
</li>
<li>使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li>
</ul>
</li>
<li>如何检验呢？<ul>
<li>奇偶校验<ul>
<li>奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。</li>
<li>偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。</li>
<li>但是此方法容易出现漏检。</li>
</ul>
</li>
<li>循环冗余校验<ul>
<li>数据链路层广泛使用漏检率极低的循环冗余校验（Cyclic Redundancy Check，CRC）检错技术。<ul>
<li>收发双方约定好一个生成多项式G(X)。</li>
<li>发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码（冗余码），将冗余码添加到待发送数据的后面一起传输。</li>
<li>接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可靠传输</p>
<ul>
<li>可靠传输的相关概念<ul>
<li>使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特差错）。</li>
<li>出现差错之后该怎么办呢？<ul>
<li>数据链路层为上层提供服务有两种情况<ul>
<li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li>
<li>可靠传输服务：通过某种机制实现：发送方发送什么，接收方就接收什么。</li>
</ul>
</li>
</ul>
</li>
<li>传输差错<ul>
<li>误码</li>
<li>分组丢失</li>
<li>分组失序</li>
<li>分组重复</li>
</ul>
</li>
<li>可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。</li>
<li>可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求。</li>
</ul>
</li>
<li>可靠传输的实现<ul>
<li>停止-等待协议<ul>
<li>发送方发送数据给接收方 -&gt; 接收方进行差错检测，无差错，则接收，并且返回确认接收了该分组。如果有误码，接收方则丢弃，并且返回否认接收了该分组。</li>
<li>此时存在问题<ul>
<li>接收方若未接到数据，会进行无限制的等待<ul>
<li>所以在发送方添加超时计时器，每当发送一组数据后就启动计时器，长时间未返回结果，则重新发送</li>
</ul>
</li>
<li>传输可能出现重复，接收返回请求也可能出现错乱<ul>
<li>对发送方的数据分组进行编号</li>
<li>对接收方返回的接收或者否认进行编号<br><img src="D:\Blog\source\img\超时等待协议.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>回退N帧协议<ul>
<li>是对停止等待协议的优化：回退N帧协议采用流水线传输方式，并且利用发送窗口来限制发送方连续发送数据分组的数量<br><img src="D:\Blog\source\img\回退n帧优化.png" srcset="/img/loading.gif" lazyload>  </li>
<li>简单来说就是： 允许发送方连续发送多个数据包，而不需要等待每个数据包的确认。接收方使用一个窗口大小来指示可以接收的下一个期望的数据包序号。这种方法可以提高传输效率。</li>
<li>具体见高军老师ppt<br><img src="D:\Blog\source\img\回退n帧示意.png" srcset="/img/loading.gif" lazyload> </li>
<li>回退N帧协议的接收方采用累积确认方式。<ul>
<li>接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。</li>
<li>接收方何时发送累积确认分组，由具体实现决定。</li>
<li>确认分组ACKn表明序号为n及之前的所有数据分组都已正确接收。</li>
<li>优点：<ul>
<li>减少向网络中注入确认分组的数量。</li>
<li>即使确认分组丢失，也可能不必重传数据分组。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。</li>
</ul>
</li>
</ul>
</li>
<li>发送窗口𝑾_𝑻的取值范围是𝟏&lt;𝑾_𝑻≤ 2的n次方 - 1 ，如果超出范围，可能会出现分清楚此时传输的比特是新传输的还是重新传输的</li>
</ul>
</li>
<li>选择重传协议<ul>
<li>是对回退N帧协议的优化</li>
<li>为了使发送方仅重传出现差错的数据分组，接收方不再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。<br><img src="D:\Blog\source\img\选择性重传示意.png" srcset="/img/loading.gif" lazyload>  </li>
<li>发送窗口和接收窗口的最大值为：2的（n-1）次方，若故意取𝑾_𝑻&#x3D;𝟓，使得𝑾_𝑻+𝑾_𝑹≥𝟐^𝟑，接收方将无法分辨新旧数据分组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>以太网（Ethernet）是一种计算机网络技术，用于在局域网（LAN）中传输数据。它是最常见和广泛应用的局域网技术之一。</li>
<li>以太网使用一种称为CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection，具有载波侦听和冲突检测的多路访问）的协议来控制多台计算机同时访问网络时的数据冲突问题。</li>
<li>它采用了一种总线拓扑或星型拓扑的物理结构，允许多台计算机通过共享相同的传输媒介（通常是电缆或光纤）来进行通信。</li>
</ul>
<h4 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h4><ul>
<li>网络适配器和MAC地址<ul>
<li>网络适配器<ul>
<li>要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），网络适配器一般简称为“网卡”。</li>
<li>网络适配器是计算机与网络之间的桥梁，它负责管理数据在计算机和网络之间的传输，确保网络通信的顺畅和可靠性。</li>
<li>作用：<ul>
<li>连接计算机到网络</li>
<li>数据封装和解封</li>
<li>MAC地址管理：MAC地址用于在局域网中识别计算机和其他设备。网络适配器负责管理和维护这个地址。</li>
<li>网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换。<ul>
<li>在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I&#x2F;O总线以并行传输方式进行。</li>
<li>网卡与外部以太网（局域网）之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以串行方式进行的。<br><img src="D:\Blog\source\img\网卡的传输方式.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>MAC地址(物理地址，硬件地址)<ul>
<li>作用：使信息可以被准确的发送和接收</li>
<li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li>
<li>在每个主机发送的帧的首部中，都携带有发送主机（源主机）和接收主机（目的主机）的数据链路层地址。由于这类地址是用于媒体接入控制（Medium Access Control，MAC）的，因此被称为MAC地址<br><img src="D:\Blog\source\img\mac地址作用.png" srcset="/img/loading.gif" lazyload> </li>
<li>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。（如一个交换机有多个接口，所以可能会有多个MAC地址）</li>
<li>网卡从网络上每收到一个帧，就检查帧首部的目的MAC地址，进行如下的操作：<ol>
<li>如果目的MAC地址是广播地址（FF-FF-FF-FF-FF-FF），则接受该帧。</li>
<li>如果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。</li>
<li>如果目的MAC地址是网卡支持的多播地址，则接受该帧。</li>
<li>其他情况丢弃该帧</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>CSMA&#x2F;CD协议<ul>
<li>引出<ul>
<li>由于共享型以太网有着天然广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点。</li>
<li>当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。<br><img src="D:\Blog\source\img\信号碰撞.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA&#x2F;CD，它是载波监听多址接入&#x2F;碰撞检测（Carrier Sense Multiple Access Collision Detection）的英文缩写词。<ul>
<li>多址接入MA<ul>
<li>多个站点连接在一条总线上，竞争使用总线。</li>
</ul>
</li>
<li>载波监听CS<ul>
<li>每个站点在发送帧之前，先要检测一下总线上是否有其他站点在发送帧（“先听后说”）<ul>
<li>若检测到总线空闲96比特时间（发送96比特所耗费的时间，也称为帧间最小间隔），则发送这个帧；</li>
<li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。</li>
</ul>
</li>
</ul>
</li>
<li>碰撞检测CD<ul>
<li>每个正在发送帧的站点边发送边检测碰撞（“边说边听”）：<ul>
<li>一旦发现总线上出现碰撞，立即停止发送，退避一段随机时间后再次从载波监听开始进行发送（“一旦冲突，立即停说，等待时机，重新再说”）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享式以太网的争用期<ul>
<li>站点从发送帧开始，最多经过时长𝟐𝝉 （即𝜹→𝟎）就可检测出所发送的帧是否遭遇了碰撞。</li>
<li>共享总线以太网的端到端往返时间𝟐𝝉被称为争用期（Contention Period）或碰撞窗口（Collision Window）</li>
</ul>
</li>
<li>最小帧长和最大帧长<ul>
<li>最小帧长<ul>
<li>最小帧长是指以太网数据帧（Ethernet Frame）在物理层上必须具备的最小长度。以太网的最小帧长是64字节（包括64字节的数据和4字节的帧校验序列）。</li>
<li>这个最小帧长度是为了确保在网络中的数据帧在传输过程中具有足够的时间，以便其他设备能够检测到帧的存在，避免碰撞和丢失数据。</li>
</ul>
</li>
<li>最大帧长<ul>
<li>最大帧长是指以太网数据帧在物理层上允许的最大长度。以太网的最大帧长是1518字节（包括数据、帧头、帧校验序列和帧间隙）。</li>
<li>这个最大帧长度限制是为了确保在网络中传输的数据帧不会过大，从而防止网络拥塞和数据丢失。</li>
</ul>
</li>
</ul>
</li>
<li>共享式以太网的退避算法<ul>
<li>在使用CSMA&#x2F;CD协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。</li>
<li>共享总线以太网中的各站点采用截断二进制指数退避（Truncated Binary Exponential Backoff）算法来选择退避的随机时间。</li>
</ul>
</li>
</ul>
</li>
<li>使用集线器的共享式以太网<ul>
<li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器（Hub）。<br><img src="D:\Blog\source\img\集线器以太网.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>物理层扩展以太网<ul>
<li>扩展传输距离：<ul>
<li>在10BASE-T星型以太网中，可使用光纤和一对光纤调制解调器来扩展站点与集线器之间的距离。<br><img src="D:\Blog\source\img\光纤扩展距离.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>扩展覆盖范围和数量<ul>
<li>以太网集线器一般具有8~32个接口，如果要连接的站点数量超过了单个集线器能够提供的接口数量，就需要使用多个集线器，这样就可以连接成覆盖更大范围、连接更多站点的多级星型以太网。<br><img src="D:\Blog\source\img\集线器扩展范围和数量.png" srcset="/img/loading.gif" lazyload> </li>
<li>碰撞域<ul>
<li>指的是共享同一物理网络媒介的设备集合，它们在发送数据时可能会发生碰撞<br><img src="D:\Blog\source\img\扩展范围的碰撞域.png" srcset="/img/loading.gif" lazyload> </li>
<li>在物理层扩展的共享式以太网仍然是一个碰撞域，不能连接太多的站点，否则可能会出现大量的碰撞，导致平均吞吐量太低。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据链路层扩展以太网</li>
<li>网桥<ul>
<li>网桥是计算机网络中的网络设备，通常用于连接两个或多个局域网（LAN）或网络段，以便在它们之间传输数据</li>
<li>作用：<ul>
<li>网桥可以识别帧的结构。</li>
<li>网桥可以根据帧首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃所收到的帧。<br><img src="D:\Blog\source\img\网桥工作基本原理.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>网桥的自学习和转发帧<ul>
<li>转发表是如何建立的呢？<ul>
<li>透明网桥（Transparent Bridge）通过自学习算法建立转发表。</li>
<li>透明网桥中的“透明”，是指以太网中的各站点并不知道自己所发送的帧将会经过哪些网桥的转发，最终到达目的站点。也就是说，<strong>以太网中的各网桥对于各站点而言是看不见的</strong>。</li>
</ul>
</li>
<li>自学习和转发流程 ：<ol>
<li>网桥收到帧后进行登记（即自学习），登记的内容为帧的源MAC地址和进入网桥的接口号。</li>
<li>网桥根据帧的目的MAC地址和网桥的转发表对帧进行转发，包含以下三种情况：<ol>
<li><strong>明确转发：</strong>网桥知道应当从哪个接口转发帧。</li>
<li><strong>盲目转发：</strong>网桥不知道应当从哪个接口转发帧，只能将其通过除进入网桥的接口外的其他所有接口转发。</li>
<li><strong>丢弃：</strong>网桥知道不应该转发该帧，将其丢弃。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h4><ul>
<li>以太网交换机（以下简称交换机）本质上就是一个多接口的网桥：<ul>
<li>交换机自学习和转发帧的流程与网桥是相同的</li>
<li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机。</li>
<li>当交换机的接口与计算机或交换机连接时，可以工作在全双工方式，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞地传输数据，这样就不需要使用CSMA&#x2F;CD协议了。<br><img src="D:\Blog\source\img\交换机工作.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
<h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><ul>
<li>诞生背景：<ul>
<li>将多个站点通过一个或多个以太网交换机连接起来就构建出了交换式以太网。</li>
<li>交换式以太网中的所有站点都属于同一个广播域。</li>
<li>随着交换式以太网规模的扩大，广播域也相应扩大，<strong>巨大的广播域会带来一系列问题</strong><ul>
<li>广播风暴：广播风暴会浪费网络资源和各主机的CPU资源</li>
<li>难以管理和维护，带来潜在安全问题</li>
</ul>
</li>
</ul>
</li>
<li>分割广播域可以解决广播域太大导致的问题<ul>
<li>使用路由器可以隔离广播域（成本高）</li>
<li>虚拟局域网技术</li>
</ul>
</li>
<li>虚拟局域网（Virtual Local Area Network，VLAN）是一种将<strong>局域网内的站点划分成与物理位置无关的逻辑组的技术</strong>，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求。<ul>
<li>属于同一VLAN的站点之间可以直接进行通信，而不同VLAN中的站点之间不能直接通信。</li>
<li>连接在同一交换机上的多个站点可以属于不同的VLAN，而属于同一VLAN的多个站点可以连接在不同的交换机上。</li>
</ul>
</li>
<li>实现机制<ul>
<li>Access端口（默认）<ul>
<li>给“未打标签”的MAC帧打标签（根据端口自己的PVID），将PVID存入帧的VID中</li>
<li>若帧中的VID和接口的PVID值相同，则给帧去除标签，再进行转发，否则不转发</li>
</ul>
</li>
<li>Trunk端口<ul>
<li>既可以接收“未打标签”的MAC帧，也可以接收“已打标签”的802.1Q帧。若接收到普通以太网MAC帧时，根据接收帧的接口的PVID给帧“打标签”，这与Access接口的处理相同。</li>
<li>对于帧的VID值等于接口的PVID值的802.1Q帧，将其“去标签”转发；对于<strong>帧的VID值不等于接口的PVID值802.1Q帧</strong>，将其<strong>直接转发</strong>。因此，从Trunk接口转发出的帧，可能是普通以太网MAC帧，也可能是802.1Q帧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><ul>
<li>802.11无线局域网使用CSMA&#x2F;CA协议的原因<ul>
<li>对于802.11无线局域网，其使用无线信道传输数据，这与共享总线以太网使用有线传输介质不同。因此，802.11无线局域网<strong>不能简单照搬共享总线以太网使用的CSMA&#x2F;CD协议</strong>。<ul>
<li>由于无线信道的<strong>传输环境复杂且信号强度的动态范围非常大</strong>，在802.11无线网卡上接收到的信号强度一般都<strong>远远小于发送信号的强度</strong>，信号强度甚至相差百万倍。因此，如果要在802.11无线网卡上实现碰撞检测，对硬件的要求非常高。</li>
<li>即使能够在硬件上实现碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），还会<strong>出现无法检测到碰撞</strong>的情况，因此实现碰撞检测并没有意义。</li>
</ul>
</li>
</ul>
</li>
<li>无线局域网不能简单照搬共享总线以太网（有线局域网）使用的CSMA&#x2F;CD协议，而是不再实现碰撞检测CD功能，但在<strong>CSMA的基础上增加碰撞避免CA功能</strong>，即使用CSMA&#x2F;CA协议。<ul>
<li>CSMA&#x2F;CA协议<ul>
<li>若站点最初有数据要发送(而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li>
<li>否则，站点执行CSMA&#x2F;CA协议的退避算法。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li>
<li>当退避计时器时间减少到零时(这时信道只可能是空闲的)，站点就发送整个的帧并等待确认。</li>
<li>发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的步骤(2)开始，执行CSMA&#x2F;CA协议的退避算法，随机选定一段退避时间。</li>
<li>若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间)，就必须重传此帧(再次使用CSMA&#x2F;CA协议争用接入信道)，直到收到确认为止，或者经过若干次的重传失败后放弃发送。<br><img src="D:\Blog\source\img\CSMACA退避算法.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><hr>
<h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><ul>
<li>网络层的作用：<ul>
<li>网络层的主要任务就是<strong>将分组从源主机经过多个网络和多段链路传输到目的主机</strong>，可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。<ul>
<li>分组转发：根据转发表来确定向自己的哪个接口进行转发（转发表来自路由表）</li>
<li>路由选择：路由表来自<strong>路由选择协议</strong></li>
</ul>
</li>
</ul>
</li>
<li>网络层向上提供的两种服务：<ul>
<li><p>面向连接的虚电路服务<br><img src="D:\Blog\source\img\面向连接的虚电路服务.png" srcset="/img/loading.gif" lazyload> </p>
<ul>
<li>核心思想：<strong>可靠通信应由网络自身来保证</strong></li>
<li>必须首<strong>先建立网络层连接</strong>，保证通信双方所需的一切资源</li>
<li>通信双方沿着<strong>已经建立的虚电路</strong>发送分组</li>
<li>通信结束后，需要<strong>释放</strong>之前建立的虚电路</li>
<li>类似于在双方的网络层之间添加了一条“电话线”，不过是通过链路，路由器来模拟的。</li>
<li>表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li>
</ul>
</li>
<li><p>无连接的数据报服务<br><img src="D:\Blog\source\img\无连接的数据报服务.png" srcset="/img/loading.gif" lazyload> </p>
<ul>
<li>核心思想：<strong>可靠通信应由用户主机来保证</strong></li>
<li><strong>不需要建立网络层连接</strong></li>
<li>每个分组可以走<strong>不同的路径</strong>，因此，每个分组的首部<strong>必须携带目的主机的完整地址</strong></li>
<li>通信结束后，<strong>没有需要释放的连接</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网际协议（IP）"><a href="#网际协议（IP）" class="headerlink" title="网际协议（IP）"></a>网际协议（IP）</h3><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul>
<li>为什么要有IP以及其作用是什么？<ul>
<li>为什么?<ul>
<li>网络互联时<strong>结构各不相同</strong>，要将众多的异构型网络都互联，并且要让其可以进行<strong>互相通信</strong>，则会面临许多需要解决的问题：如网络接入机制，差错恢复方法，寻址方案等</li>
</ul>
</li>
<li>作用：<br><img src="D:\Blog\source\img\ip协议作用.png" srcset="/img/loading.gif" lazyload><ul>
<li>IP协议使得网络层可以<strong>屏蔽底层细节</strong>而专注网络层的数据转发  </li>
<li>当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们<strong>看不见互连的各网络的具体异构细节</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IPv4地址及其编制方法"><a href="#IPv4地址及其编制方法" class="headerlink" title="IPv4地址及其编制方法"></a>IPv4地址及其编制方法</h4><ul>
<li><p>IPv4地址概述</p>
<ul>
<li>IP是以网卡进行分配</li>
<li>IPv4地址是给因特网（Internet）上的<strong>每一个主机（或路由器）的每一个接口分配的</strong>一个在<strong>全世界范围内唯一</strong>的32比特的标识符。</li>
</ul>
</li>
<li><p>IPv4表示方法</p>
<ul>
<li>由于IPv4地址由32比特构成，不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</li>
</ul>
</li>
<li><p>IPv4地址的分类编址方法</p>
<ul>
<li><p>为什么要进行分类呢？</p>
<ul>
<li>由于不同分类下的IPV4地址可以更好的进行管理和分配</li>
<li>早期设计不灵活，由于需求的增加而新增一些分类，不同分类可以根据网络的主机规模来考虑</li>
</ul>
</li>
<li><p>32比特的IPv4地址分为：<strong>网络号</strong> + <strong>主机号</strong></p>
</li>
<li><p>网络号</p>
<ul>
<li>标志主机（或路由器）的接口所<strong>连接到的网络</strong></li>
<li>同一个网络中，<strong>不同主机（或路由器）的接口</strong>的IPv4地址的<strong>网络号必须相同</strong>，表示它们属于同一个网络。</li>
</ul>
</li>
<li><p>主机号</p>
<ul>
<li>标识主机（或路由器）的接口号</li>
<li><strong>同一个网络</strong>中，<strong>不同</strong>主机（或路由器）的接口的IPv4地址的主机号必须各不相同，以便<strong>区分各主机（或路由器）的接口</strong>。</li>
</ul>
</li>
<li><p>分类：<br><img src="D:\Blog\source\img\IPv4地址分类.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>分为A,B,C,D,E，差异见图</li>
<li>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</li>
<li>主机号为 <strong>“全0”</strong> 的地址是<strong>自身的网络地址</strong>（标识本网络），不能分配给主机（或路由器）的各接口。</li>
<li>主机号为 <strong>“全1”</strong>的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</li>
<li><img src="D:\Blog\source\img\A类地址.png" srcset="/img/loading.gif" lazyload></li>
<li><img src="D:\Blog\source\img\B类地址.png" srcset="/img/loading.gif" lazyload></li>
<li><img src="D:\Blog\source\img\C类网络.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li><p><img src="D:\Blog\source\img\各网络分类对比.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
</ul>
<p>多播地址是用于多播通信的特殊IP地址，多播允许将<strong>数据同时发送给一个组中的多个目标设备</strong>。即将数据发送给<strong>多播组</strong></p>
<h4 id="Ipv4地址划分子网编址方法"><a href="#Ipv4地址划分子网编址方法" class="headerlink" title="Ipv4地址划分子网编址方法"></a>Ipv4地址划分子网编址方法</h4><ul>
<li>为什么？<ul>
<li>随着更多的中小网络加入因特网，<strong>IPv4分类编址方法</strong>不够灵活、容易造成<strong>大量IPv4地址资源浪费</strong>的缺点就暴露出来了。</li>
<li>例如一个只有几个接口的网络申请一个A类地址，一个A类地址可以包含数千万接口，但只使用了几个，造成大量浪费。<br><img src="D:\Blog\source\img\分类编址浪费.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>子网<ul>
<li>子网就是前几位都相同，然后中间使用几位来划分子网，然后后几位再分配给设备接口。</li>
<li>如145.13.<strong>0</strong>.20和145.13.<strong>1</strong>.20，两者都是网络 145.13 以及用户接口 20，但是是不同子网 0,1，<strong>网络号+子网号+用户号</strong></li>
<li>子网地址其实属于网络地址</li>
</ul>
</li>
<li>子网掩码<ul>
<li>产生原因<ul>
<li>我们如何从网络地址中区分出子网地址在哪里？又是多少位呢？</li>
</ul>
</li>
<li>作用<ul>
<li><strong>子网掩码</strong>可以表明分类IPv4地址的<strong>主机号部分被借用了几个比特</strong>作为子网号。</li>
</ul>
</li>
<li>与IPv4地址类似，子网掩码也是由32比特构成的。<ul>
<li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li>
<li>之后的多个连续的比特0对应IPv4地址中的主机号。</li>
</ul>
</li>
<li>子网计算：<ul>
<li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，就可得到该IPv4地址所在子网的网络地址。<br><img src="D:\Blog\source\img\子网掩码获取子网网络地址.png" srcset="/img/loading.gif" lazyload><br><img src="D:\Blog\source\img\子网掩码例题.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Ipv4无分类编址方法"><a href="#Ipv4无分类编址方法" class="headerlink" title="Ipv4无分类编址方法"></a>Ipv4无分类编址方法</h4><ul>
<li>起因：<ul>
<li>IPv4地址的划分子网编址方法在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网(𝟐^(𝟐𝟒−𝟑)&#x3D;𝟐𝟎𝟗𝟕𝟏𝟓𝟐)由于其每个网络所包含的地址数量太小(𝟐^𝟖&#x3D;𝟐𝟓𝟔)，因此并没有得到充分使用，而因特网的IPv4地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li>
<li>为此，因特网工程任务组IETF又提出了<strong>采用无分类编址</strong>的方法，来解决IPv4地址资源紧张的问题，同时还专门成立IPv6工作组负责研究新版本的IP，以彻底解决IPv4地址耗尽问题。</li>
<li>1993年，因特网工程任务组IETF发布了<strong>无分类域间路由选择（Classless Inter-Domain Routing，CIDR ）</strong>的RFC文档[RFC1517~1519，RFC1520]。<ul>
<li>CIDR消除了传统A类、B类和C类地址以及划分子网的概念。</li>
<li>CIDR可以更加有效地分配IPv4地址资源，并且可以在IPv6使用之前允许因特网的规模继续增长。</li>
</ul>
</li>
</ul>
</li>
<li>构成<ul>
<li>无分类编址方法使用的<strong>地址掩码</strong>与划分子网使用的<strong>子网掩码</strong>类似，由32比特构成。<ul>
<li>左起连续比特1为对应的网络前缀</li>
<li>之后的连续比特0为对应的主机号<br><img src="D:\Blog\source\img\无分类掩码示例.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>为了简便起见，<strong>可以不明确给出配套的地址掩码的点分十进制形式</strong>，而是在无分类编址的IPv4地址后面<strong>加上斜线“&#x2F;”</strong>，在斜线之后写上网络前缀所占的比特数量（也就是地址掩码中左起连续比特1的数量），这种记法称为<strong>斜线记法</strong>。如：<strong>128.14.35.7 &#x2F; 20</strong>，则标识网络前缀是前20比特，主机号是32-20 &#x3D; 12比特</li>
</ul>
</li>
<li>好处<ul>
<li>使用无分类编址方法，可以根据客户的<strong>需要分配适当大小的CIDR地址块</strong>，因此可以更加有效地分配IPv4的地址空间。（因为主机号确定了用户数量，根据自定义的地址掩码，也可以操作主机号大小）</li>
<li>使用无分类编址方法的另一个好处是<strong>路由聚合</strong>（也称为构造超网）。 <ul>
<li>路由聚合就是：找到最大前缀<br><img src="D:\Blog\source\img\路由聚合.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IPv4地址与MAC地址"><a href="#IPv4地址与MAC地址" class="headerlink" title="IPv4地址与MAC地址"></a>IPv4地址与MAC地址</h4><ul>
<li><p>IPv4地址与MAC地址的封装位置<br><img src="D:\Blog\source\img\Ip地址与mac地址的封装.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>数据报传送过程中IPv4地址与MAC地址的变化情况<br><img src="D:\Blog\source\img\数据报传送ipmac变化情况.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>在数据报的传送过程中，数据报的<strong>源IP地址和目的IP地址保持不变</strong>。</li>
<li>在数据报的传送过程中，数据报的<strong>源MAC地址和目的MAC地址逐链路（或逐网络）改变</strong>。</li>
</ul>
</li>
<li><p>IPv4地址与MAC地址的关系</p>
<ul>
<li>如果仅使用MAC地址进行通信，则会出现以下主要问题：<ul>
<li>每台<strong>路由器的路由表</strong>中就必须记录因特网上<strong>所有</strong>主机和路由器各接口的MAC地址。</li>
<li>手工配置表几乎不可能完成，路由表中<strong>海量的MAC地址信息会严重占用通信资源</strong>。</li>
<li>查找转发表也会带来极大的时延。</li>
</ul>
</li>
<li>因特网的网际层使用<strong>IP地址进行寻址</strong>，就可使因特网中各路由器的路由表中的路由记录的数量大大减少，因为<strong>只需记录部分网络的网络地址</strong>，而不是记录每个网络中各通信设备的各接口的MAC地址。<ul>
<li>路由器收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的<strong>路由表进行查表转发</strong>。</li>
<li>查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但<strong>无法指明该IP地址所对应的MAC地址</strong>。</li>
<li>根据地址解析协议ARP来解决</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><ul>
<li>地址解析协议<strong>ARP</strong>（Address Resolution Protocol）<ul>
<li>根据IP地址获取目标MAC地址</li>
</ul>
</li>
<li>过程<br><img src="D:\Blog\source\img\arp协议过程.png" srcset="/img/loading.gif" lazyload><ul>
<li>如果a要发送数据报给b<ul>
<li>a会知道b的ip地址，但是不知道b的mac地址（在自身的arp高速缓存表中查找不到），在数据链路层封装mac帧时会无法填写目的mac地址</li>
<li>a会向网络发起广播（我是a，我的ip地址是ip-a，我的mac地址是mac-a，我想知道ip-b的mac地址）</li>
<li>其他设备收到广播后会进行解析，如果与广播中请求的ip地址符合则会接收并且返回，否则不予理会。</li>
<li>b会接收报文，将a的ip地址以及mac地址存到自己的arp告诉缓存表，并且给a发送arp相应，告知其自己的mac地址</li>
</ul>
</li>
<li>arp包含字段：IP地址、MAC地址以及类型（动态，静态）<ul>
<li>静态一般是手工配置</li>
<li>动态一般有生命周期（2分钟）<ul>
<li>因为ip地址和mac地址不总是一成不变，更换网卡，mac地址就改变了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IP数据报的发送与转发"><a href="#IP数据报的发送与转发" class="headerlink" title="IP数据报的发送与转发"></a>IP数据报的发送与转发</h4><ul>
<li>流程<ul>
<li>主机发送IP数据报<ul>
<li>在同一个网络中就直接交付，不同网络中间接交付</li>
<li>源主机如何判断出目的主机是否与自己在同一个网络中？<ul>
<li>c 转发给不同网络的 f，c 知道 f 的ip地址，根据分类掩码，将自己的网络前缀和f的对比，查看是否相同（是否属于同一个网络）</li>
</ul>
</li>
<li>交给哪个路由器转发呢？<ul>
<li>实际上，用户为了让本网络中的主机，能和其它网络中的主机进行通信，就必须给其<strong>指定本网络中的一个路由器</strong>，由该路由器帮忙进行转发，所指定的路由器，也被称为默认网关（就是一个保安）</li>
<li>这样，当本网络中的主机要和其它主机进行通信时，会将IP数据报传输给默认网关。由默认网关帮主机将IP数据报转发出去。</li>
</ul>
</li>
</ul>
</li>
<li>路由器转发IP数据报<ul>
<li>那么路由器收到IP数据报之后又是如何转发的呢？<ul>
<li>检查IP数据报首部是否出错：若出错，丢弃并告诉源主机，<strong>没错就转发</strong>。</li>
<li>根据IP数据报的目的地址在<strong>路由表中找匹配的记录</strong>，找到就转发给下一个该转发的，找不到就丢弃该IP数据报并告诉主机你这个我转发不了。</li>
<li>路由器不会转发广播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h4><p><img src="D:\Blog\source\img\IPv4数据报的首部格式.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>**版本(4bit)**：指明了IP协议的版本，IPv4还是IPv6；通信双方的版本要一致</li>
<li>**首部长度(4bit)**：指明了IP数据报头部的长度，以4字节为单位（和TCP数据报中的数据偏移字段类似）</li>
<li>**可选字段(1~40字节)**：可增加一些拓展功能，但很少使用，该字段的拓展直接影响了首部长度字段</li>
<li><strong>填充字段</strong>：IP数据报头部的长度要求是4的整数倍，因此需要该字段填充补0，使头部满足要求</li>
<li>**区分服务(1字节)**：一般不使用，用于提供不同等级的服务质量</li>
<li>**总长度(2字节)**：指明了整个IP数据报的长度,以字节为单位，首部长度换算成字节后，总长度 - 首部长度 &#x3D; 数据载荷的长度</li>
<li><strong>标识、标志、片偏移</strong>：这三个字段共同说明了IP的分片情况<ul>
<li>标识：16bit，就是一个数字；属于同一个IP数据报的子分片有相同的标识；IP协议栈维持一个计数器，每产生一个数据报，就将标识值加1，然后赋值给标识字段</li>
<li>标志：3bit，分别是DF、MF、保留位<ul>
<li>DF：DF&#x3D;1表示不允许分片，DF&#x3D;0表示允许分片</li>
<li>MF：MF&#x3D;1表示后边还有分片，MF&#x3D;0表示后边没有分片，这就是最后一个分片</li>
<li>保留位：暂不使用，为0</li>
<li>片偏移：13bit，以8字节为单位，这也就要求：如果要分片，只要不是最后一个IP片，其数据载荷长度都必须是8的倍数；该字段指明了分片数据报载荷部分首字节相对于其原始数据报偏移了多少字节，如第一个IP分片的数据报为原始数据载荷的0~800，那该IP分片的片偏移为0&#x2F;8&#x3D;0；第二个分片的片偏移就是800&#x2F;8&#x3D;100；</li>
</ul>
</li>
</ul>
</li>
<li>**生存时间TTL(Time To Live)(8bit)**：指明了IP数据报的生存时间还有多少<ul>
<li>当前是以跳数为单位，路由器转发IP数据报时，先将该字段减1，若不为0则转发；若为0，则表示其生存时间无了，也就是该数据包失效了，就不转发</li>
<li>主要是为了避免发生路由环路时，IP数据报在环路内永久兜圈</li>
</ul>
</li>
<li>**协议字段(8bit)**：指明了IP数据包的数据载荷部分包装的是何种协议数据单元PDU，该字段是网络层与运输层之间的接口，通过该字段的标识，可以将IP数据报正确的交给运输层的某个协议模块处理</li>
<li>**首部检验和(16bit)**：用于在IP报的转发、发送过程中校验IP头部。因为IP头部是动态变化的，所以该校验和也是动态变化的。这一点与TCP的校验和不同（TCP校验的是头部和数据载荷也即整个TCP报文段，且转发途中不会动态变化）</li>
<li>**源IP地址和目的IP地址(各占32bit，4字节)**：用于标识发送方的IP地址和接收方的IP地址，可以说是最重要的字段存在了</li>
</ol>
<h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><ul>
<li>静态路由<ul>
<li>静态路由配置是指用户或者网络运维人员使用路由器的相关命令给路由器<strong>人工配置路由表</strong></li>
<li>人工配置方式<strong>简单、开销小</strong>、但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>，一般只在小规模网络中采用。</li>
</ul>
</li>
<li>默认路由<ul>
<li>当路由器在路由表中找不到目的地址的具体路由时，会才有用默认路由</li>
</ul>
</li>
<li>静态路由配置可能存在的问题<ul>
<li>路由条目<strong>配置错误</strong>，可能导致出现<strong>路由环路</strong></li>
<li>聚合路由条目时可能引入不存在的网络</li>
</ul>
</li>
</ul>
<h3 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h3><h4 id="路由选择分类"><a href="#路由选择分类" class="headerlink" title="路由选择分类"></a>路由选择分类</h4><ul>
<li>静态路由选择<ul>
<li>简单，开销小，但不能及时适应网络状态的变化</li>
<li>一般只能在小规模网络中使用</li>
</ul>
</li>
<li>动态路由选择<ul>
<li>动态路由：路由器通过路由选择协议<strong>自动获取</strong>路由信息</li>
<li>比较复杂，开销大，但是能较好地适应网络状态的变化</li>
<li>适用于大规模网络</li>
</ul>
</li>
<li>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：<ul>
<li>自适应：因特网采用动态路由选择，能较好地适应网络状态的变化。</li>
<li>分布式：因特网中的各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li>
<li>分层次：<ul>
<li>将整个因特网划分为许多较小的<strong>自治系统（Autonomous System，AS）</strong>。</li>
<li>在自治系统内部和外部采用<strong>不同类别</strong>的路由选择协议，分别进行路由选择。<br><img src="D:\Blog\source\img\分层次路由选择协议.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="路由信息协议"><a href="#路由信息协议" class="headerlink" title="路由信息协议"></a>路由信息协议</h4><ul>
<li>相关概念<ul>
<li>路由信息协议（Routing Information Protocol)是内部网关协议最先得到广泛使用的协议</li>
<li>RIP要求自治系统AS内的每一个路由器，都要维护从它<strong>自己到AS内其他每一个网络的距离记录</strong>。这是一组距离，称为距离向量（Distance-Vector，D-V）。</li>
<li>RIP使用跳数（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。<ul>
<li>RIP将路由器到直连网络的距离定义为1。</li>
<li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li>
<li>RIP允许一条路径最多只能包含15个路由器，距离等于16时相当于不可达。因此RIP只适用于小型互联网。</li>
</ul>
</li>
</ul>
</li>
<li>工作流程<ol>
<li>路由器刚开始工作时，只知道自己到直连网络的RIP距离为1。</li>
<li>每个路由器仅和相邻路由器周期性的交换并更新路由信息</li>
<li>若干次交换和更新后，每个路由器都知道到达本自治系统AS内各网络的最短距离和下一跳路由器，称为收敛。</li>
</ol>
</li>
<li>问题<ul>
<li>坏消息传播得慢</li>
<li>当线路故障的消息没有及时更新的时候，一些路由器会被另一些可达的未更新的路由器所误导，导致故障信息传播的十分缓慢。</li>
<li>优化<ul>
<li>限制距离</li>
<li>即时更新，而不是周期性更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="开放最短路径优先协议"><a href="#开放最短路径优先协议" class="headerlink" title="开放最短路径优先协议"></a>开放最短路径优先协议</h4><ul>
<li>概念<ul>
<li>开放最短路径优先（Open Shortest Path First，OSPF）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的。</li>
<li>使用了迪杰斯特拉的最短路径算法</li>
<li>通过相邻路由器之间的互相问候分组，来建立和维护邻居关系</li>
</ul>
</li>
<li>工作过程<ol>
<li>使用问候发现和维护邻居路由器的可达性</li>
<li>展示自己的数据给邻居</li>
<li>互相请求需要的数据</li>
<li>更新数据（洪泛法）类似广播</li>
</ol>
</li>
<li>优化<ul>
<li>为了使OSPF协议能够用于规模很大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围，称为区域（area）。</li>
<li>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统AS，这样就减少了整个网络上的通信量。<br><img src="D:\Blog\source\img\ospf划分区域.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
<h4 id="边界网关协议"><a href="#边界网关协议" class="headerlink" title="边界网关协议"></a>边界网关协议</h4><ul>
<li>概念<ul>
<li>边界网关协议（Border Gateway Protocol，BGP）属于外部网关协议EGP这个类别，用于<strong>自治系统AS之间</strong>的路由选择协议。</li>
</ul>
</li>
<li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由。</li>
</ul>
<h4 id="路由器的基本工作原理"><a href="#路由器的基本工作原理" class="headerlink" title="路由器的基本工作原理"></a>路由器的基本工作原理</h4><ul>
<li>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是<strong>转发分组</strong>。<br><img src="D:\Blog\source\img\路由器基本原理.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="网际控制报文协议（ICMP）"><a href="#网际控制报文协议（ICMP）" class="headerlink" title="网际控制报文协议（ICMP）"></a>网际控制报文协议（ICMP）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>为了<strong>更有效地转发IP数据报</strong>以及提高IP数据报交付成功的机会，TCP&#x2F;IP体系结构的网际层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）[RFC 792]。</li>
<li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li>
<li>ICMP报文被封装在IP数据报中发送。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p><strong>差错报告报文</strong>：用来向主机或路由器报告差错情况</p>
<ul>
<li>终点不可达<ul>
<li>当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文。</li>
</ul>
</li>
<li>源点抑制<ul>
<li>当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li>
</ul>
</li>
<li>超时<ul>
<li>收到数据报后，若TTL结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文。</li>
<li>在预先规定的时间内未能收到一个数据报的全部数据报分片时，也会发送超时报文</li>
</ul>
</li>
<li>参数问题<ul>
<li>路由器检测到数据报首部误码丢弃该数据报，并且发送参数问题报文</li>
</ul>
</li>
<li>改变路由（重定向）<ul>
<li>路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样<strong>可以通过更好的路由</strong>到达目的主机。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>询问报文</strong>：用来向主机或路由器询问情况</p>
<ul>
<li>回送请求和回答<ul>
<li>用来测试目的站是否可达以及了解其有关状态。</li>
</ul>
</li>
<li>时间戳请求和回答<ul>
<li>用来进行时钟同步和测量时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟专用网和网络地址转换"><a href="#虚拟专用网和网络地址转换" class="headerlink" title="虚拟专用网和网络地址转换"></a>虚拟专用网和网络地址转换</h3><h4 id="虚拟专用网"><a href="#虚拟专用网" class="headerlink" title="虚拟专用网"></a>虚拟专用网</h4><ul>
<li>虚拟专用网（Vitual Private Network）：<ul>
<li>我们如何让两个专用网络进行通信呢？<ul>
<li>直接花钱连线</li>
<li>使用因特网作为载体</li>
</ul>
</li>
<li>利用公用的因特网作文本机构和专用网之间的通信载体。</li>
</ul>
</li>
<li>公用网和专用网的区别是什么呢？<ul>
<li>公用网的ip全是公开的，专用网为了安全考虑，ip都是不公开的</li>
</ul>
</li>
<li>如何实现<ul>
<li>我们需要在两个专用网中分别使用一个路由器，路由器可以连接公网</li>
<li>将专网的内部ip加密封装到数据报之中，通过路由器转发到公网</li>
<li>转发的地址是目的专网的路由器的公网地址</li>
<li>目的专网收到之后，进行解析即可</li>
</ul>
</li>
</ul>
<h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><ul>
<li><p>为什么需要？</p>
<ul>
<li>主要解决IPv4地址紧缺的问题，通过将<strong>一个公网IP地址和多个私网IP</strong>相对应，从而解决IP地址不够用的情况</li>
</ul>
</li>
<li><p>如何实现</p>
<ul>
<li>使用NAT软件，并且至少有一个有效的全球地址ip</li>
<li>当私网通过NAT时，会将其转换为公网在因特网传输<br><img src="D:\Blog\source\img\NAT过程.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li><p>优化:网络地址与端口号转换方法</p>
<ul>
<li>由于目前绝大多数基于TCP&#x2F;IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，为了更加有效地利用NAT路由器中的全球IP地址，现在常将NAT转换和运输层端口号结合使用。<ul>
<li>这样就可以使内部专用网中使用专用地址的大量主机，共用NAT路由器上的1个全球IP地址，因而可以同时与因特网中的不同主机进行通信。<br><img src="D:\Blog\source\img\网络地址与端口号转换.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>内网的地址和端口号都可能不同，但是通过NAPT发送时，就直接使用：公用地址 ： NAPT自己分配的端口，并且存到转换表之中，便于之后的操作。</p>
<h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>多播（Multicast，也称为组播）是一种实现“一对多”通信的技术，与传统单播“一对一”通信相比，多播可以极大地节省网络资源。</li>
<li>在因特网上进行的多播，称为IP多播。<br><img src="D:\Blog\source\img\ip多播.png" srcset="/img/loading.gif" lazyload></li>
<li>可以减少网络中资源的消耗</li>
</ul>
<h4 id="IP多播地址和多播组"><a href="#IP多播地址和多播组" class="headerlink" title="IP多播地址和多播组"></a>IP多播地址和多播组</h4><ul>
<li>在IPv4中，<strong>D类地址</strong>被作为多播地址。</li>
<li><strong>多播地址只能用作目的地址</strong>，而不能用作源地址。</li>
<li>一个多播地址确定一个多播组</li>
</ul>
<h4 id="局域网上进行硬件多播"><a href="#局域网上进行硬件多播" class="headerlink" title="局域网上进行硬件多播"></a>局域网上进行硬件多播</h4><ul>
<li>硬件多播其实就是多播MAC地址，只需要把IPv4的多播地址转换为MAC地址即可</li>
<li>由于IP多播地址可变化的28比特的前5个比特无法映射到MAC多播地址，<strong>这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的</strong>。<ul>
<li>所以在链路层判断MAC地址正确后，还会将数据上传至网络层，进行IP地址的判断，从而确定正确的传输</li>
</ul>
</li>
</ul>
<h4 id="因特网上进行IP多播需要的两种协议"><a href="#因特网上进行IP多播需要的两种协议" class="headerlink" title="因特网上进行IP多播需要的两种协议"></a>因特网上进行IP多播需要的两种协议</h4><ul>
<li>引出<ul>
<li>要在因特网上进行IP多播，<strong>要考虑IP多播数据报经过多个多播路由器进行转发的问题</strong>。<ul>
<li>多播路由器必须根据IP多播数据报首部中的IP多播地址，将其转发到有该多播组成员的局域网。</li>
</ul>
</li>
<li>那么路由器如何知道自己的接口所在局域网有哪些多播成员呢？<ul>
<li>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。</li>
<li>需要使用多播路由选择协议来解决</li>
</ul>
</li>
</ul>
</li>
<li>多播路由选择协议<ul>
<li>过程<ul>
<li>主要任务是：在多播路由器之间为每个多播组建立一个多播转发树</li>
<li>多播转发树连接多播源和所有拥有该多播组成员的路由器。</li>
<li>IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器。</li>
<li>之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员。</li>
</ul>
</li>
</ul>
</li>
<li><strong>网际组管理协议（IGMP）：维护多播组与其成员关系</strong><ul>
<li>报文类型<ul>
<li>成员报告报文</li>
<li>成员查询报文</li>
<li>离开组报文</li>
</ul>
</li>
<li>加入多播组<ul>
<li>发送成员报告报文申请加入</li>
</ul>
</li>
<li>监听多播组成员变化<ul>
<li>多播路由器定时发送成员查询报文（广播）</li>
<li>成功接收到报文的组员会延时随机时间后发送请求（成员报告报文），</li>
<li>如果该组有一个成员（延时最短的）已经发送报告报文了，那么该组其他的成员就取消发送，这样可以减少资源浪费</li>
<li>长时间未收到响应，会将该组从多播组中删除</li>
</ul>
</li>
<li>退出多播组<ul>
<li>当主机要退出某个多播组时，可<strong>主动发送</strong>一个离开组报文而不必等待多播路由器的查询。</li>
<li>这样可使多播路由器能够更快地发现某个组有成员离开。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>背景<ul>
<li>IPv4不够用</li>
</ul>
</li>
<li>变化<ul>
<li>IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。</li>
<li>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</li>
<li>更大的地址空间</li>
<li>扩展的地址层次结构，灵活的首部等</li>
<li>IPv6 的地址主要有以下类型地址：<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IPv6数据报的首部"><a href="#IPv6数据报的首部" class="headerlink" title="IPv6数据报的首部"></a>IPv6数据报的首部</h4><p><img src="D:\Blog\source\img\ipv4对比ipv6.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>取消了首部校验和字段。</li>
<li>取消了分片&#x2F;重新组装相关字段。</li>
<li>取消选项字段。</li>
</ul>
<h4 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h4><ul>
<li>使用双协议栈<ul>
<li>使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li>
<li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li>
<li>根据需要进行转换</li>
<li>会漏一些信息</li>
</ul>
</li>
<li>使用隧道技术<ul>
<li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li>
<li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li>
</ul>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><hr>
<h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><ul>
<li>进程间基于网络通信（<strong>运输层作用</strong>）<ul>
<li>物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了<strong>主机到主机的通信</strong>。</li>
<li>然而在计算机网络中<strong>实际进行通信的真正实体，是位于通信两端主机中的进程</strong>。</li>
<li>如何为<strong>运行在不同主机上的应用进程</strong>提供直接的逻辑通信服务，就是运输层的主要任务。运输层协议又称为端到端协议。</li>
<li>运输层向应用层实体<strong>屏蔽了下面网络核心的细节</strong>（例如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条<strong>端到端的逻辑通信信道</strong>。<br><img src="D:\Blog\source\img\进程间基于网络通信.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>运输层端口号<ul>
<li>运行在计算机上的进程是使用进程标识符（Process Identification，PID）来标识的（每个PCB（进程控制块）由其唯一的PID标识）<ul>
<li>因特网也有其类似的实现，使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识</li>
</ul>
</li>
<li>TCP&#x2F;IP体系结构的运输层使用<strong>端口号</strong>来标识和区分应用层的不同应用进程。端口号的长度为16比特，取值范围是0~65535。<br><img src="D:\Blog\source\img\端口号的分配.png" srcset="/img/loading.gif" lazyload></li>
<li>端口号应用举例<ul>
<li>用户端根据域名向DNS服务器发起请求（通过标识自己的端口号，以及目标端口号），申请获取该域名的IP地址<ul>
<li>DNS服务器：存储了域名和对应IP，类似于一个电话簿</li>
</ul>
</li>
<li>DNS返回IP地址</li>
<li>用户端根据IP地址发起请求访问Web服务器</li>
<li>Web服务器根据请求，返回内容</li>
<li>**上述交流信息的TCP首部均包含了”源端口”以及”目的端口”的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP基本概览"><a href="#TCP基本概览" class="headerlink" title="TCP基本概览"></a>TCP基本概览</h4><ul>
<li>什么是 TCP ？<ul>
<li>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。<ul>
<li><strong>面向连接：</strong>一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的：</strong>无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流传输：</strong>用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式  "></a>TCP报文段的首部格式  <img src="D:\Blog\source\img\tcp报文首部格式.png" srcset="/img/loading.gif" lazyload></h4><h4 id="控制位"><a href="#控制位" class="headerlink" title="控制位"></a>控制位</h4><p><strong>控制位</strong></p>
<ol>
<li>URG（Urgent）：表示紧急指针（Urgent Pointer）字段有效。当该位被置为1时，表示当前报文段中的数据具有紧急性，需要优先处理。紧急指针用于指示报文段中的紧急数据的结束位置。</li>
<li><strong>ACK（Acknowledgment）：表示确认序号（Acknowledgment Number）字段有效。当该位被置为1时，表示确认字段中的值是有效的，即确认接收到的数据。在建立连接后，TCP通信中的大多数报文都会将ACK置为1。</strong></li>
<li>PSH（Push）：表示推送数据。当该位被置为1时，表示接收方应该尽快将接收到的数据交给上层应用，而不是等待缓冲区填满或等待延时定时器到期。</li>
<li>RST（Reset）：表示连接复位。当该位被置为1时，表示发生了错误或异常情况，需要立即中断当前连接。接收到RST标志的一方会立即关闭连接。</li>
<li><strong>SYN（Synchronize）：表示建立连接请求。当该位被置为1时，表示发送方希望建立一个新的连接，并指明初始序列号。</strong></li>
<li><strong>FIN（Finish）：表示结束连接。当该位被置为1时，表示发送方已经完成了数据的发送，并要求关闭连接。接收到FIN标志的一方会发送ACK作为回应，并逐渐关闭连接。</strong></li>
</ol>
<p>这些控制位的组合和交互使用，使得TCP协议能够进行可靠的连接建立、数据传输和连接关闭。通过这些控制位，TCP可以实现流量控制、拥塞控制、数据完整性和可靠性等功能。</p>
<h4 id="确认号和序列号"><a href="#确认号和序列号" class="headerlink" title="确认号和序列号"></a>确认号和序列号</h4><ul>
<li><p>作用：</p>
<ul>
<li>序列号：初次建立是随机数，之后每发送一次数据就累加一次该数据字数的大小，用来<strong>解决包乱序问题</strong></li>
<li>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>
</ul>
</li>
<li><p><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></p>
</li>
<li><p><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></p>
<p><img src="D:\Blog\source\img\TCP中的确认号和序列号.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h4 id="三报文握手-建立TCP连接"><a href="#三报文握手-建立TCP连接" class="headerlink" title="三报文握手 建立TCP连接"></a>三报文握手 建立TCP连接</h4><ul>
<li><p>“三报文握手”建立TCP连接的目的</p>
<ul>
<li>使TCP双方能够确知对方的存在。</li>
<li>使TCP双方能够协商一些参数（例如最大报文段长度、最大窗口大小、时间戳选项等）。</li>
<li>使TCP双方能够对运输实体资源进行分配和初始化。运输实体资源包括缓存大小、各状态变量、连接表中的项目等。</li>
</ul>
</li>
<li><p>流程<br><img src="D:\Blog\source\img\三次握手.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>为何不能省去第三次</p>
<ul>
<li><p>避免资源的浪费</p>
<ul>
<li>当客户端的一个请求阻塞时，会重新发送请求，然后和服务端建立连接。</li>
<li>再传输数据后，会关闭连接</li>
<li>此时之前阻塞的请求又发送到了服务端，因为服务端是被动打开的，所以服务端根据请求会发送确认报文。</li>
<li>但是此时的客户端已经关闭，而且无法被服务端给唤醒，所以不会理财服务端的请求</li>
<li>此时服务端会一直开启并且等待客户端响应，浪费了资源</li>
</ul>
<p><img src="D:\Blog\source\img\两次握手.png" srcset="/img/loading.gif" lazyload> </p>
</li>
<li><p>如果有了第三次</p>
<ul>
<li>当滞留的请求到达服务器，服务器会向客户端发送连接确认报文，然后会等待第三次握手（因此可以检测到客户端有没有关闭）</li>
<li>如果如上面的情况，客户端关闭了，那么客户端不会返回请求给服务端，服务端会超时重传，并且不会一直死等，一定时间就关闭，不像上面那样进入连接已建立状态，然后一直白白等。</li>
</ul>
</li>
<li><p>历史连接问题：</p>
<p><img src="D:\Blog\source\img\三次握手避免历史连接.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>如果没有第三次握手，那么第二次握手返回ACKNum的时候，客户端可能没有机会进行检验并且告诉服务端：这是历史连接！，因为当第二次握手结束连接就可能建立了</li>
</ul>
</li>
</ul>
</li>
<li><p>第一次握手丢失：</p>
<ul>
<li>第一次握手（告诉服务端，我想和你进行连接）</li>
<li>如果丢失，客户端发送后未得到服务端的确认请求，那么会进行超时重传，达到一定次数后，会等待一定时间，如果还是没有收到确认（第二次握手）那么会断开连接（主动方：客户端）</li>
</ul>
</li>
<li><p>第二次握手丢失：</p>
<ul>
<li>第二次握手（服务端发送确认通知）</li>
<li>此时客户端等待服务端的确认（第二次握手），服务端等待客户端的确认（第三次握手）</li>
<li>客户端没有得到第二次握手，会进行超时重传（上限一次），然后等待一段时间，如果没有收到，客户端断开连接</li>
<li>服务端没有收到第三次握手也会进行超时重传（上限两次），然后再等待一段时间，如果还是没有收到，那么服务端会断开连接</li>
</ul>
</li>
<li><p>第三次握手丢失：</p>
<ul>
<li>第三次握手（客户端接收到服务端的确认通知之后，会向其返回第三次握手，此时，客户端进入ESTABLISHED状态）</li>
<li>服务端发起确认（第二次握手）后会进行重传（上限两次），达到上限会进行一段时间等待，如果还是没有收到第三次握手，服务端断开连接。</li>
</ul>
</li>
<li><p>第三次握手可以携带数据，前两次握手不可携带数据</p>
</li>
</ul>
<h5 id="半连接全连接队列"><a href="#半连接全连接队列" class="headerlink" title="半连接全连接队列"></a>半连接全连接队列</h5><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列（已经建立好连接的连接）等待使用</strong></p>
<p><strong>作用：</strong></p>
<ul>
<li><strong>实现超时处理</strong>：如果某个连接在一定时间内没有完成第二次握手，那么可以将其从半连接队列中移除，释放相关资源</li>
<li><strong>控制未完成连接的数量</strong>：半连接队列可以限制半连接的个数，防止过多的半连接导致服务器资源不足</li>
<li><strong>实现连接的临时存储</strong>：由于服务器可能在某些情况下无法立即处理完整个三次握手，例如服务器繁忙或负载较大，因此需要一种机制来保存已经接收到第一次握手的连接，但尚未完成第二次握手的状态。这就是半连接队列的作用。半连接队列用于存储这些未完成的连接，确保服务器在处理这些连接时不被过多占用，而不至于丢失这些连接请求。</li>
</ul>
<h4 id="四报文挥手-释放TCP连接"><a href="#四报文挥手-释放TCP连接" class="headerlink" title="四报文挥手 释放TCP连接"></a>四报文挥手 释放TCP连接</h4><p><img src="D:\Blog\source\img\四次挥手.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>小问题<ul>
<li>不进行时间等待会怎么样？<ul>
<li>如果不进行时间等待，在客户端发送确认报文并加入关闭阶段时，服务端无法收到，因此无法关闭，而此时客户端已经关闭，无法进行超时重传<br><img src="D:\Blog\source\img\四次挥手时间等待作用.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
<li>第一次挥手丢失：<ul>
<li>第一次挥手（客户端让自己与服务端断开，并且自己不再传输数据给服务端）</li>
<li>如果丢失的话，客户端无法收到服务端发来的确认报文，这会触发客户端的重传机制</li>
<li>如果重传到了一定次数，那么会直接关闭连接</li>
</ul>
</li>
<li>第二次挥手丢失：<ul>
<li>第二次挥手（就是服务端对客户端的关闭请求的确认）</li>
<li>如果丢失，客户端无法收到确认报文，那么会触发客户端的超时重传机制</li>
<li>如果客户端重传到了一定次数还没有收到第二次挥手（确认），则会直接关闭连接</li>
</ul>
</li>
<li>第三次挥手丢失：<ul>
<li>第二次挥手之后，服务端可能还会有数据需要传输，所以会进入关闭等待状态。当服务端的数据传输完毕，就会进行第三次挥手，对服务端进行关闭。</li>
<li>服务端发起第三次挥手，但是没有收到确认之后，会进行超时重传</li>
<li>当重传达到一定的次数之后，再进行最后的一段时间的等待，还未收到确认，那么就会直接关闭。</li>
</ul>
</li>
<li>第四次挥手丢失：<ul>
<li>第四次挥手（确认收到服务端的关闭请求，并返回确认）</li>
<li>如果第四次挥手丢失，那么服务端会进行第三次挥手的超时重传，达到一定次数后，再等待一定时间后，如果还是没有收到确认，那么会直接关闭</li>
</ul>
</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li>流量控制的基本概念<br><img src="D:\Blog\source\img\流量控制的基本概念.png" srcset="/img/loading.gif" lazyload><ul>
<li>因为服务端应用程序可能正忙于其他任务，并不一定能够立刻取走数据。如果不根据此时服务接收方的接收缓存情况来进行流量控制的话，会造成数据的溢出丢失</li>
</ul>
</li>
<li>流量控制的过程<br><img src="D:\Blog\source\img\流量控制例子.png" srcset="/img/loading.gif" lazyload><ul>
<li>首先在建立 TCP 连接时，接收方会告诉发送方：我的接收窗口大小为400，此时，发送方会将自己的发送窗口大小也设为400</li>
<li>发送方会一个个的传输数据报，并且发送序列号</li>
<li>接收方会进行接受的确认以及流量的控制：如上图：确认报文，确认前200号的数据，调整滑动窗口为300</li>
<li>发送方根据返回的确认信息，知道自己到底有效的传输了多少的数据，然后进行滑动窗口的移动，以及删除发送缓存中已被接收的数据</li>
<li>发送方只发送自己发送窗口内的数据</li>
<li>发送窗口向前滑动的前提是发送窗口的数据确认被正确接收</li>
</ul>
</li>
<li>问题<ul>
<li>如果接收窗口为0，那么此时发送窗口也会相应变为0，此时该如何破解这个局面呢？<ul>
<li>当发送方的发送窗口变为0后，会启动一个持续计时器， 当计时结束，发送方会主动发送一个零窗口探测报文，接收方必须接收该报文</li>
</ul>
</li>
<li>如果零窗口探测报文丢失呢？<ul>
<li>零窗口探测报文段也有设置的有重传计时器，如果丢失，等待该计时器超时，然后重传零窗口探测报文段</li>
</ul>
</li>
<li>为什么接收方接收窗口为0时还能接收零窗口探测报文<ul>
<li>TCP规定，就算接收窗口为0，也必须接受零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li><p>拥塞控制的基本概念</p>
<ul>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞（congestion）。</li>
</ul>
</li>
<li><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。<br><img src="D:\Blog\source\img\拥塞吞吐量.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>流量控制与拥塞控制的区别</p>
<ul>
<li>流量控制是服务器可能正忙于其他任务，当接收缓存满了之后并一定能及时的取走数据，导致新来的数据会被丢弃</li>
<li>拥塞控制是指防止过多的数据注入到网络之中，使网络能够承受现有的网络负荷</li>
</ul>
</li>
<li><p>方法概念</p>
<ul>
<li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</li>
<li>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)</li>
<li>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法。</li>
<li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li>
<li>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意。</li>
</ul>
</li>
<li>如何确定网络拥塞？<ul>
<li>其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞控制的四种方法</p>
<ul>
<li><p>慢开始</p>
<ul>
<li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加倍</li>
</ul>
</li>
<li><p>拥塞避免</p>
<ul>
<li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</li>
</ul>
</li>
<li><p>快重传</p>
<ul>
<li><p>在没有快重传的时候，如果报文丢失那么会进行超时重传，需要等待一定时间，并且重传完毕后，会将ssthreash减半，并且将初始窗口转变为1，然后使用慢开始算法</p>
</li>
<li><p>快重传就是要求接收方在收到一个失序的报文段后就<strong>立即发出重复确认</strong>，而不是等到主机发送数据时捎带确认。</p>
</li>
<li><p>快重传规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="D:\Blog\source\img\快重传举例.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li><p>快恢复</p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="D:\Blog\source\img\拥塞控制.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h4><ul>
<li>以字节为单位的滑动窗口</li>
<li>超时重传（超时时间主要为加权平均往返时间）</li>
<li>选择确认</li>
</ul>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ul>
<li>连接<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
</li>
<li>服务对象<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
</li>
<li>可靠性<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
</li>
<li>拥塞控制，流量控制<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
</li>
<li>首部开销<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
</li>
<li>传输方式<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
</li>
<li>应用场景<ul>
<li>TCP<ul>
<li>FTP 文件传输</li>
<li>HTTP &#x2F; HTTPS</li>
</ul>
</li>
<li>UDP<ul>
<li>包总量较少的通信</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><hr>
<h3 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h3><ul>
<li>应用层的作用：<ul>
<li>解决通过应用进程的交互来实现特定网络应用的问题</li>
<li>我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是运输层。</li>
<li>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h4><ul>
<li>HTTP是什么<ul>
<li>HTTP是超文本传输协议：Hyper Text Transfer Protocol</li>
<li>协议：<ul>
<li>建立了交流通信的规范</li>
</ul>
</li>
<li>传输：<ul>
<li>HTTP协议是一个双向协议</li>
<li>允许有中转或接力（在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。）</li>
</ul>
</li>
<li>超文本：<ul>
<li>内容超文本</li>
<li>是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li>
</ul>
</li>
<li><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong><ul>
<li>可以是服务器到浏览器，也可以是服务器到服务器等。</li>
</ul>
</li>
</ul>
</li>
<li>HTTP常见状态码<ul>
<li><code>1xx</code>：提示信息</li>
<li><code>2xx</code>：服务器成功处理请求</li>
<li><code>3xx</code>：表示客户端请求的<strong>资源发生了变动</strong>，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong></li>
<li><code>4xx</code>：表示客户端发送的报文，服务器无法处理。<ul>
<li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
</li>
<li><code>5xx</code>：表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于<strong>服务端的错误</strong>。</li>
</ul>
</li>
<li>HTTP常见字段<ul>
<li>Host 字段<ul>
<li>客户端发送请求时，用来指定服务器的域名。</li>
</ul>
</li>
<li>Content-Length 字段<ul>
<li>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</li>
</ul>
</li>
<li>Connection 字段<ul>
<li>指定是什么类型的连接方式，如长连接等</li>
</ul>
</li>
<li>Content-Type 字段<ul>
<li>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li>
</ul>
</li>
<li>Content-Encoding 字段<ul>
<li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h4><ul>
<li>GET和POST的区别<ul>
<li>GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。</li>
<li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。</li>
</ul>
</li>
<li>GET和POST方法都是安全和幂等的吗？</li>
</ul>
<blockquote>
<p>安全：在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>幂等：所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
</blockquote>
<ul>
<li>GET方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</li>
<li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</li>
</ul>
<h4 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h4><ul>
<li><p>作用</p>
<ul>
<li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，提升服务的性能。</li>
</ul>
</li>
<li><p>强制缓存</p>
<ul>
<li>浏览器发现本地资源A后，根据与服务器的检验规则，<strong>浏览器给本地资源A进行检验</strong><ul>
<li>如果符合要求，浏览器直接返回该本地资源</li>
<li>如果不符合要求，浏览器会向服务器发送资源请求</li>
</ul>
</li>
<li>强缓存指的是只要<strong>浏览器判断缓存没有过期</strong>，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器这边。</strong></li>
<li>实现：<ul>
<li>利用HTTP响应头部(Response Header)字段实现<ul>
<li><code>Cache-Control</code>：相对时间，优先级更高</li>
<li><code>Expires</code>：绝对时间</li>
</ul>
</li>
</ul>
</li>
<li>流程：<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部添加Cache-Control，Cache-Control中设置了过期时间</li>
<li>当浏览器再次访问该资源时，会根据Cache-Control来计算该资源是否过期，如果没过期则直接使用，否则重新发起请求，服务器收到请求后，会更新Response头部的Cache-Control</li>
</ul>
</li>
<li><strong>当服务器的资源已经更新，但是缓存的时间还未到期，那么此时缓存保存的仍然是旧的数据。</strong></li>
</ul>
</li>
<li><p>协商缓存</p>
<ul>
<li>浏览器发现本地资源A后，浏览器给服务器发送一个请求，将资源A的相关信息告诉服务器，<strong>服务器对其进行检验</strong><ul>
<li>如果符合要求，浏览器直接返回该本地资源</li>
<li>如果不符合要求，服务器会直接返回一份新的资源A</li>
</ul>
</li>
<li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</li>
<li>实现：<ul>
<li>请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul>
<li>客户端会在请求头中使用<code>If-Modified-Since</code>，将之前获取资源时服务器返回的<code>Last-Modified</code>值发给服务器</li>
<li>服务器收到请求后，会将客户端返回的<code>If-Modified-Since</code>里的值（即本地缓存的最新修改时间），与服务器的最新修改时间对比</li>
<li>如果本地缓存仍然是最新的，那么返回304 Not Modified，客户端收到后则知道仍然可以使用缓存中的副本</li>
<li>如果缓存不是最新，服务器会返回新的资源，并且响应头中包含新的<code>Last-Modified</code>值</li>
</ul>
</li>
<li>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
</li>
<li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li>
<li>所以Etag的优先级更高</li>
</ul>
</li>
<li>Etag实现过程：<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的</li>
<li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<ul>
<li>如果没有过期，则直接使用本地缓存</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段（存的Etag值），该字段的值就是 ETag 唯一标识</li>
</ul>
</li>
<li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<ul>
<li>如果值相等，则返回 304 Not Modified，不会返回资源</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>
</ul>
</li>
</ul>
</li>
<li><p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<ul>
<li>再次发起相同请求</li>
<li>本地检验缓存（强制缓存），成功直接使用，未成功则进行协商缓存</li>
<li>协商缓存进行检验，成功直接使用，未成功则重新返回并更新相关检验的字段</li>
</ul>
</li>
</ul>
<h4 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP&#x2F;1.1 特性"></a>HTTP&#x2F;1.1 特性</h4><ul>
<li>优点<ul>
<li>简单：报文形式：header + body，头部信息：key + value</li>
<li>灵活易扩展：各类请求方法并未固定死，可以自定义和扩展</li>
<li>应用广泛和跨平台</li>
</ul>
</li>
<li>缺点<ul>
<li>无状态：<ul>
<li>好处：服务器无需存储HTTP状态，节省资源</li>
<li>坏处：服务器没有记忆能力，完成有关联性的操作很麻烦，例如在网上购物时，每一步操作都需要知道用户身份，服务器不存储状态，因此每一步操作都需要验证身份信息（cookie技术和session技术解决）。</li>
</ul>
</li>
<li>明文传输：<ul>
<li>好处：方便阅读，方便调试</li>
<li>坏处：信息不安全</li>
</ul>
</li>
</ul>
</li>
<li>性能分析<ul>
<li>长连接<ul>
<li>在早期的HTTP&#x2F;1.0中，每次发起一个请求都需要新建一次TCP连接，并且串行请求（一个请求的响应完全返回后，才能发起下一个请求）。</li>
<li>为了解决上述连接问题，HTTP&#x2F;1.1提出了<strong>长连接</strong>（持久连接）的通信方式，只要任意一端没有明确提出断开连接，则保持TCP连接状态。（如果超过一定时间没有数据交互，服务器也会主动断开该连接）<br><img src="D:\Blog\source\img\长短连接的区别.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>管道网络运输（并不默认开启该功能）<ul>
<li>HTTP&#x2F;1.1采用了长连接的方式，使得管道网络传输成为了可能，即可在同一个TCP连接里，客户端发起多个请求，只要第一个请求发出去，不必等待其回来，就可以发送第二个请求，由此减少整体响应时间。<br><img src="D:\Blog\source\img\管道网络运输.png" srcset="/img/loading.gif" lazyload> </li>
<li>请求必须有序。</li>
<li>如果服务端在处理某个请求队列头部的请求时，耗时较长，那么后续的请求处理都会被阻塞，这被成为队头堵塞。</li>
</ul>
</li>
<li>队头阻塞<br><img src="D:\Blog\source\img\队头堵塞.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
<h4 id="HTTP-1-1-如何优化"><a href="#HTTP-1-1-如何优化" class="headerlink" title="HTTP&#x2F;1.1 如何优化"></a>HTTP&#x2F;1.1 如何优化</h4><ol>
<li><p>避免发送HTTP请求</p>
<ol>
<li>使用缓存技术</li>
</ol>
</li>
<li><p>减少HTTP请求发送次数</p>
<ol>
<li><p>减少重定型请求</p>
<ul>
<li><p>重定向就是一个服务器资源从url1迁移到url2后，但是客户端并不知情，仍然请求url1，此时服务器会通过302响应码和Location头部告诉客户端资源已经迁移至url2。 </p>
</li>
<li><p>解决方案：</p>
<ul>
<li><p>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</p>
</li>
<li><p>因为客户端也不止有一个，有了代理服务器，第一台设备的第一次重定向后，代理服务器就会知晓其规则，那么之后的该请求的重定向就无需到达源服务器，而是直接由代理服务器进行返回</p>
<p><img src="D:\Blog\source\img\客户端服务器请求方案.png" srcset="/img/loading.gif" lazyload><br><img src="D:\Blog\source\img\代理服务器帮忙处理重定向.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>合并求情</p>
<ul>
<li>把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。 </li>
<li>这样也带来了问题，当大资源中的某个小资源发生了变化，客户端必须重新下载整个大资源，带来了额外的网络消耗</li>
</ul>
</li>
<li><p>延迟发送请求</p>
<ul>
<li>按需获取，例如请求网页的时候，没必要获取全部资源，而是仅仅获取当前用户所需要的资源即可</li>
</ul>
</li>
</ol>
</li>
<li><p>减少HTTP响应数据的大小</p>
<ul>
<li>对响应的资源进行压缩</li>
</ul>
</li>
</ol>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，<strong>在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</strong></li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h4 id="HTTPS-解决了HTTP的哪些问题？"><a href="#HTTPS-解决了HTTP的哪些问题？" class="headerlink" title="HTTPS 解决了HTTP的哪些问题？"></a>HTTPS 解决了HTTP的哪些问题？</h4><ul>
<li>实现了<ul>
<li>信息加密：交互信息无法被窃取。</li>
<li>校验机制：无法篡改通信内容，篡改了就不能正常显示。</li>
<li>身份证书：证明淘宝是真的淘宝网。</li>
</ul>
</li>
<li>实现方案：<ul>
<li>混合加密的方式实现信息的机密性，解决了窃听的风险。</li>
<li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到数字证书中，解决了冒充的风险。</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的实现方式"><a href="#HTTPS的实现方式" class="headerlink" title="HTTPS的实现方式"></a>HTTPS的实现方式</h4><ul>
<li><p><strong>混合加密</strong></p>
<blockquote>
<ul>
<li>公钥：公开给所有人；私钥：必须本人保管，不可泄漏</li>
<li>二者可以双向进行解密和加密<br><strong>公钥加密，私钥解密。这个目的是为了保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br><strong>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>对称加密：使用相同的密钥（称为对称密钥）同时用于加密和解密数据。对称加密算法存在一个密钥分发的问题。发送方和接收方必须事先共享密钥，这在分布式环境中可能会变得复杂和不安全。</li>
<li>非对称加密：使用一对密钥，分别是公钥和私钥。发送方使用接收方的公钥对数据进行加密，而接收方使用自己的私钥对数据进行解密。</li>
</ul>
</blockquote>
<ul>
<li><p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li>
<li>简单来说就是，数据使用对称加密，然后因为对称加密的密钥传输有可能有安全问题，于是使用非对称加密来传输对称加密的密钥<br><img src="D:\Blog\source\img\https混合加密.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
</li>
<li><p><strong>第二次梳理理解：</strong></p>
<ul>
<li><strong>客户端自己有私钥a，然后将对应的公钥a发送给服务端，服务端根据公钥a进行加密（此加密信息只能通过私钥a才能获取，即只能由客户端获取），加密的内容就是也是一个私钥b（后面用来实现通信的私钥b）</strong></li>
<li><strong>客户端获取到公钥a加密后的信息，根据自己的密钥a进行解密，得到了服务器的私钥b</strong></li>
<li><strong>然后双方进行传输：服务端发送信息，此信息使用公钥b加密，此时只能由有私钥b的才能解密</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>摘要算法 和 数字签名</strong><br>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p>
</li>
</ul>
<p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p>
<p>用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。</p>
<p>通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</p>
<ul>
<li>所以使用摘要算法：计算出内容指纹一并传输给接收方，让接收方来校验</li>
<li>并且为了防止被攻击者将内容和指纹一同修改，所以使用数字签名：私钥加密，公钥解密，确定是来自于指定对象。<br><img src="D:\Blog\source\img\摘要算法数字签名.png" srcset="/img/loading.gif" lazyload></li>
<li><strong>数字证书</strong><br>如果造假者进行公钥的伪造（伪造一个假官方，发布假公钥），那么数字签名也就失效了，因为它传私钥给你也传公钥给你。</li>
</ul>
<p>所以为了防止这种漏洞，发送方可以将自己的公钥上传给权威机构CA（数字证书认证机构），接收方就不会出现使用伪造公钥的情况了<br><img src="D:\Blog\source\img\数字证书.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><h4 id="SSL-TLS-协议基本流程"><a href="#SSL-TLS-协议基本流程" class="headerlink" title="SSL&#x2F;TLS 协议基本流程"></a>SSL&#x2F;TLS 协议基本流程</h4><ul>
<li>客户端向服务器索要并且验证服务器的公钥</li>
<li>双方协商产生会话密钥</li>
<li>双方采用会话密钥进行加密通信</li>
</ul>
<h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><ul>
<li>改善：<ul>
<li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
</li>
<li>不足：<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应</li>
</ul>
</li>
</ul>
<h4 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h4><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。‘</p>
<ul>
<li><p>改善：</p>
<ul>
<li>头部压缩：HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。（使用一个表来维护所有字段，根据需要生成索引来确定需要哪些字段）</li>
<li>二进制格式：HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame），对计算机而言增加了传输效率</li>
<li>并发传输：针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。<br><img src="D:\Blog\source\img\http2并发传输.png" srcset="/img/loading.gif" lazyload></li>
<li>服务器推送：HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息</li>
</ul>
</li>
<li><p>缺陷：</p>
<ul>
<li>没有解决TCP层面的队头阻塞<ul>
<li>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>并且使用基于UDP的QUIC协议来实现类似TCP的可靠性传输<br>QUIC有三个特点:无队头阻塞、更快的连接建立连接迁移</p>
<ul>
<li>无队头阻塞：<br>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</li>
</ul>
<p>QUIC 有自己的一套机制可以保证传输的可靠性的。当<strong>某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</strong>，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p>
<ul>
<li>更快的连接建立：<br>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，建立连接时需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”<br><img src="D:\Blog\source\img\http3更快的连接建立.png" srcset="/img/loading.gif" lazyload></li>
<li>连接迁移：<ul>
<li>对于TCP传输来说：当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。</li>
<li>对于QUIC协议，通过连接ID来标记通信双方，所以就算IP变了，只要仍有上下文信息，那么就可以实现无缝连接</li>
</ul>
</li>
</ul>
<h4 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h4><ul>
<li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul>
<li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li>
<li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li>
<li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li>
<li>工作原理：<ul>
<li>当客户端访问某一个地址时，会将请求交给服务器进行处理</li>
<li>在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理</li>
<li>在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息</li>
<li>浏览器在接受响应后会按照cookie信息在客户端建立cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不安全，明文暴露</li>
<li>移动端无法使用</li>
<li>无法跨域使用<ul>
<li><img src="D:/Blog/source/img/跨域访问.png" srcset="/img/loading.gif" lazyload alt="Alt text"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul>
<li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。</li>
<li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="D:/Blog/source/img/session原理示意图.png" srcset="/img/loading.gif" lazyload alt="Alt text"></li>
<li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li>
</ul>
</li>
<li><p>cookie和session的比较：</p>
<ul>
<li>cookie保存在客户端，session保存在服务端</li>
<li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li>
<li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li>
<li>cookie存放的数据量较小，session可以存储更多的信息。</li>
<li>cookie由于存放在客服端，相对于session更不安全</li>
<li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="D:/Blog/source/img/cookie，session，令牌对比.png" srcset="/img/loading.gif" lazyload alt="Alt text"></li>
</ul>
</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="从键入网址到显示网页的全过程："><a href="#从键入网址到显示网页的全过程：" class="headerlink" title="从键入网址到显示网页的全过程："></a>从键入网址到显示网页的全过程：</h4><ol>
<li><p>浏览器解析URL</p>
</li>
<li><ol>
<li>URL的组成？</li>
</ol>
</li>
</ol>
<p>例如：http: &#x2F;&#x2F; www. server. com &#x2F; dir1 &#x2F; file1.html</p>
<p>http 代表访问数据的协议</p>
<p><a target="_blank" rel="noopener" href="http://www.server/">www.server</a> 代表服务器名称</p>
<p>dir1&#x2F;file1.html 代表访问的文件的路径</p>
<ol>
<li><p>根据URL在DNS中找到 IP地址</p>
</li>
<li><ol>
<li>DNS是什么？</li>
</ol>
</li>
</ol>
<p>dns就是域名系统，用来存储域名和对应的ip地址</p>
<ol>
<li><ol>
<li>为什么需要DNS？</li>
</ol>
</li>
</ol>
<p>域名比起ip地址更容易记忆</p>
<p>ip地址可能经常更换，使用域名可以使用户体验更好，无需记忆多变的ip地址</p>
<p>域名可以映射到多个ip地址，便于实现负载均衡等</p>
<ol>
<li><ol>
<li>域名层级关系</li>
</ol>
</li>
</ol>
<p>越靠右层级越高，<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a>   </p>
<p>最高级的是最右侧隐藏的 . ，这个 . 代表的是根域名， .com是顶级域名，server.com是权威域名</p>
<ol>
<li><ol>
<li>域名解析流程</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>客户端发出dns请求，<a href="http://www.server.com的IP是多少？">www.server.com的IP是多少？</a></li>
<li>本地dns服务器会现在缓存中寻找，找到则直接返回</li>
<li>如果没找到那么会依次从最高层的域名服务器进行查找</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>问根域名，根域名不知道，但是可以指明方向（如指示去,.com找）</li>
<li>问.com，.com不知道，也可以指明方向（如指示去<a target="_blank" rel="noopener" href="http://www.server.com找)/">www.server.com找）</a></li>
<li>然后找到，权威DNS服务器将对应的IP地址告诉本地DNS</li>
<li>本地进行缓存</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>协议栈对传输进行下一步指示（告诉你使用什么协议）</p>
</li>
<li><ol>
<li>获取到IP后指示进行什么协议来传输</li>
</ol>
</li>
<li><p>进行TCP传输</p>
</li>
<li><ol>
<li>TCP报文头部格式</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>源端口号，目的端口号：确定数据的来源和去处</li>
<li>序列号：因为TCP是分包传输的，序列号可以解决乱序的问题</li>
<li>确认序号：确认包是否收到，解决丢包问题</li>
<li>状态位：SYN发起连接，ACK回复，RST重新连接，FIN结束连接</li>
<li>窗口大小：实现流量控制</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>三次握手</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>流程</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>服务端进行监听</li>
<li>客户端发送建立请求，然后客户端等待服务端发送确认连接报文</li>
<li>服务端发送确认连接报文后，负端进入同步已接收状态，等待客户端进行最后的连接确认</li>
<li>客户端接收到确认连接报文，然后返回连接已确认报文，此时正式建立连接</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>分析：</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>第一次握手的丢失</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li><ol>
<li>第一次握手是为了告诉服务端，我想和你进行连接</li>
<li>如果丢失了，此时证明客户端已经发送请求，客户端会等待服务端返回确认请求，服务端没接收到，那么不会返回，客户端会进行超时重传，达到一定次数后，并且等待一定时间后还是没有收到确认报文，那么客户端主动断开连接</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>第二次握手的丢失</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li><ol>
<li>第二次握手是服务端告诉客户端，我知道了你要和我连接，我告诉你一声</li>
<li>客户端发送建立请求后，客户端等待服务端的确认，服务端因为已经发送了确认，服务端正在等待第三次握手，如果客户端没有得到第二次握手，会超时重传，然后等待，无效再断开连接</li>
<li>服务端没有接收到客户端的确认（第三次握手），也会进行超时重传，然后等待一段时间没有后，那么服务端会主动断开连接</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>第三次握手的丢失</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li><ol>
<li>第三次握手是客户端建立连接请求被服务端接收到，并且服务端返回 确认报文也被客户端接收到，然后此时进行服务端再等待客户端做最后的连接确认</li>
<li>客户端进行第三次握手后，会进入连接已建立状态，因为第三次握手丢失了，服务端会一直等待，然后超时重传，达到上限后还没有收到第三次握手，那么会主动断开连接</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>第三次握手为何不能省？</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>避免资源浪费</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li><ol>
<li>tcp传输协议之中，服务端是被动打开的，客户端是主动打开的</li>
<li>客户端数据传输结束后会关闭连接</li>
<li>如果客户端发送数据，然后其中某一个数据阻塞了，但是客户端以为自己传输结束了，于是客户端将自己关闭</li>
<li>然后此时该数据到达了服务端，服务端会被被动打开，服务端会发送确认报文</li>
<li>此时客户端已经关闭，并且无法被服务端唤醒，所以不会理睬</li>
<li>那么服务端一直会开启并且等待客户端响应</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>如果有了第三次</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>当滞留的请求到达服务器，服务器会向客户端发送连接确认报文，然后会等待第三次握手（因此可以检测到客户端有没有关闭）</li>
<li>如果如上面的情况，客户端关闭了，那么客户端不会返回请求给服务端，服务端会超时重传，并且不会一直死等，一定时间就关闭，不像上面那样进入连接已建立状态，然后一直白白等。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>四次挥手</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>流程</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>客户端主动发起TCP连接释放报文，并且进入终止等待状态1</li>
<li>服务端接收到连接释放报文后，告诉客户端，我还有未发完的数据，然后服务端进入关闭等待，客户端进入终止等待状态2</li>
<li>服务端将剩余数据传输完毕后再次告诉客户端，此时服务端进入最后确认状态</li>
<li>客户端收到后，知道数据已经传输完毕，并且发送确认报文，进入最后的时间等待状态</li>
<li>服务端接收到确认报文后，进行关闭</li>
<li>客户端经过一定的时间等待后进入关闭</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>为何要进行时间等待？</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>为的就是防止第四次挥手丢失后，服务端总是等待确认而不关闭，服务端会在一定时间告诉客户端：你咋还不发送确认报文啊？客户端收到后，就会知道自己之前的确认报文丢失了，于是会进行报文的重传</li>
<li>如果没有时间等待，那么服务端无法告诉客户端自己没有收到确认报文，也就无法进行重传，那么服务端也就无法关闭了</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>IP确定往哪里传输（TCP也是根据IP来发）</p>
</li>
<li><ol>
<li>IP报文头部格式</li>
<li>IP传输过程</li>
</ol>
</li>
<li><p>MAC地址确定两点之间的传输</p>
</li>
<li><ol>
<li>MAC头部</li>
<li>发送方MAC地址，接收方MAC地址的获取</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>发送方的MAC地址就在网卡里面</li>
<li>接收方的MAC地址需要根据ARP协议获取</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>ARP协议</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>使用广播的形式：这个IP地址是谁的啊！？</li>
<li>网络中的目的地址会进行反应</li>
<li>将其写入缓存，便于下次直接发送</li>
</ol>
</li>
</ol>
</li>
<li><p>网卡，交换机，路由器</p>
</li>
<li><ol>
<li>网卡作用</li>
<li>交换机作用</li>
<li>路由器作用</li>
</ol>
</li>
<li><p>接收端层层拆解获取HTTP数据</p>
</li>
</ol>
<p><img src="D:\Blog\source\img\数据传输过程.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="如何优化TCP？"><a href="#如何优化TCP？" class="headerlink" title="如何优化TCP？"></a>如何优化TCP？</h4><h5 id="优化三次握手"><a href="#优化三次握手" class="headerlink" title="优化三次握手"></a>优化三次握手</h5><ul>
<li><p>客户端优化</p>
<p>客户端发起第一次建立连接请求时，如果长时间没有收到第二次的确认连接，那么会进行超时重传，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次。并且每次<strong>超时重传时间是上一次的2倍</strong>，1-&gt;2-&gt;4-&gt;8-&gt;16</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手，总共耗时63秒，我们可以对其进行优化。</p>
<ul>
<li>通过 <code>tcp_syn_retries</code> 控制其重传的次数。</li>
<li>比如在内网通讯的时候，减少重传次数，尽快获取错误。</li>
</ul>
</li>
<li><p>服务端优化</p>
<ul>
<li>通过netstat -s 观察半连接队列溢出情况，通过tcp_max_syn_backlog、somaxconn、backlog，调整半连接队列的大小</li>
</ul>
</li>
<li><p>绕过三次握手</p>
<ul>
<li><p>使用TCP Fast Open 功能绕过三次握手</p>
<p><img src="D:\Blog\source\img\绕过三次连接.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
</ul>
<p>在客户端首次建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>所以，第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。</p>
<p>之后，如果客户端再次向服务器建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含「数据」（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 Cookie；</li>
<li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li>
<li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li>
<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li>
<li>此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。</li>
</ol>
<p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。</p>
<p>如何解决三次握手中的缺少第三次握手的问题呢？</p>
<h5 id="优化四次挥手"><a href="#优化四次挥手" class="headerlink" title="优化四次挥手"></a>优化四次挥手</h5><p>看不懂啊</p>
<ul>
<li>调整重传次数</li>
</ul>
<h5 id="TCP传输数据的性能提升"><a href="#TCP传输数据的性能提升" class="headerlink" title="TCP传输数据的性能提升"></a>TCP传输数据的性能提升</h5><ul>
<li>提升滑动窗口的大小</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/11/08/计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Carefreehuang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/04/JVM/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
