<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>黑马点评-登录注册实现</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="基于Redis优化session来进行短信登陆"><a href="#基于Redis优化session来进行短信登陆" class="headerlink" title="基于Redis优化session来进行短信登陆"></a>基于Redis优化session来进行短信登陆</h3><h4 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h4><ol><li>发送验证码<br>首先根据用户的手机号进行判断，是否合法，合法则可以进行发送验证码。通过session进行保存。</li><li>通过验证码进行登录，注册<br>通过实体LoginFormDTO，封装手机号，验证码，密码（暂时只考虑手机号和验证码），先进行手机号合法性的判断，合法再判断手机号和验证码是否与session中存储的一致。</li></ol><hr><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：当客户端访问某一个地址时，会将请求交给服务器进行处理，在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理，在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息，浏览器在接受响应后会按照cookie信息在客户端简历cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="/../img/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 </li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="/../img/session%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li>cookie和session的比较：<ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="/../img/cookie%EF%BC%8Csession%EF%BC%8C%E4%BB%A4%E7%89%8C%E5%AF%B9%E6%AF%94.png" alt="Alt text"></li></ul></li></ul><hr><ol><li>校验登陆状态，实现拦截<br>用户在进行请求时，会从cookie中携带JsessionId到服务端，服务端通过JsessionId从session中获取信息，没有session信息则进行拦截，有session信息则将用户信息保存到threadLocal中，并放行。<br>拦截器的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2. 获取session中的用户信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//4. 不存在，则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br>        UserHolder.saveUser(user);<br>        <span class="hljs-comment">//6. 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="Redis优化登录注册"><a href="#Redis优化登录注册" class="headerlink" title="Redis优化登录注册"></a>Redis优化登录注册</h4><ol><li>为什么需要优化？<br>因为session是存储在服务器之中的，所以当有多台tomcat时，会出现session共享问题，比如用户第一次访问了tomcat1，第二次访问了tomcat2，那么tonmcat2中肯定没有存放用户的session信息，所以此时登录拦截会出现问题。不改变session存储的解决方案有：将完整session拷贝到每一台tomcat中，并且及时同步，这就带来了两个问题：<ol><li>每个tomcat都有完整session，会造成服务器压力过大。</li><li>拷贝session数据时，可能会出现延迟。</li><li>所以我们使用redis进行实现，因为redis本身就是可以共享的。</li></ol></li><li>redis实现</li><li>设计key</li></ol><ul><li>由于redis全局共享，所以我们需要设计不重复，不暴露信息的key。可以直接让后台生成token进行业务。</li></ul><ol><li>登录后，根据手机号查询判断是否有用户信息 ，无则新建，将用户数据保存到redis，生成token作为key。有则进行校验，根据token判断数据是否存在。不存在则拦截，存在则将用户信息保存到threadLocal，并放行（token也存在请求头中）。</li><li>拦截器通过判断threadLocal是否为空进行判断拦截还是放行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-comment">//校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//校验验证码（从redis中）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<span class="hljs-comment">//获取用户输入的code</span><br>    <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>        <span class="hljs-comment">//不一致则报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建新用户并保存</span><br>        user = createUserWithPhone(phone);<span class="hljs-comment">//(user接收，便于保存)</span><br>    &#125;<br>    <span class="hljs-comment">//保存信息到redis</span><br>    <span class="hljs-comment">//随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> RedisConstants.LOGIN_USER_KEY + token;<br>    <span class="hljs-comment">//将user对象转为hash存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));<br>    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);<br>    <span class="hljs-comment">//设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//返回token</span><br>    <span class="hljs-comment">//session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>登录刷新问题<br>- 通过拦截器查看用户是否在操作，如果没有操作超过30分钟，删除token，用户重新登录<br>- 通过查看请求，如果请求头中有token，那么我们刷新token存活时间。<br>- 拦截器优化：在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br>   <img src="/../img/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96.png" alt="Alt text"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//获取请求头之中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//基于token获取redis中的用户（get是根据key以及字段取值，entries是根据key取值）</span><br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash()<br>            .entries(token);<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//将查询到的hash数据转为userDTO</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap,<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(),<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//将userDTO信息保存到threadLocal</span><br>    UserHolder.saveUser(userDTO);<br>    <span class="hljs-comment">//刷新token的有效期</span><br>    stringRedisTemplate.expire(token,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);<br>    <span class="hljs-comment">//放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-26记事</title>
    <link href="/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>前言：闲来无聊，本应该是记单词的时间，但是又想练习打字，于是开始用电脑码一下今天的日记吧</p><h3 id="学习状态总结"><a href="#学习状态总结" class="headerlink" title="学习状态总结"></a>学习状态总结</h3><p>总体可以给自己打分80吧，今天又没去上课，在宿舍学习，效率一般，任务完成度还行，但是吸收的并不多，也进行了运动，下面是今日的统计情况，累计时长接近9小时</p><h4 id="23年09月26日"><a href="#23年09月26日" class="headerlink" title="23年09月26日"></a>23年09月26日</h4><blockquote><p><strong>08:00至09:58 【redis学习】  1小时58分钟</strong></p></blockquote><p>&emsp;redisson 联锁，可重用锁，</p><blockquote><p><strong>10:20至11:31 【redis学习】  1小时11分钟</strong></p></blockquote><p>&emsp;秒杀优化 异步下单，阻塞队列</p><blockquote><p><strong>14:30至15:50 【redis学习】  1小时20分钟</strong></p></blockquote><p>&emsp;调傻逼bug，总算解决了，但是不知道原因</p><blockquote><p><strong>15:50至17:30 【leetcode刷题】  1小时40分钟</strong></p></blockquote><p>&emsp;一道半力扣，小颓废唉</p><blockquote><p><strong>19:15至20:42 【redis学习】  1小时27分钟</strong></p></blockquote><p>&emsp;redis消息队列看完，不过没咋吸收全是api，语法</p><blockquote><p><strong>20:42至20:55 【leetcode刷题】  13分钟</strong></p></blockquote><p>&emsp;三道sql</p><blockquote><p><strong>20:55至22:00 【运动健身】  1小时5分钟</strong></p></blockquote><p>&emsp;引体，弯举，划船，卷腹</p><h3 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h3><p>自己这段时间还是太焦虑和着急了，基于求成进度，想快速的学完java进行实习，这样使自己草草的看完视频，码一下代码就安慰自己是学完了，说实话这真的是致命毒药，因为做项目的关键在于去面试找工作，面试官拷打你的项目的时候就是直接根据项目的技术栈来进行询问的，如果你回答不上来那么等于是没做，所以我现在的改变我的心态，必须吃透项目，并且看完一章节后根据网上资料以及ppt进行总结归纳，不要急于求成，每天起码画两三个小时去总结。<br>关于自己实习的问题也不能着急，你现在如果去一个垃圾小厂实习的话，一是可能学不到东西，赚不到钱，还有挂科的风险，并且最主要的是浪费了时间，这学期应该好好静下心来，学习java（redis，mq，sprincloud等），学习计网，还有备战六级，并且反复刷leetcode，最后一两个月，差不读学习完springcloud课程之后再进行八股，准备面试以及期末考试。<br>好吧就这样吧，加油，睡觉了！</p><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配下标-KMP算法</title>
    <link href="/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：尽管之前大二学数据结构我就学过kmp，但是由于这个算法比较复杂，并且自己划水一年，所以基本上是新学差不多，今天花了接近三个小时，重新梳理一下kmp的思路，以及注意事项。</p><p>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><ol><li>根据前后缀来进行快速匹配，使得不需要使用两个for循环来进行匹配，如图 <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="使用前后缀匹配" title="Magic Gardens"></li><li>如何进行匹配呢，我们借助next数组，next数组是一个和字串长度相等的int数组，相应的存储以该节点为后缀的最大公共前后缀长度，什么是公共前后缀呢？例如：aabaa字串的公共前后缀就是a,aa，所以其最大长度为2。</li><li>那么next数组如何发挥作用呢，我们依次匹配串，当有冲突时，我们利用next进行回溯，回溯到的位置就是 next[冲突位置索引-1] ，为什么呢，我们可以举一个例子，比如 串 a a b a a f，对应的next数组为0 1 0 1 2 0，当父串为：a a b a a b a a f,我们可以知道当匹配到父串的第二个b时会有冲突，所以回溯，根据next，父串指针不动，字串指针回溯到next[indexOf(‘f’)-1]即2，所以我们再次从子串的第一个b开始匹配。</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next,String s)</span>&#123;<br>    <span class="hljs-comment">//初始化 j 以及 next数组</span><br>    <span class="hljs-comment">//i：后缀末尾   j：前缀末尾</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length();i++)&#123;<span class="hljs-comment">//对于每一个后缀的结尾</span><br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))&#123;<span class="hljs-comment">//判断是否前后缀相等</span><br>            j = next[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//不匹配则 j 回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>    <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>    getNext(next,needle);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>        <span class="hljs-comment">//关键此处的 while和下面的if不能交换顺序！！</span><br>        <span class="hljs-comment">//反例如 父串 sads 子串 sad</span><br>        <span class="hljs-comment">//若是if(==)在前，当第一个匹配 s时，j++，此时i还没有++，所以在进行接下来的while时会进入while导致bug</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) <span class="hljs-comment">//不匹配则查找不匹配字符的前一个位置的next值，进行回溯</span><br>            j = next[j - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) <span class="hljs-comment">//匹配则两个指针同时后移，进行下一个的匹配</span><br>            j++;<br>        <span class="hljs-keyword">if</span> (j == needle.length()) <br>            <span class="hljs-keyword">return</span> i - needle.length() + <span class="hljs-number">1</span>;<span class="hljs-comment">//返回子字符串在父字符串中的匹配位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的单词</title>
    <link href="/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体思路为：整体的字符反转，字符中额外空格的删除，字符单词反转</p><p>字符反转很简单，使用双指针即可<br>删除字符中的额外空格有点麻烦，可以使用双指针（参考之前的数组移除元素），具体思路如下：定义快慢指针，用快指针遍历数组，当快指针指向非目标值时，将快指针的内容拷贝到慢指针处，然后fast++，slow++。主要留心中间空格以及两端空格的处理。<br>字符单词反转不麻烦但是得考虑全。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">char</span>[] sChars = s.toCharArray();<br>      <span class="hljs-comment">//字符串整体反转</span><br>      reverse(sChars,<span class="hljs-number">0</span>,sChars.length-<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//去除额外空格</span><br>      sChars = removeExtraSpace(sChars);<br>      <span class="hljs-comment">//单词内反转</span><br>      reverseEachWord(sChars);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sChars);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt;= chars.length; end++) &#123;<span class="hljs-comment">//便于让end总是指向每一个单词的末尾</span><br>          <span class="hljs-keyword">if</span>(end == chars.length || chars[end] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>              reverse(chars,start,end-<span class="hljs-number">1</span>);<br>              start = end + <span class="hljs-number">1</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] removeExtraSpace(<span class="hljs-type">char</span>[] chars)&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; chars.length; fast++) &#123;<br>          <span class="hljs-keyword">if</span> (chars[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<span class="hljs-comment">//整体为去除空格模板</span><br>              <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在非首位的每个单词后面添加一个空格</span><br>                  chars[slow] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                  slow ++;<br>              &#125;<br>              <span class="hljs-keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] !=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                  <span class="hljs-comment">//删除所有空格</span><br>                  <span class="hljs-comment">//将快指针的内容（非空格的字母）赋值给慢指针</span><br>                  chars[slow] = chars[fast];<br>                  slow++;<br>                  fast++;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//同时slow也就是到达了最后的有效位置，slow的大小就是处理完后的数组大小。</span><br>      <span class="hljs-type">char</span>[] newChar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[slow];<br>      <span class="hljs-comment">//数组拷贝，System.arraycopy(拷贝数组, 起始索引, 新数组, 起始索引, 拷贝长度); </span><br>      System.arraycopy(chars, <span class="hljs-number">0</span>, newChar, <span class="hljs-number">0</span>, slow); <br>      <span class="hljs-keyword">return</span> newChar;<br>  &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> end)</span>&#123;<br>      <span class="hljs-type">char</span> tmp;<br>      <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>          tmp = chars[start];<br>          chars[start] = chars[end];<br>          chars[end] = tmp;<br>          start ++;<br>          end --;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
