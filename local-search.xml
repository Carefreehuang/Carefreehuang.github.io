<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>消息队列笔记</title>
    <link href="/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><ul><li><p>消息队列（Message Queue）是一种用于在应用程序之间传输异步消息的通信模式。它是一种在分布式系统中广泛应用的通信机制，用于解耦应用程序的组件，实现松耦合和可伸缩性。</p></li><li><p>同步和异步通讯</p><ul><li>同步通讯：类似打电话，实时响应，但通讯期间无法干其他事情<ul><li>缺点：<ul><li>耦合度高，不便于修改</li><li>资源浪费，调用链中的每个服务都需要等待相关前置服务的响应，浪费资源</li><li>级联问题：一个服务出现问题，相关调用服务都会出现问题</li></ul></li></ul></li><li>异步通讯：类似发短信，不是实时，但是可以支持多线程操作<ul><li>优点：<ul><li>耦合度低，服务双方并不是直接通信，而是由一个中间人来代理，发布者发布事件到中间人，订阅者从中间人接收事件。同时也便于修改更新</li><li>增加吞吐量，快服务不会被慢服务耽误，发布事件后即可去继续执行自己的业务。如：一个支付服务只需要向Broker（中间人）发布一个支付成功的事件，剩下的就不用它管了</li><li>故障隔离，无级联问题，服务之间都是去中间人接受事件，一个服务出故障和另一个服务之间并没有直接关系</li><li>流量削峰：不管发布事件流量波动多大，都由中间人接收，进行缓冲，订阅者可以按照自己的速度处理事件</li></ul></li><li>缺点：<ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂时，业务没有明确的流程线，不好追踪管理（出了bug都不好找）</li></ul></li></ul></li></ul></li><li><p>常见MQ对比:</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p></li></ul><h3 id="MQ的基本使用"><a href="#MQ的基本使用" class="headerlink" title="MQ的基本使用"></a>MQ的基本使用</h3><ul><li>SpringAMQP<ul><li>它是基于RabbitMQ封装的一套模板，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现，并且利用SpringBoot对其实现了自动装配，使用起来十分方便</li><li>SpringAMQP提供了三个功能：<ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul></li><li>消息的发送 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-comment">//用于发送消息</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, SpringAMQP! &quot;</span>;<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>消息的接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><span class="hljs-comment">//注解要监听的队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>发布订阅<br>  <img src="/../img/%E5%B8%A6%E6%9C%89exchange%E7%9A%84mq.png" alt="exchangemq"><ul><li>增加了exchange角色<ul><li>Exchange：交换机。一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或者是将消息对其。到底如何操作，取决于Exchange的类型。Exchange有以下三种类型<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key的队列</li><li>Topic：通配符，把消息交给符合routing pattern(路由模式)的队列</li></ul></li></ul></li></ul></li><li>消息转换器<ul><li>Spring会把发送的消息序列化为字节发送给MQ，接收消息的时候，会将字节反序列化为Java对象</li><li>但是默认情况下，Spring采用的序列化方式是JDK序列化，众所周知，JDK序列化存在以下问题<ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul></li><li>使用jackson代替原来的jdk的序列化<ul><li>引入依赖</li><li>在publisher和comsumer启动类添加bean，对原来的序列化进行覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>publis MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>consumer和publisher的序列化器需保持一致，同时consumer中接收数据的类型，也需要和发送数据的类型保持一致</li></ul></li></ul></li></ul></li></ul></li></ul><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker笔记</title>
    <link href="/2023/10/03/docker%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/03/docker%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><ul><li>docker是一个用go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所需要的依赖打包进docker container。</li><li>image：<ul><li>Docker镜像是容器的模板，它包含了应用程序和其依赖项的快照。镜像是只读的，可用于创建运行中的容器实例。</li></ul></li><li>container：<ul><li>Docker容器是一个轻量级的可执行单元，包括应用程序及其运行时环境、依赖项和配置。容器隔离了应用程序和底层操作系统，确保容器在不同环境中具有一致的行为。</li></ul></li><li>dockerhub：<ul><li>类似于github，是官方的一个镜像托管平台，类似的平台有很多，如阿里云镜像库等，这样的平台统称为：docker registry</li><li>我们可以将自己的镜像上传到dockerhub，也可以直接从dockerhub拉取镜像</li></ul></li><li>docker架构：<ul><li>服务端：负责处理docker命令，管理镜像，容器等</li><li>客户端：通过api向docker服务端发送指令</li><li><img src="/./../img/docker%E6%9E%B6%E6%9E%84.jpg" alt="docker架构"></li></ul></li></ul><h3 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h3><ul><li>docker可以解决依赖兼容问题<ul><li>docker打包应用的依赖，配置等，并且进行了隔离</li></ul></li><li>docker可以解决操作系统环境的差异<ul><li>docker不仅打包应用的依赖，也打包了系统的库函数</li><li>所以docker可以解决不同的系统上的环境问题，但是必须底层都是一个系统（如都是linux的Ubuntu，Centos等）</li></ul></li><li>docker和虚拟机的区别：<ul><li>Docker容器非常轻量级，与传统虚拟机相比，它们更快速启动、占用更少的系统资源，并允许在同一物理主机上运行更多的容器。</li><li>Docker便于移植</li></ul></li></ul><h3 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h3><ul><li>建议自行查看docker文档，或者询问chatgpt</li><li>推荐一篇文章<a href="https://zhuanlan.zhihu.com/p/187505981">什么是docker</a><style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>修剪二叉搜索树</title>
    <link href="/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树</a></p></blockquote><ul><li><p>与删除结点思路不同</p><ul><li>我们应该利用特性，来递归遍历</li><li>即当根结点值小于low，那么所有左子树可以抛弃，将右子树返回给上层接收即可，此操作删除了根节点也删除了根节点的左子树（大于high同理）</li><li>然后每次递归操作需要递归返回，以及递归完后需要        <ul><li>root.left &#x3D; trimBST(root.left,low,high);</li><li>root.right &#x3D; trimBST(root.right,low,high);</li></ul></li><li>这就是上层接收与下层返回的实现</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment">* public class TreeNode &#123;</span><br><span class="hljs-comment">*     int val;</span><br><span class="hljs-comment">*     TreeNode left;</span><br><span class="hljs-comment">*     TreeNode right;</span><br><span class="hljs-comment">*     TreeNode() &#123;&#125;</span><br><span class="hljs-comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment">*         this.val = val;</span><br><span class="hljs-comment">*         this.left = left;</span><br><span class="hljs-comment">*         this.right = right;</span><br><span class="hljs-comment">*     &#125;</span><br><span class="hljs-comment">* &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; low)&#123;<span class="hljs-comment">//此时越界了，删除所有左子树以及根节点（即让上层接收右子树）</span><br>            <span class="hljs-keyword">return</span> trimBST(root.right,low,high);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &gt; high)&#123;<span class="hljs-comment">//此时越界了，删除所有右子树以及根节点</span><br>            <span class="hljs-keyword">return</span> trimBST(root.left,low,high);<br>        &#125;<br>        <span class="hljs-comment">//上层的接收发起</span><br>        root.left = trimBST(root.left,low,high);<br>        root.right = trimBST(root.right,low,high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>删除二叉搜索树的结点</title>
    <link href="/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <url>/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></p></blockquote><ol><li>思路分析</li></ol><ul><li>整体思路：<ul><li>依然使用二叉搜索树的性质来查找需要删除的节点</li><li>当找到时执行相应的删除逻辑</li></ul></li><li>在二叉搜索树中删除节点比插入节点难，因为删除节点的时候涉及到了结构的调整。</li><li>所以我们在删除的时候得分情况来进行讨论<ul><li>当找到的节点是叶子节点时，直接返回null，即代表删除（原理是返回null给上层的递归调用的节点来进行接受）</li><li>当只有单个子节点时，直接返回单个子节点，给上层接受</li><li>当有两个节点时（包括有两颗子树），我们需要思考如何调整结构，我们画图后可以很容易想明白，我们可以按照二叉搜索树规则来进行结构调整。<ul><li>比如我们可以选择将待删除的节点的右节点作为新的根节点，于是我们应该将待删除的节点的左子树迁移到右子树上。</li><li>但是迁移到哪里呢？我们知道二叉搜索树是左节点小于根节点，右节点大于根节点，所以右子树全部节点都大于左子树，我们应该将左子树拼接到右子树中最小的节点之中。</li><li>所以我们应该将左子树拼接到右子树的最最左节点上</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<span class="hljs-comment">//找到删除节点</span><br>            <span class="hljs-comment">//分类讨论</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//找到右子树中最小的节点，将左子树拼接上去</span><br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root.val)&#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; root.val)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习笔记</title>
    <link href="/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h3><ul><li>单体架构：将所有的功能集中在一个项目之中开发，打包部署<ul><li>优点<ul><li>架构简单</li><li>部署成本低</li></ul></li><li>缺点<ul><li>耦合度高，维护困难，升级困难</li></ul></li></ul></li><li>分布式架构：根据功能对系统做拆分，每个业务功能模块作为独立的项目进行开发，成为一个服务<ul><li>优点<ul><li>耦合度低</li><li>利于服务的升级拓展</li></ul></li><li>缺点<ul><li>调用关系复杂</li></ul></li></ul></li><li>微服务<ul><li>架构特点：<ul><li>单一职责，每一个服务对应唯一的业务能力，做到单一职责</li><li>自治，团队独立，技术独立，数据独立</li><li>面向服务，服务提供统一标准接口，与语言和技术无关</li><li>隔离性强，服务调用做好隔离，容错，降级，避免出现级联问题（即一个服务挂了影响到另一个服务）<br><img src="/../img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微服务"></li></ul></li></ul></li><li>SpringCloud<ul><li>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验</li><li>常见的组件包括：<ul><li>微服务注册与发现<ul><li>Eureka</li><li>Nacos</li><li>Consul</li></ul></li><li>服务远程调用<ul><li>OpenFeign</li><li>Dubbo</li></ul></li><li>服务链路监控<ul><li>Zipkin</li><li>Sleuth</li></ul></li><li>统一配置管理<ul><li>SpringCloudConfig</li><li>Nacos</li></ul></li><li>统一网关路由<ul><li>SpringCloudGateway</li><li>Zuul</li></ul></li><li>流控，降级，保护<ul><li>Hystix</li><li>Sentinel</li></ul></li></ul></li></ul></li></ul><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><ul><li>假如我们的服务提供者user-service提供了三个实例，占用的分别是8081、8082、8083端口</li><li>我们思考三个问题：<ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时，该如何选择？</li><li>order-service如何得知某个user-service实例是否健康，是不是已经宕机？</li></ul></li><li>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下<br><img src="/./../img/eureka%E7%BB%93%E6%9E%84.jpg" alt="eureka结构"></li><li>我们回答上述问题：<ul><li>order-service如何得知user-service实例地址？<ul><li>user-service服务启动后，会将自己的信息注册到eureka服务端</li><li>eureka保存 服务名称 - 服务实力的地址 的映射</li><li>order-service根据服务名称拉取实例的地址列表</li></ul></li><li>order-service如何从多个user-service实例中选择具体的实例？<ul><li>利用负载均衡的算法进行判断（随机，轮询等）</li></ul></li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？<ul><li>被注册的服务（userservice）会定时向eureka-server发起请求（心跳），报告自己的状态</li><li>当eureka-server一定时间 没有接收到已经注册的服务的请求（心跳）时，eureka-server会认为该服务实例故障，会从服务列表剔除。</li></ul></li></ul></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>为什么要用负载均衡<ul><li>解决单体架构无法应对高请求的问题</li><li>将客户端请求均匀的分发到多台目标服务器</li><li>检测出目标服务器的健康状态，使得客户端不向已经宕机的服务器发送请求。</li></ul></li><li>实现方案<ul><li>基于DNS实现负载均衡</li><li>基于硬件实现负载均衡</li><li>基于软件实现负载均衡</li></ul></li><li>基于软件实现负载均衡<ul><li>SpringCloud底层利用Ribbon组件来实现负载均衡功能<br><img src="/../img/ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="ribbon实现负载均衡"></li><li>ribbon调用详情如下：<br><img src="/../img/ribbon%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt="ribbon调用详情"><ol><li>拦截RestTemplate请求：<a href="http://user-service/user/1">http://user-service/user/1</a></li><li>RibbonLoadBalanceClient会从请求中获取服务名称，即user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost8081，localhost8082</li><li>IRule根据负载均衡规则，选择一个实例</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代user-service，得到<a href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求</li></ol></li></ul></li><li>负载均衡策略：<ul><li>随机，轮询等</li><li>默认的是ZoneAvoidanceRule，是一种轮询方案</li><li>自定义实现：<ul><li>代码方式：在order-service中的OrderApplication类中，定义一个IRule，此种方式定义的负载均衡规则，对所有微服务均有效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>配置文件实现：在order-service中的application.yml文件中，添加新的配置也可以修改规则<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是user-service服务</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure></li></ul></li><li>饥饿加载：饥饿加载是一种在获取主要数据的同时，立即获取相关联的数据的策略。</li><li>懒加载：懒加载是一种在需要数据时才加载的策略。</li><li>Ribbon默认是采用懒加载，即第一次访问时，才回去创建LoadBalanceClient，第一次请求时间会很长</li><li>而饥饿加载在则会在项目启动时创建，降低第一次访问的耗时，可以在配置文件中调整加载方案。</li></ul></li></ul><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><ul><li>认识Nacos<ul><li>Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件，相比于Eureka，功能更加丰富，在国内受欢迎程度较高</li><li>Nacos是SpringCloudAlibaba的组件，而SpringCloud Alibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos与使用Eureka对于微服务来说，依赖不同，服务地址不同，其他基本类似。</li><li>nacos集群：将服务实例分布于全国各地，在一个地方的实例划分为一个集群，增加容灾能力。</li><li>nacos服务分级存储模型：<ol><li>服务：userservice</li><li>集群，杭州的userservice</li><li>实例，杭州的机房的部署了userservice的服务器</li></ol></li><li>nacos在实现负载均衡的时候会优先同集群的实例</li><li>权重配置<ul><li>对于老差设备分配更少的权重</li><li>nacos可以进行权重的配置（设为0，该实例永远不会被访问）</li></ul></li><li>环境隔离：Nacos提供了namespace来实现环境隔离功能<ul><li>nacos中可以有多个namespace</li><li>namespace下可以由group、service等</li><li>不同的namespace之间相互隔离，例如不同的namespace的服务互相不可见</li></ul></li><li>nacos实例分类<ul><li>临时实例（默认类型），宕机超过一定时间，会从服务列表中剔除。</li><li>非临时实例（可手动设置），宕机后不会被剔除。</li></ul></li><li>Nacos与Eureka的共同点<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康监测</li></ul></li><li>Nacos与Eureka的不同点<ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当急群众存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul></li></ul><h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><ul><li>为什么需要配置管理：<ul><li>当服务器部署的实例越来越多时，逐个修改微服务的配置很麻烦，并且容易出错，所以此时需要一个统一的配置管理方案，集中管理所有实例的配置。</li><li>Nacos可以将配置集中管理，也可以在配置变更时，及时通知微服务，实现配置的热更新。</li></ul></li><li>从微服务拉取配置：<ul><li>微服务要拉取Nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动</li><li>既然要拉取nacos中的配置，再读取application.yml，那么如何获取nacos的地址呢？<ul><li>Spring引入了一种新的配置文件：bootstrap.yml文件，会在application.yml之前被读取<ol><li>项目启动</li><li>加载bootstrap.yml,获取nacos地址，配置文件的id（服务名-服务环境-后缀名）</li><li>根据配置文件id，读取nacos中的配置文件</li><li>读取本地的application.yml，与nacos中的配置合并</li><li>创建spring容器</li><li>加载bean</li></ol></li></ul></li></ul></li><li>配置的热更新<ul><li>在@Value注入的变量类上添加注解@RefreshScope（刷新作用域）</li><li>使用@ConfigurationProperties注解代替@Value注解，在user-service服务中，添加一个类，读取pattern.dateformat属性</li></ul></li><li>配置共享：<ul><li>其实微服务启动时，回去Nacos读取多个配置文件，例如<ul><li>[spring.application.name]-[spring.profiles.active].yaml，例如：user-service-dev.yaml</li><li>[spring.application.name].yaml，例如：userservice.yaml</li></ul></li><li>而[spring.application.name].yaml不包含环境，因此可以被多个环境共享</li><li>配置共享优先级<ul><li>服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置<ul><li>user-service-dev.yaml &gt; user-service.yaml &gt; application.yaml</li></ul></li></ul></li></ul></li></ul><h3 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h3><ul><li>为什么要使用feign远程调用：<ul><li>以前的RestTemplate存在以下问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://user-service/user/&quot;</span> + order.getUserId();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, User.class);<br></code></pre></td></tr></table></figure><ul><li>可读性差，编程体验不统一</li><li>对于参数复杂的url难以维护</li></ul></li></ul></li><li>feign的使用<ul><li>使用步骤：引入依赖-&gt;添加注解-&gt;编写feign客户端<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;user-service&quot;)</span><span class="hljs-comment">//服务名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><span class="hljs-comment">//请求方式以及路径</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<span class="hljs-comment">//请求参数以及返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserClient userClient;<span class="hljs-comment">//注入feign客户端</span><br><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-comment">// 1. 查询订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.findById(orderId);<br>        <span class="hljs-comment">// 2. 利用Feign发起http请求，查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.findById(order.getUserId());<br>        <span class="hljs-comment">// 3. 封账user到order</span><br>        order.setUser(user);<br>        <span class="hljs-comment">// 4. 返回</span><br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>feign的使用优化<ul><li>feign的最佳实践<ul><li>继承：<ol><li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserAPI</span>&#123;<br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>Feign客户端和Controller都继承该接口</li></ol><ul><li>实现了代码共享，但是紧耦合</li></ul></li><li>抽取：<ul><li>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</li><li>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用<br><img src="/../img/feign%E7%9A%84%E6%8A%BD%E5%8F%96%E5%AE%9E%E7%8E%B0.jpg" alt="feign的抽取实现">   </li><li>解决包扫描问题：<ul><li>指定Feign应该扫描的包</li><li>指定需要加载的Client接口</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h3><ul><li>为什么需要网关<ul><li>Gateway网关是我们服务的守门神，是所有微服务的统一入口</li></ul></li><li>网关的核心功能为：<ul><li>请求路由:一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫路由。当然路由的目标服务有多个时，还需要做负载均衡</li><li>权限控制:网关作为微服务的入口，需要校验用户是否有请求资格，如果没有则拦截</li><li>限流:当请求量过高时，在网关中按照微服务能够接受的速度来放行请求，避免服务压力过大<br><img src="/../img/%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="网关架构图"> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">## 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment">## 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment">## nacos地址（我这里还是用的nginx反向代理，你们可以启动一个单体的nacos，用8848端口）</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment">## 路由id，自定义，只需要唯一即可</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span> <span class="hljs-comment">## 路由的目标地址，lb表示负载均衡，后面跟服务名称</span><br>          <span class="hljs-comment">## uri: http://localhost:8081 ## 路由的目标地址，http就是固定地址</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">## 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment">## 这个是按照路径匹配，只要是以/user开头的，就符合规则</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span> <span class="hljs-comment">## 按照上面的写法，再配置一下order-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-service</span> <br>          <span class="hljs-attr">predicates:</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span> <br></code></pre></td></tr></table></figure></li></ul></li><li>过滤器：<ul><li>作用：<ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由请求生效</li></ul></li><li>default-filters：<ul><li>对所有路由都生效的过滤器</li></ul></li><li>全局过滤器：<ul><li>使用自己的业务逻辑进行实现的过滤器</li></ul></li><li>过滤器执行顺序<ul><li>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</li><li>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器<br><img src="/../img/%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt="过滤器"> </li><li>排序规则为：<ul><li>每个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前（默认值为2147483647，即int最大值）</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul></li></ul></li></ul></li><li>跨域问题：<ul><li>什么是跨域：域名不一致就是跨域，主要包括<ul><li>域名不同：<a href="http://www.baidu.com和www.baidu.org,www.js.com和miaosha.js.com/">www.baidu.com和www.baidu.org，www.js.com和miaosha.js.com</a></li><li>域名相同，端口不同：localhost:8080和localhost:8081</li><li>请求协议不同，如http:baidu.com和https:baidu.com</li></ul></li><li>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</li><li>解决方案：CORS<ul><li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</li><li>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<style>/* 只设置 markdown 字体 */.markdown-body {font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;font-size: 20px;}</style></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-30记事</title>
    <link href="/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>放假以来一直有点颓废，已经浪费接近三天了。原因有二：</p><ul><li>主要原因还是自己浮躁，懒惰，没能走出宿舍去教室自习。</li><li>在宿舍人容易有惰性，并且还会容易沉迷无限火力。</li><li>还有就是自己的焦虑问题<ul><li>总是想一口吃成大胖子，导致学习不扎实，自己也喜欢幻想自己变成编程大佬的开心生活。</li><li>明明知道自己该做什么，但还是焦虑自己是不是该做这，该做那，然后又去刷点短视频，水点群，真是浪费时间，还极度的影响到了我的睡眠。</li></ul></li><li>解决对策：<ul><li>早上起来，迅速洗漱，走出宿舍去教室自习。</li><li>制定学期计划，月计划，周计划，日计划，并且贯彻执行。</li><li>禁止胡思乱想，一旦胡思乱想请立马查看自己的胡思乱想对策，开始进行自我的提升和学习。</li><li>保持良好的运动习惯，蹲推拉不能少，晚上的有氧也不能少，跑步，骑车都可以。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>递归回溯解决二叉树所有路径问题</title>
    <link href="/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径</a></p></blockquote><ul><li>关键在于如何进行所有路径的记录以及遍历。<ul><li>首先肯定是要利用前序遍历的思想的，因为题目要求的顺序和前序遍历的顺序一致，即 根-&gt;子 </li><li>利用回溯来实现非暴力的遍历，此题来说遍历就是向paths加节点，回溯就是向paths删节点。</li></ul></li><li>具体实现参照代码以及自己画图理解</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-comment">//前序遍历进行加入</span><br>        paths.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到达叶子节点</span><br>            <span class="hljs-comment">//构建符合题意的字符串</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; paths.size() - <span class="hljs-number">1</span>; i++) &#123;<br>                sb.append(paths.get(i)+<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>            sb.append(paths.get(paths.size()-<span class="hljs-number">1</span>));<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.left, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//进行回溯,节点指针回退一步，并且让paths重新变为回退的状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.right, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        traversal(root,paths,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-附近商户，签到，uv统计</title>
    <link href="/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h3><ul><li>实现根据当前位置搜索附近商户，并排序。</li></ul><h4 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h4><ul><li>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。</li><li>根据商铺类型为key，写入类型相同的商铺的经度纬度信息，保存在一个ZSet中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取所有shop，并且根据shop类型进行分组，保存在Map中（shopid，shops）</span><br>    List&lt;Shop&gt; shopList = shopService.list();<br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">//map.entrySet()：获取所有的键值对集合</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        List&lt;Shop&gt; shops = entry.getValue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(shops.size());<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            <span class="hljs-comment">//将当前type的商铺都添加到locations集合中</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())));<br>        &#125;<br>        <span class="hljs-comment">//批量写入</span><br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>具体实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">//1. 判断是否需要根据距离查询</span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br>    <span class="hljs-comment">//2. 计算分页查询参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>    <span class="hljs-comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span><br>    <span class="hljs-comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span><br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(key,<br>            GeoReference.fromCoordinate(x, y),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));<br>    <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//4. 解析出id</span><br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    <span class="hljs-keyword">if</span> (list.size() &lt; from) &#123;<br>        <span class="hljs-comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    HashMap&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        ids.add(Long.valueOf(shopIdStr));<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>        distanceMap.put(shopIdStr, distance);<br>    &#125;);<br>    <span class="hljs-comment">//5. 根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        <span class="hljs-comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span><br>        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>    &#125;<br>    <span class="hljs-comment">//6. 返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>如何高效少内存的进行签到统计：<ul><li>使用31位bitMap来统计一个用户的一个月的签到情况，1为签到，0为未签到。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 写入Redis  BITSET key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>如何获取本月连续签到的数据<ul><li>获取签到数据（从当前日期直到月初）</li><li>从末尾往前计算看有多少个连续的1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()<br>            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            count++;<br>        <span class="hljs-comment">//数字右移，抛弃最后一位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="uv统计"><a href="#uv统计" class="headerlink" title="uv统计"></a>uv统计</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数</a></p></blockquote><ul><li>简单方法就是直接遍历<ul><li>可以使用递归</li><li>可以是用迭代（利用队列）</li></ul></li><li>难点在于根据题目条件进行优化，即使用完全二叉树性质。<ul><li>完全二叉树：只有最底层的节点不是满的，并且最底层的节点从左到右必须是连续的。</li><li>一颗满二叉树（所有节点都是满的）的节点个数是2^deep - 1个，所以我们可以判断出满二叉树的个数，然后进行叠加计算。</li><li>完全二叉树是由许多的满二叉树组成的（可画图分析）</li><li>所以使用递归进行计算，如何判断是否是满二叉树呢<ul><li>一个根节点，对其进行左遍历以及右遍历（一直左遍历，一直右遍历）来进行判断， 当其左遍历深度&#x3D;&#x3D;右遍历深度时，其为一棵满二叉树。</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left!=<span class="hljs-literal">null</span>)&#123;<br>            left = left.left;<br>            leftDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>            right = right.right;<br>            rightDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(rightDeepth==leftDeepth)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;leftDeepth) -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> countNodes(root.right) + countNodes(root.left)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-达人探店，好友关注</title>
    <link href="/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/"/>
    <url>/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能实现"><a href="#点赞功能实现" class="headerlink" title="点赞功能实现"></a>点赞功能实现</h4><ol><li><p>基本功能实现</p><ul><li>要求：<ul><li>同一个用户只能对同一篇笔记点赞一次，再点赞即取消点赞</li><li>当前用户若点赞则显示高亮（前端页面会根据是否点赞决定是否高亮），根据isLike属性判断</li></ul></li><li>实现：<ul><li>使用redis中的set集合来进行判断是否点赞过（下文会具体介绍）。</li><li>点赞判断使用blog实体中的isliked进行判断，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注解通常用于实体类属性上，表示该属性不对应数据库表中的列。</span><br><span class="hljs-comment">//在这里，属性 isLike 被标记为 exist = false，</span><br><span class="hljs-comment">//意味着这个属性不会映射到数据库表的任何列。</span><br><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span>&#123;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//防止空指针</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;blog:liked&quot;</span>+blog.getId();<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key,userId.toString());<br>    blog.setIsLike(score != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>点赞排行榜实现</p><ul><li>要求：根据时间顺序展示点赞用户。</li><li>目前的问题：我们之前的点赞是放入set集合，无法进行时间的判断，所以我们此时可以使用Sortset（Zset），包含分数作为优先级。<br> <img src="/../img/list%EF%BC%8Cset%EF%BC%8Csortedset%E5%AF%B9%E6%AF%94.png" alt="对比"></li><li>解决方案：<ul><li>点赞使用zset保存，key是：”blog:liked”+id;（id是被点赞blogid），存储的元素是（userid（点赞人），分数（当前毫秒时间戳））<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br><br>       <span class="hljs-comment">// 获取当前登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>       <span class="hljs-type">Double</span> <span class="hljs-variable">haveScore</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>       <span class="hljs-keyword">if</span> (haveScore==<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//未点赞，可点赞</span><br>           <span class="hljs-comment">//数据库点赞数据+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//保存用户到redis的set集合</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().add(key,userId.toString(),System.currentTimeMillis());<span class="hljs-comment">//点赞榜单，使用sortedSet进行优化，以时间戳作为优先级排序</span><br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//已点赞，取消点赞</span><br>           <span class="hljs-comment">//数据库-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//将用户从redis的set集合移除</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>排行榜实现：根据博客查询redis集合（点赞人）-&gt; 按照指定顺序返回点赞人集合</li><li>关注点：如何在in的情况下按照指定顺序返回数据：见注释<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">//查询top5的点赞用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//解析出用户id</span><br>    <span class="hljs-keyword">if</span> (top5==<span class="hljs-literal">null</span>||top5.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">//in查询数据库是按照默认id顺序，所以需要进行指定顺序，order by field(id,5,1)#根据id按照5，1进行返回</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>    List&lt;User&gt; users = userService.query().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br>            .last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>)<br>            .list();<br>    List&lt;UserDTO&gt; userDTOS = users.stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">//返回userdto</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><h4 id="关注功能实现"><a href="#关注功能实现" class="headerlink" title="关注功能实现"></a>关注功能实现</h4><ul><li>简单实现 <ul><li>建立数据库表tb_follow，有userid，followUserid字段来实现关注功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">//获取当前登录的userId</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//查询当前用户是否关注了该笔记的博主</span><br>        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>        <span class="hljs-comment">//只查询一个count就行了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count(queryWrapper);<br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFellow)</span> &#123;<br>        <span class="hljs-comment">//获取当前用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//判断是否关注</span><br>        <span class="hljs-keyword">if</span> (isFellow) &#123;<br>            <span class="hljs-comment">//关注，则将信息保存到数据库</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//取关，则将数据从数据库中移除</span><br>            LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>            remove(queryWrapper);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>共同关注功能实现<ul><li>利用redis的set集合存储用户的关注对象，对两个用户的关注对象集合求交集即可求出共同关注。下面为修改之后的关注功能实现，即将关注的对象加入redis中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>     <span class="hljs-comment">//获取用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userDTO.getId();<br>     <span class="hljs-comment">//判断是否关注</span><br>     <span class="hljs-keyword">if</span> (isFollow)&#123;<br>         <span class="hljs-comment">//关注则新增数据</span><br>         <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>         follow.setUserId(userId);<br>         follow.setFollowUserId(followUserId);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注的用户的id，放进redis的set集合 ： sadd userId followerUserId</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().add(key,followUserId.toString());<br>         &#125;<br>     &#125;<span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//取关，删除数据</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                 .eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId)<br>                 .eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>,followUserId));<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注用户的id从redis移除</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().remove(key,followUserId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="推送功能实现"><a href="#推送功能实现" class="headerlink" title="推送功能实现"></a>推送功能实现</h4><ul><li>feed流<ul><li>当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂。</li><li>feed流有两种模式：<ul><li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等)</li><li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</li></ul></li></ul></li><li>Timeline三种模式：<ul><li>推</li><li>拉</li><li>推拉结合</li></ul></li><li>我们使用推模式进行实战<ul><li>需求：<ul><li>修改新增博客的业务，在博客保存到数据库的时候，也推送到粉丝的收件箱。</li><li>收件箱按时间戳排序</li><li>收件箱实现分页查询</li></ul></li><li>难点：<ul><li>传统情况下分页查询是根据角标进行，但是因为我们的feed数据会更新，同时脚标也会更新，所以不能使用脚标。<ul><li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页<br><img src="/../img/%E8%A7%92%E6%A0%87%E5%8F%98%E5%8C%96.png" alt="角标变化"></li></ul></li><li>使用score来进行分页可以解决问题<ul><li>score使用时间戳来进行记录</li><li>根据集合名（当前登录id的关注集合），最小分数，最大分数，开始偏移量，查询个数 reverseRangeByScoreWithScores(key, 0, max, offset, 2);</li><li>每次查询完毕后需要返回最小时间戳，作为下次查询条件</li><li>偏移量的作用是防止出现相同时间戳的情况，为上次查询返回的相同最小时间戳的个数，关键，1最小时间戳（即最后一个），2相同</li><li>封装返回</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">//获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//查询用户收件箱（set(key（feed:userid),粉丝的id）)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;feed:&quot;</span>+userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>            <span class="hljs-comment">//查询的集合，最小分数值，最大分数值，起始偏移，查询数量</span><br>            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples==<span class="hljs-literal">null</span>||typedTuples.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//解析数据</span><br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple:typedTuples)&#123;<br>        <span class="hljs-comment">//获取id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> typedTuple.getValue();<br>        ids.add(Long.valueOf(id));<br>        <span class="hljs-comment">//获取score（时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (time==minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//解决sql in无法排序问题，手动指定顺序为传入的ids</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);              <span class="hljs-comment">//&quot;order by field(id,&quot; + &quot;3,4,5&quot; + &quot;)&quot;</span><br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>,ids).last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog:blogs)&#123;<br>        <span class="hljs-comment">//查询发布blog的用户信息</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">//查询当前用户是否给该blog点过赞</span><br>        isBlogLiked(blog);<br>    &#125;<br>    <span class="hljs-comment">//封装结果并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">scrollResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    scrollResult.setList(blogs);<br>    scrollResult.setOffset(os);<br>    scrollResult.setMinTime(minTime);<br>    <span class="hljs-keyword">return</span> Result.ok(scrollResult);<br>&#125;<br></code></pre></td></tr></table></figure> <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-优惠券秒杀</title>
    <link href="/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/"/>
    <url>/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="全局id"><a href="#全局id" class="headerlink" title="全局id"></a>全局id</h4><ul><li>原因：<ul><li>抢购商品时，订单保存到订单表之中，如果将订单id设置为数据库的自增id的话，规律性太明显，并且单表数据量有限制。</li></ul></li><li>实现：<ul><li>符号位 + 时间戳 + 序列号 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span>&#123;<br>        <span class="hljs-comment">//生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">//生成序列号</span><br>        <span class="hljs-comment">//获取当前日期，精确到天（将key以天分组，方便管理，并且解决redis自增上限问题）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">//自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">//拼接并且返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<span class="hljs-comment">//先左移32位，再或运算将count补上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="实现秒杀"><a href="#实现秒杀" class="headerlink" title="实现秒杀"></a>实现秒杀</h4><ul><li>秒杀券和其他普通优惠券类似，普通优惠券可以任意购买，而秒杀券需要在特定时间并且一人一单的方式进行抢购。券在一张表，包含所有的券，其中用一个字段标明其是否是秒杀券，并且还有一张秒杀券表，可采用类似于外键进行关联，其中包含的是秒杀券的一些特定信息（抢购时间，结束时间，库存等）。</li><li>抢秒杀券：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5. 扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>,voucherId)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">//6.1 设置订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">//6.2 设置用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//6.3 设置代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(id);<br>    <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>    save(voucherOrder);<br>    <span class="hljs-comment">//8. 返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><ul><li>上面代码有很明显的问题，就是在高并发场景下会出现超卖现象。原因就在于，在库存判断和库存扣除两步中并没有锁来约束。</li><li>我们可以进行加锁来解决：<ul><li>悲观锁<ul><li>悲观锁认为线程安全一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock等，都是悲观锁。</li></ul></li><li>乐观锁：<ul><li>乐观锁认为线程安全问题不一定发生，因此不加锁，只在数据更新的时候再去判断有没有其他线程对数据就进行了修改。<ul><li>如果没有修改，则认为自己是安全的，自己可以更新数据。</li><li>如果被其他线程进行了修改，则说明发生了安全问题，此时继续重试或者异常。</li></ul></li></ul></li><li>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</li><li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。</li></ul></li><li>在本项目中，并不需要指定版本号，可以使用stock进行替代，比较查询时的stock数据和修改时的数据库中的stock数据是否一致（因为stock只会减少，不会增加，因此不会出现aba问题，所以可以代替版本号）。</li></ul><h4 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h4><ul><li>操作逻辑，进行库存判断之后，根据订单表中的数据，判断用户是否已经购买过。<ul><li>购买过则不能下单</li></ul></li><li>初步逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一人一单逻辑</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果在多线程情况下，在执行一人一单的逻辑之前，在这个区间如果进来了多个线程，仍然能抢多张优惠券。即 线程1:库存充足-&gt;判断一人一单（此时该优惠券中并没有写入userid）-&gt;此时线程2：库存充足-&gt;优惠券无userid-&gt;线程2写入userid-&gt;线程1写入userid</li><li>解决办法<ul><li>添加悲观锁<ul><li>将一人一单后的逻辑写入一个方法createVouherOrder，并对该方法加锁。</li><li>但是此时的粒度太粗，当该方法有锁时，所有用户都无法进行此方法，而我们的目的是一人一单，所以这个锁，应该加在单个用户上，使用userid来标识。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 一人一单逻辑</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<span class="hljs-comment">//需要根据userid的字面量来进行加锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//5. 扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//6. 创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">//6.1 设置订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">//6.2 设置用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//6.3 设置代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setUserId(id);<br>        <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>        save(voucherOrder);<br>        <span class="hljs-comment">//8. 返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>    <span class="hljs-comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用AopContext.currentProxy()来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去IVoucherOrderService中创建createVoucherOrder方法</li><li>并且导入依赖aspectjweaver，以及在启动类加上注解@EnableAspectJAutoProxy(exposeProxy &#x3D; true)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h4><ul><li>通过加锁可以解决在单机情况下的一人一单问题，但是在集群模式下就不行了。<br><img src="/../img/jvm%E9%94%81.png" alt="jvm锁"></li><li>如上图所示，jvm中的锁都是按照单机为域划分的，所以在集群模式下我们需要使用分布式锁，即让锁不在jvm内部，而是让锁在jvm外，为公用的锁。</li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><ul><li>分布式锁：满足分布式系统或者集群模式下的多线程可见的并且可以互斥的锁。<br><img src="/./../img/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="分布式锁"></li><li>分布式锁应该满足的条件：<ul><li>可见性：每个线程，每个服务器都能看到锁</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全</li></ul></li><li>常见的分布式锁：<ul><li>mysql</li><li>redis</li><li>zookeeper<br><img src="/../img/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="常见分布式锁"></li></ul></li><li>redis实现分布式锁：<ul><li>核心思路：利用redis的SETNX方法，当多个线程进入时，利用该方法获取锁，第一个线程进入时，redis则有这个key，返回1，表示他抢到了锁，那么他去执行业务，完成后，再删除锁，退出锁，没有抢到锁的线程则等待重试。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">//锁的前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//自动拆箱可能会出现null，这样写更稳妥</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//通过DEL来删除锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br><span class="hljs-comment">// 获取锁对象</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock(<span class="hljs-number">120</span>);<br><span class="hljs-comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许抢多张优惠券&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取代理对象</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    redisLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>redis分布式锁误删问题：<ul><li>逻辑说明：<ul><li>如果持有锁的线程1在内部出现了阻塞，导致锁ttl过期，自动释放。</li><li>此时线程2来获取锁，因为线程1已经释放了锁，所以线程2拿到了锁</li><li>现在线程1阻塞结束，继续执行业务，再释放锁。&#x2F;</li><li>此时会将线程2的锁释放。</li></ul></li><li>解决办法<ul><li>在线程释放锁的时候判断该锁是否是自己的。</li><li>实现：存入锁的时候放入自己的线程标识，释放的时候再对锁进行判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标识是否一致</span><br>    <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>分布式锁的原子性问题：<ul><li>更为极端的误删逻辑说明</li><li>假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制）</li><li>于是锁的TTL到期了，自动释放了</li><li>那么现在线程2趁虚而入，拿到了一把锁</li><li>但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑</li><li>但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了</li><li>那么就相当于判断标识那行代码没有起到作用</li><li>这就是删锁时的原子性问题</li><li>因为线程1的拿锁，判断标识，删锁，不是原子操作，所以我们要防止刚刚的情况</li></ul></li><li>使用lua脚本解决多条命令的原子性问题<ul><li>Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;其他参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure></li></ul></li><li>但是此时分布式锁仍然存在问题：锁不住。<ul><li>因为当锁的ttl快到期的时候，我们并没有实现续期功能。</li><li>所以得依赖redisson来解决续期问题。</li></ul></li></ul><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><ul><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题<br><img src="/../img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="可重入锁"></li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h4><ul><li>我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br><img src="/../img/%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96.png" alt="异步优化"></li><li></li></ul><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在力扣中有许多层序遍历相关的题目，但基本都是以下面这题为基础进行修改的，所以记录一下，加强理解。</p><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p></blockquote><p>  [TOC]</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>类似于图的广度优先遍历，利用队列的性质，每次先入队一个节点，然后对其进行出队，出队后判断其是否还有子节点，有子节点则再次入队，并且用for循环进行当前层级的遍历，因为当前每次进行节点出队前的deque的size就是当前层次的节点数量。</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//存储列表的列表</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//为空则返回空列表</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.add(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<span class="hljs-comment">//定义个数，用来分层</span><br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//定义每个层次的节点列表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">//用来对当前层进行操作</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                level.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><ol><li>前后序遍历：<br>前序遍历和后续遍历比较简单，类似于图的广度优先遍历。前序遍历利用栈来保存节点，当栈不为空，弹出节点，进行左右节点的判断，有的话将左右节点入栈。需要考虑一下的就是入栈和出栈的顺序问题，因为栈先进后出的特点，所以需要逆向存储，前序遍历中，本该是中左右，但是由于栈的特性，我们应该先中，右，左。而后续遍历考虑一下左右顺序并将list反转一下即可。</li><li>中序遍历：利用栈存储已经浅层次访问的节点（未进行遍历，以及右节点的判断），再利用cur指针，进行遍历，cur先深入最左底部，并存储访问的节点，如果该节点的左节点访问完全，则输出根节点，再进行右节点的访问。有点绕，具体见代码：</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;            <br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-comment">//cur!=null代表的是向左还没走完，stack!=null代表的是已经走过的节点还未完全判断访问（例如右节点）</span><br>            <span class="hljs-comment">//左节点访问：</span><br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到了最左</span><br>                stack.push(cur);<span class="hljs-comment">//存储访问过的元素</span><br>                cur = cur.left;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = stack.pop();<br>                result.add(cur.val);<span class="hljs-comment">//进行左的遍历</span><br>                cur = cur.right;<span class="hljs-comment">//这一步就决定上面需要使用else</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//先判断有无左右节点，有则反方向放入节点，如右左根</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-商户缓存</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="缓存的基本知识"><a href="#缓存的基本知识" class="headerlink" title="缓存的基本知识"></a>缓存的基本知识</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><ol><li>缓存是数据交换的缓冲区，一般从数据库中获取，存储在本地。</li><li>redis缓存:由于其被static修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被final修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build();<br></code></pre></td></tr></table></figure></li></ol><h4 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h4><ol><li>速度快</li><li>缓存数据存储在代码之中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户并发访问给服务器带来的读写压力。</li><li>实际开发之中，数据量往往很大，如果没有缓存作为“减震器”，系统很难支撑。</li><li>缓存会增加代码复杂度和运营成本。</li><li>降低后端负载，提高读写速度。</li><li>数据一致性成本，代码维护成本，运维成本。</li></ol><h4 id="商户缓存的使用"><a href="#商户缓存的使用" class="headerlink" title="商户缓存的使用"></a>商户缓存的使用</h4><ol><li>缓存作用模型：<br><img src="/../img/%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg" alt="缓存作用模型"></li></ol><h3 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h3><ol><li>什么是缓存更新<ul><li>缓存更新就是为了节约内存而设计的，因为内存数据宝贵，当向redis插入太多数据时，可能会导致缓存中数据过多，所以需要对redis中的数据进行更新，或者淘汰。</li><li>内存淘汰：当redis数据大过我们设定的max_memory时，会自动触发淘汰机制，淘汰不重要的数据（可以自己设置策略）。</li><li>超时剔除：给redis数据设置ttl（time to live），redis会将超时的数据进行删除。</li><li>主动更新：手动调用方法删除缓存，通常用来解决缓存和数据库不一致的问题。</li></ul></li><li>业务场景<ul><li>低一致需求：使用内存淘汰机制，如店铺类型的查询缓存。</li><li>高一致需求：主动更新，以超时剔除兜底，如店铺详情查询。</li></ul></li><li>缓存不一致的解决方案：<ol><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li><li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li><li>目前采用的方案：方案一<ol><li>如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来</li><li>因为更新缓存读写操作麻烦，所以直接删除缓存，等有新数据再直接写入缓存，完成更新。</li></ol></li><li>保证数据库和缓存同时成功和失败：</li></ol><ul><li>单体系统：将缓存和数据库操作放在一个事务之中。</li><li>分布式系统：利用TCC等分布式事务方案</li></ul><ol start="6"><li>数据库 缓存：<ul><li>出现问题的原因就在于，在数据库操作和缓存更新中间的时间里，可能会有其他线程进行操作。比如当线程1进行删除操作时，在更新数据库完成前，另一个线程2进来查询，发现此时缓存未命中，于是查询未更新完的数据库，写入缓存。然后线程1的更新完成了，但是此时缓存中已经被线程2以脏数据写入，此时的缓存等于并没有更新，所以此时数据库和缓存仍然不一致。<br> <img src="/../img/%E5%85%88%E7%BC%93%E5%AD%98%E5%86%8D%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="先缓存再数据库"></li><li>因为数据库操作时间长，所以先删除缓存再更新数据库，在数据操作和删除缓存之间的危险时间更长。</li><li>先操作数据库，再删除缓存<br> 线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题。<br> <img src="/../img/%E5%85%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E7%BC%93%E5%AD%98.png" alt="先数据库再缓存"></li></ul></li></ol></li></ol><h3 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透： 缓存穿透是指客户请求的数据在缓存和数据库之中都不存在，这样的请求会导致频繁的访问数据库。</p><pre><code class="hljs">1. 解决方案：缓存空对象  - 优点：实现简单，维护方便  - 缺点：额外的内存消耗，造成短期的不一致2. 布隆过滤  - 优点：内存占用少，没有多余key  - 实现复杂，可能误判</code></pre><ul><li><p>缓存空对象：当数据库和redis都没有该数据时，直接生成该数据&lt;key-“”&gt;存储到redis之中。所以有了额外的内存消耗，短期不一致是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过（因为这是插入语句，一般来说插入语句就是直接插入到数据库，然后通过key查询缓存，发现没有缓存再查询数据库，将key-value保存到redis，此时因为又存在redis，所以并不会对redis进行更新，得等到ttl过才会更新），所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了。</p></li><li><p>布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突</p></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul><li>缓存雪崩：是指在同一时间段，大量缓存的key同时失效，或者redis服务器宕机，导致大量的请求到达数据库，带来巨大的压力。</li><li>解决方案<ul><li>给不同的key添加不同的TTL，让其分批失效。</li><li>使用熔断机制，给流量设置一定阈值。</li><li>搭建redis集群（防止redis宕机）</li></ul></li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul><li>缓存击穿：与缓存雪崩类似，缓存雪崩是大规模的key失效，而缓存击穿是 一个 热点的Key（高并发访问，缓存业务重建业务复杂），有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。例如：一件抢购中的商品的key失效。</li><li>解决方案：<ul><li>互斥锁</li><li>逻辑过期</li></ul></li><li>互斥锁：利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题，线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。<br><img src="/../img/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"><ul><li>逻辑过期：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案<br>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据<br>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据。<br><img src="/../img/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png" alt="逻辑过期"></li></ul></li><li>互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响</li><li>逻辑过期方案：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦。<style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-登录注册实现</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基于Redis优化session来进行短信登陆"><a href="#基于Redis优化session来进行短信登陆" class="headerlink" title="基于Redis优化session来进行短信登陆"></a>基于Redis优化session来进行短信登陆</h3><h4 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h4><ol><li>发送验证码<br>首先根据用户的手机号进行判断，是否合法，合法则可以进行发送验证码。通过session进行保存。</li><li>通过验证码进行登录，注册<br>通过实体LoginFormDTO，封装手机号，验证码，密码（暂时只考虑手机号和验证码），先进行手机号合法性的判断，合法再判断手机号和验证码是否与session中存储的一致。</li></ol><hr><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：当客户端访问某一个地址时，会将请求交给服务器进行处理，在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理，在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息，浏览器在接受响应后会按照cookie信息在客户端简历cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="/../img/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 </li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="/../img/session%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li>cookie和session的比较：<ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="/../img/cookie%EF%BC%8Csession%EF%BC%8C%E4%BB%A4%E7%89%8C%E5%AF%B9%E6%AF%94.png" alt="Alt text"></li></ul></li></ul><hr><ol><li>校验登陆状态，实现拦截<br>用户在进行请求时，会从cookie中携带JsessionId到服务端，服务端通过JsessionId从session中获取信息，没有session信息则进行拦截，有session信息则将用户信息保存到threadLocal中，并放行。<br>拦截器的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2. 获取session中的用户信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//4. 不存在，则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br>        UserHolder.saveUser(user);<br>        <span class="hljs-comment">//6. 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="Redis优化登录注册"><a href="#Redis优化登录注册" class="headerlink" title="Redis优化登录注册"></a>Redis优化登录注册</h4><ol><li>为什么需要优化？<br>因为session是存储在服务器之中的，所以当有多台tomcat时，会出现session共享问题，比如用户第一次访问了tomcat1，第二次访问了tomcat2，那么tonmcat2中肯定没有存放用户的session信息，所以此时登录拦截会出现问题。不改变session存储的解决方案有：将完整session拷贝到每一台tomcat中，并且及时同步，这就带来了两个问题：<ol><li>每个tomcat都有完整session，会造成服务器压力过大。</li><li>拷贝session数据时，可能会出现延迟。</li><li>所以我们使用redis进行实现，因为redis本身就是可以共享的。</li></ol></li><li>redis实现</li><li>设计key</li></ol><ul><li>由于redis全局共享，所以我们需要设计不重复，不暴露信息的key。可以直接让后台生成token进行业务。</li></ul><ol><li>登录后，根据手机号查询判断是否有用户信息 ，无则新建，将用户数据保存到redis，生成token作为key。有则进行校验，根据token判断数据是否存在。不存在则拦截，存在则将用户信息保存到threadLocal，并放行（token也存在请求头中）。</li><li>拦截器通过判断threadLocal是否为空进行判断拦截还是放行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-comment">//校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//校验验证码（从redis中）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<span class="hljs-comment">//获取用户输入的code</span><br>    <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>        <span class="hljs-comment">//不一致则报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建新用户并保存</span><br>        user = createUserWithPhone(phone);<span class="hljs-comment">//(user接收，便于保存)</span><br>    &#125;<br>    <span class="hljs-comment">//保存信息到redis</span><br>    <span class="hljs-comment">//随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> RedisConstants.LOGIN_USER_KEY + token;<br>    <span class="hljs-comment">//将user对象转为hash存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));<br>    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);<br>    <span class="hljs-comment">//设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//返回token</span><br>    <span class="hljs-comment">//session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>登录刷新问题<br>- 通过拦截器查看用户是否在操作，如果没有操作超过30分钟，删除token，用户重新登录<br>- 通过查看请求，如果请求头中有token，那么我们刷新token存活时间。<br>- 拦截器优化：在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br>   <img src="/../img/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96.png" alt="Alt text"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//获取请求头之中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//基于token获取redis中的用户（get是根据key以及字段取值，entries是根据key取值）</span><br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash()<br>            .entries(token);<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//将查询到的hash数据转为userDTO</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap,<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(),<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//将userDTO信息保存到threadLocal</span><br>    UserHolder.saveUser(userDTO);<br>    <span class="hljs-comment">//刷新token的有效期</span><br>    stringRedisTemplate.expire(token,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);<br>    <span class="hljs-comment">//放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-26记事</title>
    <link href="/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：闲来无聊，本应该是记单词的时间，但是又想练习打字，于是开始用电脑码一下今天的日记吧</p><h3 id="学习状态总结"><a href="#学习状态总结" class="headerlink" title="学习状态总结"></a>学习状态总结</h3><p>总体可以给自己打分80吧，今天又没去上课，在宿舍学习，效率一般，任务完成度还行，但是吸收的并不多，也进行了运动，下面是今日的统计情况，累计时长接近9小时</p><h4 id="23年09月26日"><a href="#23年09月26日" class="headerlink" title="23年09月26日"></a>23年09月26日</h4><blockquote><p><strong>08:00至09:58 【redis学习】  1小时58分钟</strong></p></blockquote><p>&emsp;redisson 联锁，可重用锁，</p><blockquote><p><strong>10:20至11:31 【redis学习】  1小时11分钟</strong></p></blockquote><p>&emsp;秒杀优化 异步下单，阻塞队列</p><blockquote><p><strong>14:30至15:50 【redis学习】  1小时20分钟</strong></p></blockquote><p>&emsp;调傻逼bug，总算解决了，但是不知道原因</p><blockquote><p><strong>15:50至17:30 【leetcode刷题】  1小时40分钟</strong></p></blockquote><p>&emsp;一道半力扣，小颓废唉</p><blockquote><p><strong>19:15至20:42 【redis学习】  1小时27分钟</strong></p></blockquote><p>&emsp;redis消息队列看完，不过没咋吸收全是api，语法</p><blockquote><p><strong>20:42至20:55 【leetcode刷题】  13分钟</strong></p></blockquote><p>&emsp;三道sql</p><blockquote><p><strong>20:55至22:00 【运动健身】  1小时5分钟</strong></p></blockquote><p>&emsp;引体，弯举，划船，卷腹</p><h3 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h3><p>自己这段时间还是太焦虑和着急了，基于求成进度，想快速的学完java进行实习，这样使自己草草的看完视频，码一下代码就安慰自己是学完了，说实话这真的是致命毒药，因为做项目的关键在于去面试找工作，面试官拷打你的项目的时候就是直接根据项目的技术栈来进行询问的，如果你回答不上来那么等于是没做，所以我现在的改变我的心态，必须吃透项目，并且看完一章节后根据网上资料以及ppt进行总结归纳，不要急于求成，每天起码画两三个小时去总结。<br>关于自己实习的问题也不能着急，你现在如果去一个垃圾小厂实习的话，一是可能学不到东西，赚不到钱，还有挂科的风险，并且最主要的是浪费了时间，这学期应该好好静下心来，学习java（redis，mq，sprincloud等），学习计网，还有备战六级，并且反复刷leetcode，最后一两个月，差不读学习完springcloud课程之后再进行八股，准备面试以及期末考试。<br>好吧就这样吧，加油，睡觉了！</p><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配下标-KMP算法</title>
    <link href="/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：尽管之前大二学数据结构我就学过kmp，但是由于这个算法比较复杂，并且自己划水一年，所以基本上是新学差不多，今天花了接近三个小时，重新梳理一下kmp的思路，以及注意事项。</p><p>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><ol><li>根据前后缀来进行快速匹配，使得不需要使用两个for循环来进行匹配，如图 <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="使用前后缀匹配" title="Magic Gardens"></li><li>如何进行匹配呢，我们借助next数组，next数组是一个和字串长度相等的int数组，相应的存储以该节点为后缀的最大公共前后缀长度，什么是公共前后缀呢？例如：aabaa字串的公共前后缀就是a,aa，所以其最大长度为2。</li><li>那么next数组如何发挥作用呢，我们依次匹配串，当有冲突时，我们利用next进行回溯，回溯到的位置就是 next[冲突位置索引-1] ，为什么呢，我们可以举一个例子，比如 串 a a b a a f，对应的next数组为0 1 0 1 2 0，当父串为：a a b a a b a a f,我们可以知道当匹配到父串的第二个b时会有冲突，所以回溯，根据next，父串指针不动，字串指针回溯到next[indexOf(‘f’)-1]即2，所以我们再次从子串的第一个b开始匹配。</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next,String s)</span>&#123;<br>    <span class="hljs-comment">//初始化 j 以及 next数组</span><br>    <span class="hljs-comment">//i：后缀末尾   j：前缀末尾</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length();i++)&#123;<span class="hljs-comment">//对于每一个后缀的结尾</span><br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))&#123;<span class="hljs-comment">//判断是否前后缀相等</span><br>            j = next[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//不匹配则 j 回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>    <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>    getNext(next,needle);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>        <span class="hljs-comment">//关键此处的 while和下面的if不能交换顺序！！</span><br>        <span class="hljs-comment">//反例如 父串 sads 子串 sad</span><br>        <span class="hljs-comment">//若是if(==)在前，当第一个匹配 s时，j++，此时i还没有++，所以在进行接下来的while时会进入while导致bug</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) <span class="hljs-comment">//不匹配则查找不匹配字符的前一个位置的next值，进行回溯</span><br>            j = next[j - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) <span class="hljs-comment">//匹配则两个指针同时后移，进行下一个的匹配</span><br>            j++;<br>        <span class="hljs-keyword">if</span> (j == needle.length()) <br>            <span class="hljs-keyword">return</span> i - needle.length() + <span class="hljs-number">1</span>;<span class="hljs-comment">//返回子字符串在父字符串中的匹配位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的单词</title>
    <link href="/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体思路为：整体的字符反转，字符中额外空格的删除，字符单词反转</p><p>字符反转很简单，使用双指针即可<br>删除字符中的额外空格有点麻烦，可以使用双指针（参考之前的数组移除元素），具体思路如下：定义快慢指针，用快指针遍历数组，当快指针指向非目标值时，将快指针的内容拷贝到慢指针处，然后fast++，slow++。主要留心中间空格以及两端空格的处理。<br>字符单词反转不麻烦但是得考虑全。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">char</span>[] sChars = s.toCharArray();<br>      <span class="hljs-comment">//字符串整体反转</span><br>      reverse(sChars,<span class="hljs-number">0</span>,sChars.length-<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//去除额外空格</span><br>      sChars = removeExtraSpace(sChars);<br>      <span class="hljs-comment">//单词内反转</span><br>      reverseEachWord(sChars);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sChars);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt;= chars.length; end++) &#123;<span class="hljs-comment">//便于让end总是指向每一个单词的末尾</span><br>          <span class="hljs-keyword">if</span>(end == chars.length || chars[end] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>              reverse(chars,start,end-<span class="hljs-number">1</span>);<br>              start = end + <span class="hljs-number">1</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] removeExtraSpace(<span class="hljs-type">char</span>[] chars)&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; chars.length; fast++) &#123;<br>          <span class="hljs-keyword">if</span> (chars[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<span class="hljs-comment">//整体为去除空格模板</span><br>              <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在非首位的每个单词后面添加一个空格</span><br>                  chars[slow] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                  slow ++;<br>              &#125;<br>              <span class="hljs-keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] !=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                  <span class="hljs-comment">//删除所有空格</span><br>                  <span class="hljs-comment">//将快指针的内容（非空格的字母）赋值给慢指针</span><br>                  chars[slow] = chars[fast];<br>                  slow++;<br>                  fast++;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//同时slow也就是到达了最后的有效位置，slow的大小就是处理完后的数组大小。</span><br>      <span class="hljs-type">char</span>[] newChar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[slow];<br>      <span class="hljs-comment">//数组拷贝，System.arraycopy(拷贝数组, 起始索引, 新数组, 起始索引, 拷贝长度); </span><br>      System.arraycopy(chars, <span class="hljs-number">0</span>, newChar, <span class="hljs-number">0</span>, slow); <br>      <span class="hljs-keyword">return</span> newChar;<br>  &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> end)</span>&#123;<br>      <span class="hljs-type">char</span> tmp;<br>      <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>          tmp = chars[start];<br>          chars[start] = chars[end];<br>          chars[end] = tmp;<br>          start ++;<br>          end --;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
