<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/10/14/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/14/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>Java中有8种基本数据类型<ul><li>6种数字类型<ul><li>4种整数类型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1种字符类型<ul><li>char</li><li>妈的，原来了<code>string</code>不是基本数据类型，java中根本没有<code>string</code>这个关键词</li></ul></li><li>一种布尔类型<ul><li><code>boolean</code></li></ul></li></ul></li><li>一个字节(byte)对应八个二进制位(bit)</li><li>基本类型和包装类型的区别<ul><li><strong>用途</strong>：包装类可以定义泛型，基本数据类型则不可以</li><li><strong>存储方式</strong>：<code>基本数据类型的局部变量存放在java虚拟机栈中的局部变量表之中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java虚拟机的堆中</code>。而<strong>包装类型属于对象类型</strong>，几乎所有的实例对象都是存放在堆中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> myInt; <span class="hljs-comment">// 基本数据类型的成员变量</span><br>    String myString; <span class="hljs-comment">// 引用数据类型的成员变量</span><br>    <span class="hljs-comment">// 其他代码和方法...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>占用空间</strong>：相比于包装类型，基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：包装类型不赋值就是null，基本类型有默认值。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code>比较的是值，对于包装数据类型来说，<code>==</code>比较的是对象的内存地址，所以对于包装对象之间的<strong>值的比较</strong>，全部使用<code>equals()</code>方法。</li></ul></li></ul><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><ul><li>作用：<ul><li>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</li><li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。</li><li><strong>简单来说就是：当你生成一个包装对象时，在缓存数值范围内的，系统已经给你创建好了，你直接用就行，并不会内部重新new对象，不在缓存内的就是在内部给你new出来，此时每个的地址都不同</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">packCache</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1，2 比较在缓存内，一个正常生成（直接使用缓存），</span><br>    <span class="hljs-comment">//一个手动new，返回false，因为一个使用的预先生产的缓存，</span><br>    <span class="hljs-comment">//一个是new</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">80</span>);<br>    <span class="hljs-comment">//1，3，在缓存范围内，都正常生成，结果地址相同，</span><br>    <span class="hljs-comment">//说明都是使用的预先生成好的缓存对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-comment">//比较超出缓存范围，返回false，因为超出范围，</span><br>    <span class="hljs-comment">//都是在内部new的</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100f</span>;<br>    System.out.println(f1 == f2);<span class="hljs-comment">//false，因为Float，Double没有实现缓存机制</span><br>    System.out.println(i1 == i2);<span class="hljs-comment">//false</span><br>    System.out.println(i1 == i3);<span class="hljs-comment">//true</span><br>    System.out.println(i4 == i5);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用他们对应的引用类型包装起来；<ul><li>调用了包装类的<code>valueof()</code></li></ul></li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；<ul><li>调用了<code>xxxValue()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 </span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<span class="hljs-comment">//上下等价</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<span class="hljs-comment">//上下等价</span><br></code></pre></td></tr></table></figure></li></ul></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li></ul><h4 id="浮点数精度丢失问题"><a href="#浮点数精度丢失问题" class="headerlink" title="浮点数精度丢失问题"></a>浮点数精度丢失问题</h4><ul><li>为什么会产生？<ul><li>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</li></ul></li><li>如何解决？<ul><li><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</li></ul></li></ul><h4 id="超过long类型的整形数据如何表示？"><a href="#超过long类型的整形数据如何表示？" class="headerlink" title="超过long类型的整形数据如何表示？"></a>超过long类型的整形数据如何表示？</h4><ul><li><code>BigInteger</code> 内部使用 int[] 数组来存储任意大小的整形数据。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h4><ul><li><strong>语法形式</strong>：<ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li></ul></li><li><strong>存储方式</strong>：<ul><li>如果成员变量使用<code>static</code>修饰，那么成员变量属于类，和实例一起存在堆之中，如果没有<code>static</code>修饰，那么是局部变量，存在栈之中</li></ul></li><li>生存时间：<ul><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li></ul></li><li>默认值：<ul><li>从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul></li></ul><h4 id="静态变量的作用？"><a href="#静态变量的作用？" class="headerlink" title="静态变量的作用？"></a>静态变量的作用？</h4><ul><li>静态变量就是被<code>static</code>修饰的变量，它可以被类的所有实例共享，无论类创建了多少个对象，它们都共享同一份静态变量。</li><li><strong>也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</strong></li></ul><h4 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h4><ul><li><strong>形式</strong>：字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong>：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。<strong>java中char占两个字节</strong></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="什么是方法的返回值-方法有哪几种类型？"><a href="#什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="什么是方法的返回值?方法有哪几种类型？"></a>什么是方法的返回值?方法有哪几种类型？</h4><ul><li>方法的返回值：<ul><li>方法的返回值 是指我们获取到的某个方法体中的代码<strong>执行后产生的结果</strong>！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</li></ul></li><li>类型：<ul><li>有参有返</li><li>无参无返</li><li>有参无返</li><li>无参有返</li></ul></li></ul><h4 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h4><ul><li>与jvm相关<ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul></li></ul><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><ul><li><strong>调用方式</strong><ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名 </code>的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 </li><li>不过不建议调用静态方法时，使用<code>对象.方法名</code>,因为静态方法是属于类，而不是实例对象，使用<code>对象.方法名</code>容易混淆</li></ul></li><li><strong>访问类成员存在限制</strong><ul><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ul></li></ul><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p></blockquote><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><ul><li><strong>重载</strong>：<ul><li>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果多个方法(比如 StringBuilder 的构造方法)有相同的名字、不同的参数， 便产生了重载。</span><br>  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><strong>重载就是同一个类之中多个同名方法根据传参的不同执行不同的处理逻辑</strong></li></ul></li><li><strong>重写</strong><ul><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</li><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li><li><strong>重写就是子类堆父类的重新改造，外部样子不能变，内部逻辑可以变</strong></li></ul></li></ul><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h4 id="创建一个对象以及对象实体和对象引用有何不同"><a href="#创建一个对象以及对象实体和对象引用有何不同" class="headerlink" title="创建一个对象以及对象实体和对象引用有何不同"></a>创建一个对象以及对象实体和对象引用有何不同</h4><ul><li>创建对象<ul><li>使用<code>new</code>创建对象实例（存放在堆内存之中），对象引用指向对象实例（对象引用存放在栈内存之中）</li><li>即栈内存中的对象引用存储的是对象实例地址或者引用，并不直接存储实例对象的数据</li><li>一个对象引用可以指向0-1个对象</li><li>一个对象可以被n个对象引用所指向</li></ul></li><li>对象的相等和引用的相等<ul><li>对象的相等一般比较他们在内存中存放的内容是否相等</li><li>引用相等一般比较的是他们指向的内存地址是否相等</li></ul></li><li>对象和引用的比较<ul><li>对象是指内存中分配的一块区域，用于存储数据和方法。</li><li>引用是指用于标识或指向对象的变量或值。它类似于一个指针或标签，提供了对对象的间接访问方式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个Person对象并通过引用进行操作</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="如果一个类没有声明构造方法，还能正常执行吗？"><a href="#如果一个类没有声明构造方法，还能正常执行吗？" class="headerlink" title="如果一个类没有声明构造方法，还能正常执行吗？"></a>如果一个类没有声明构造方法，还能正常执行吗？</h4><ul><li>构造方法<ul><li>构造方法是一种特殊的方法，主要工作是完成对象的初始化工作。</li></ul></li><li>没有声明构造方法，也可以正确执行<ul><li>因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li><li>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</li><li>创建对象时的()就是在调用无参的构造方法</li></ul></li><li>特点：<ul><li>名字与类名一致</li><li>无返回值，也不能用void声明</li><li>生成类的对象时自动执行，无需调用（或者可以说new对象时的()就是在调用）</li><li>无法被override 重写，但是可以被overload 重载</li></ul></li></ul><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><ul><li>封装<ul><li>不允许外部直接访问类的内部，而需要通过类所定义的方法来获取内部的数据</li></ul></li><li>继承（extends）<ul><li>使用已存在的类的定义作为基础建立新类的技术</li><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li>多态<ul><li>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例</li><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但在父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 定义一个父类 Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The animal makes a sound.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义两个子类 Dog 和 Cat 继承自 Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建 Animal 类型的引用指向不同的子类对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>        <span class="hljs-comment">// 调用 makeSound 方法，根据实际对象类型，会执行相应的子类方法</span><br>        animal1.makeSound();  <span class="hljs-comment">// 输出: The dog barks.</span><br>        animal2.makeSound();  <span class="hljs-comment">// 输出: The cat meows.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h4><ul><li>相同点<ul><li>都不能被实例化</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ul></li><li>区别<ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类 Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String name;<br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; is sleeping.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 接口 Swimmable</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体类 Dog 继承自 Animal，并实现 Swimmable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog is swimming.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.name = <span class="hljs-string">&quot;Bobby&quot;</span>;<br>        dog.makeSound();  <span class="hljs-comment">// 输出: The dog barks.</span><br>        dog.sleep();      <span class="hljs-comment">// 输出: Bobby is sleeping.</span><br>        dog.swim();       <span class="hljs-comment">// 输出: The dog is swimming.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="浅拷贝和深拷贝区别？什么是引用拷贝？"><a href="#浅拷贝和深拷贝区别？什么是引用拷贝？" class="headerlink" title="浅拷贝和深拷贝区别？什么是引用拷贝？"></a>浅拷贝和深拷贝区别？什么是引用拷贝？</h4><ul><li>深浅拷贝的区别<ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。<br><img src="/../img/%E6%B7%B1%E6%B5%85%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB.png"></li></ul></li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h4 id="Object类的常见方法"><a href="#Object类的常见方法" class="headerlink" title="Object类的常见方法"></a>Object类的常见方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h4><ul><li>对于基本数据类型：<ul><li><code>==</code>比较的是值</li><li>无法使用<code>equals()</code>,<code>equals()</code>方法存在于<code>Object</code>类中</li></ul></li><li>对于引用类型：<ul><li><code>==</code>比较的是对象的内存地址</li></ul></li><li><code>equals()</code><ul><li><strong>类没有重写 equals()方法：</strong>通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object类equals()方法。</li><li><strong>类重写了 equals()方法：</strong>一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li><li>例如String中的<code>equals()</code>就被重写，使equals()从比较地址，变为比较对象的值</li></ul></li></ul><h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h4><ul><li>hashCode() 是 Java 中的一个方法，它用于计算对象的哈希（hash code）。哈希码是一个整数值，通常用于快速确定对象在哈希表等数据结构中的存储位置</li><li>所以hashCode()也能进行比较，但是为什么还需要equals()呢？<ul><li>因为可能有哈希碰撞</li><li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li></ul></li><li>为什么重写 equals() 时必须重写 hashCode() 方法？<ul><li>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</li></ul></li><li>因为hashCode()在查找定位有特殊的作用，所以需要，而hashCode()又不能完全代替equals()所以，也需要equals()</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h4 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h4><ul><li><p><code>String</code>是不可变化的</p></li><li><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，并且有一些方法</p></li><li><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p></li><li><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p></li><li><p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的,性能比<code>StringBuffer</code>高10%- 15%</p></li><li><p><strong>使用</strong></p><ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul></li></ul><h4 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变</li></ul><h4 id="字符串的拼接-“-”-StringBuilder"><a href="#字符串的拼接-“-”-StringBuilder" class="headerlink" title="字符串的拼接 “+” &#x2F; StringBuilder"></a>字符串的拼接 “+” &#x2F; StringBuilder</h4><ul><li>字符串对象通过 “+” 的字符串拼接实际上是通过 <code>StringBuilder</code>调用<code>append()</code>方法实现的</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><ul><li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</li><li>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？<ul><li>会创建1或者2个对象</li><li>当常量池中没有”abc”的引用时，那么会先在字符串常量池创建”abc”，然后再在堆空间创建。</li><li>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”</li></ul></li></ul><h4 id="String-intern"><a href="#String-intern" class="headerlink" title="String intern()"></a>String intern()</h4><ul><li>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul></li></ul><h4 id="String-“-”"><a href="#String-“-”" class="headerlink" title="String “+”"></a>String “+”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为是常量字符串，jvm会在编译阶段就将其放入字符串常量池（str1，str2，str3）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-comment">//常量折叠：</span><br><span class="hljs-comment">//String str3 = &quot;str&quot; + &quot;ing&quot;; 编译器会给你优化成 String str3 = &quot;string&quot;;</span><br><span class="hljs-comment">//String str4 = new StringBuilder().append(str1).append(str2).toString(); 对于对象引用 + 的拼接其实是通过StringBuilder调用append()然后再调用toString()产生了一个新的String对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-comment">//str3是一个新对象，由StringBuilder产生</span><br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/14/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%86%8D%E5%A4%8D%E7%9B%98/"/>
    <url>/2023/10/14/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%86%8D%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="/2023/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2023/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><ul><li>进程间基于网络通信（<strong>运输层作用</strong>）<ul><li>物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了<strong>主机到主机的通信</strong>。</li><li>然而在计算机网络中<strong>实际进行通信的真正实体，是位于通信两端主机中的进程</strong>。</li><li>如何为<strong>运行在不同主机上的应用进程</strong>提供直接的逻辑通信服务，就是运输层的主要任务。运输层协议又称为端到端协议。</li><li>运输层向应用层实体<strong>屏蔽了下面网络核心的细节</strong>（例如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条<strong>端到端的逻辑通信信道</strong>。<br><img src="/../img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png"></li></ul></li><li>运输层端口号<ul><li>运行在计算机上的进程是使用进程标识符（Process Identification，PID）来标识的（每个PCB（进程控制块）由其唯一的PID标识）<ul><li>因特网也有其类似的实现，使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识</li></ul></li><li>TCP&#x2F;IP体系结构的运输层使用<strong>端口号</strong>来标识和区分应用层的不同应用进程。端口号的长度为16比特，取值范围是0~65535。<br><img src="/../img/%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D.png"></li><li>端口号应用举例<ul><li>用户端根据域名向DNS服务器发起请求（通过标识自己的端口号，以及目标端口号），申请获取该域名的IP地址<ul><li>DNS服务器：存储了域名和对应IP，类似于一个电话簿</li></ul></li><li>DNS返回IP地址</li><li>用户端根据IP地址发起请求访问Web服务器</li><li>Web服务器根据请求，返回内容</li><li>**上述交流信息的TCP首部均包含了”源端口”以及”目的端口”的信息</li></ul></li></ul></li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP基本概览"><a href="#TCP基本概览" class="headerlink" title="TCP基本概览"></a>TCP基本概览</h4><ul><li>什么是 TCP ？<ul><li>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。<ul><li><strong>面向连接：</strong>一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的：</strong>无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流传输：</strong>用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文</li></ul></li></ul></li></ul><h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><p>  <img src="/../img/tcp%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><h4 id="三报文握手-建立TCP连接"><a href="#三报文握手-建立TCP连接" class="headerlink" title="三报文握手 建立TCP连接"></a>三报文握手 建立TCP连接</h4><ul><li>“三报文握手”建立TCP连接的目的<ul><li>使TCP双方能够确知对方的存在。</li><li>使TCP双方能够协商一些参数（例如最大报文段长度、最大窗口大小、时间戳选项等）。</li><li>使TCP双方能够对运输实体资源进行分配和初始化。运输实体资源包括缓存大小、各状态变量、连接表中的项目等。</li></ul></li><li>流程<br>  <img src="/../img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></li><li>为何不能省去第三次<ul><li>避免资源的浪费<ul><li>当客户端的一个请求阻塞时，会重新发送请求，然后和服务端建立连接。</li><li>再传输数据后，会关闭连接</li><li>此时之前阻塞的请求又发送到了服务端，因为服务端是被动打开的，所以服务端根据请求会发送确认报文。</li><li>但是此时的客户端已经关闭，而且无法被服务端给唤醒，所以不会理财服务端的请求</li><li>此时服务端会一直开启并且等待客户端响应，浪费了资源<br><img src="/../img/%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></li></ul></li></ul></li></ul><h4 id="四报文挥手-释放TCP连接"><a href="#四报文挥手-释放TCP连接" class="headerlink" title="四报文挥手 释放TCP连接"></a>四报文挥手 释放TCP连接</h4><p><img src="/../img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ul><li>小问题<ul><li>不进行时间等待会怎么样？<ul><li>如果不进行时间等待，在客户端发送确认报文并加入关闭阶段时，服务端无法收到，因此无法关闭，而此时客户端已经关闭，无法进行超时重传<br><img src="/../img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85%E4%BD%9C%E7%94%A8.png"></li></ul></li></ul></li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li>流量控制的基本概念<br><img src="/../img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"><ul><li>因为服务端应用程序可能正忙于其他任务，并不一定能够立刻取走数据。如果不根据此时服务接收方的接收缓存情况来进行流量控制的话，会造成数据的溢出丢失</li></ul></li><li>流量控制的方法<ul><li>首先在建立tcp连接时，接收方会告诉发送方：我的接收窗口大小为400，此时，发送方会将自己的发送窗口大小也设为400</li><li>发送方解析接收方的响应数据包，根据接收方的接收窗口大小调整自己的发送窗口大小</li><li>发送方通过向前滑动发送窗口的方式移除已确认被正确接收的数据，并将他们从缓冲区删除</li><li>发送方只发送自己发送窗口内的数据</li><li>发送窗口向前滑动的前提是发送窗口的数据确认被正确接收</li></ul></li><li>问题<ul><li>如果接收窗口为0，那么此时发送窗口也会相应变为0，此时该如何破解这个局面呢？<ul><li>当发送方的发送窗口变为0后，会启动一个持续计时器， 当计时结束，发送方会主动发送一个零窗口探测报文，接收方必须接收该报文</li></ul></li><li>如果零窗口探测报文丢失呢？<ul><li>零窗口探测报文段也有设置的有重传计时器，如果丢失，等待该计时器超时，然后重传零窗口探测报文段</li></ul></li><li>为什么接收方接收窗口为0时还能接收零窗口探测报文<ul><li>TCP规定，就算接收窗口为0，也必须接受零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段</li></ul></li></ul></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li>拥塞控制的基本概念<ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞（congestion）。</li></ul></li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。<br><img src="/../img/%E6%8B%A5%E5%A1%9E%E5%90%9E%E5%90%90%E9%87%8F.png"></li><li>流量控制与拥塞控制的区别<ul><li>流量控制是服务器可能正忙于其他任务，当接收缓存满了之后并一定能及时的取走数据，导致新来的数据会被丢弃</li><li>拥塞控制是指防止过多的数据注入到网络之中，使网络能够承受现有的网络负荷</li></ul></li><li>方法概念<ul><li>为了防止cwnd（发送方的拥塞窗口，决定了发送窗口）增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意。</li></ul></li><li>如何确定网络拥塞？<ul><li>其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</li></ul></li></ul></li><li>拥塞控制的四种方法<ul><li>慢开始<ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加倍</li></ul></li><li>拥塞避免<ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</li></ul></li><li>快重传<ul><li>快重传就是要求接收方在收到一个失序的报文段后就立即发出重复确认，而不是等到主机发送数据时捎带确认。</li><li>快重传规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li></ul></li><li>快恢复<ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="/../img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"></li></ul></li></ul></li></ul><h4 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h4><ul><li>以字节为单位的滑动窗口</li><li>超时重传（超时时间主要为加权平均往返时间）</li><li>选择确认</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ul><li>连接<ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul></li><li>服务对象<ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul></li><li>可靠性<ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul></li><li>拥塞控制，流量控制<ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li><li>首部开销<ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li><li>传输方式<ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul></li><li>应用场景<ul><li>TCP<ul><li>FTP 文件传输</li><li>HTTP &#x2F; HTTPS</li></ul></li><li>UDP<ul><li>包总量较少的通信</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2023/10/13/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/13/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>什么是01背包问题呢？<br>就是每个物品最多只能使用1次，故为01</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>动规五部曲<ul><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例实验</li></ul></li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>二维实现<ul><li>二维dp数组:dp[i][j]，其中i代表 0-i的物品中选取，j代表此时的最大容量，dp[i][j]则代表此情况下包的最大价值</li><li>递推公式：要是能放下，则<br> <code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i])</code><br> 放不下则<code>dp[i][j] = dp[i-1][j]</code></li><li>初始化：画二维表来理解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; i &lt;= target; i++)&#123;<br><span class="hljs-comment">//从背包此时最大尺寸大于等于第一个背包的重量起，</span><br><span class="hljs-comment">//依次向后填充，填充到背包空间最大的情况</span><br>dp[<span class="hljs-number">0</span>][i] = nums[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li><li>遍历顺序无所谓，因为每次的取值都来自于左上方</li></ul></li><li>一维实现<ul><li>一维数组省去了i,直接就是dp[j]，j仍然代表此时最大容量</li><li>递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></li><li>初始化：如果物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了，便于后续取最大值进行覆盖</li><li><strong>遍历顺序</strong>：必须逆序，不然会出现物品多次使用的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br><span class="hljs-comment">//此情况不放物品就是dp[j]，放了就是 dp[j - weight[i]] + value[i]</span><br><span class="hljs-comment">//就是之前二维数组不放物品的拷贝：之前二维数组不放物品的为dp[i-1][j]</span><br>    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>分割等和子集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-comment">// 背包的体积为sum / 2</span><br><span class="hljs-comment">// 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</span><br><span class="hljs-comment">// 背包如果正好装满，说明找到了总和为 sum / 2 的子集。</span><br><span class="hljs-comment">// 背包中每一个元素是不可重复放入。</span><br><span class="hljs-comment">// 为什么可以用背包问题来判断呢？背包问题不是求包里能放的最大价值吗？</span><br><span class="hljs-comment">// 因为此题的物品价值 == 物品重量，所以无论你怎么放，放到最好的情况就是物品价值为sum/2，如果有这个情况那么true，否则false</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//sum/2有小数，不可能由整数构成</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][target+<span class="hljs-number">1</span>]; <span class="hljs-comment">//i代表从0-i号物品中取，j代表此时最大剩余量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; i &lt;= target; i++)&#123;<br>            <span class="hljs-comment">//从背包此时最大尺寸大于等于第一个背包的重量起，依次向后填充，填充到背包空间最大的情况</span><br>            dp[<span class="hljs-number">0</span>][i] = nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i])&#123;<span class="hljs-comment">//能放下</span><br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-nums[i]] + nums[i]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i][target] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最后一块石头的重量Ⅱ</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-comment">//转换为动态规划</span><br>        <span class="hljs-comment">//理解题意，关键在于一堆重量为a的石头和一堆重量为b的石头碰撞后会剩下|a-b|的石头</span><br>        <span class="hljs-comment">//所以此时转换为01背包问题，将给定的石头分为两堆最接近的大小即可</span><br>        <span class="hljs-comment">//即给定一个承重sum/2的背包，最大的放置重量为多少</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stone:stones)&#123;<br>            sum += stone;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stones[i]; j--)&#123;<br>                <span class="hljs-comment">//此时是stones[i]</span><br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM类加载</title>
    <link href="/2023/10/12/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/10/12/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="类字节码"><a href="#类字节码" class="headerlink" title="类字节码"></a>类字节码</h3><h4 id="多语言编译为字节码在JVM运行"><a href="#多语言编译为字节码在JVM运行" class="headerlink" title="多语言编译为字节码在JVM运行"></a>多语言编译为字节码在JVM运行</h4><ul><li>为什么需要字节码：<ul><li>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。</li></ul></li><li>为什么jvm不能直接运行java代码：<ul><li>这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的</li><li>所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。<br><img src="/../img/java%E5%9C%A8jvm%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></li></ul></li></ul><h4 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h4><ul><li>编译后形成的class到底是个啥<ul><li>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。</li><li>jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</li></ul></li><li>Class文件结构属性<br>  <img src="/../img/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%B1%9E%E6%80%A7.png"></li></ul><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><blockquote><p>类的生命周期包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段<br><img src="/../img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p></blockquote><ul><li><strong>加载: 查找并加载类的二进制数据</strong><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。<blockquote><p>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></blockquote></li><li>加载方式<ul><li>本地系统直接加载</li><li>网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul></li><li><strong>验证: 确保被加载的类的正确性</strong><ul><li>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:<ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，如是否以<code>0xCAFEBABE</code>开头<ul><li>字节码文件魔数0xCAFEBABE，每一个java字节码文件(.class)都是以相同的4字节内容开始的——十六进制的CAFEBABE，用来判断是否是java字节码文件（文件名后缀+魔数等）</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求，例如: 这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行</li></ul></li></ul></li><li><strong>准备: 为类的静态变量分配内存，并将其初始化为默认值</strong><ul><li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong><ul><li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。</li></ul></li></ul></li><li><strong>解析: 把类中的符号引用转换为直接引用</strong><ul><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</li><li>符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul></li><li><strong>初始化：为类的静态变量赋予正确的初始值</strong><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li><li><strong>初始化步骤</strong><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li><strong>类初始化时间</strong><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul></li></ul></li><li><strong>使用</strong><ul><li>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</li></ul></li><li><strong>卸载</strong><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul></li></ul><h4 id="类加载器、JVM类加载机制"><a href="#类加载器、JVM类加载机制" class="headerlink" title="类加载器、JVM类加载机制"></a>类加载器、JVM类加载机制</h4><ul><li><p>类加载器的层次<br><img src="/../img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1.png"> </p></li><li><p>启动类加载器（Bootstrap ClassLoader）：</p><ul><li>负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><p>扩展类加载器（Extension ClassLoader）：</p><ul><li>该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li></ul></li><li><p>应用程序类加载器（Application ClassLoader）：</p><ul><li>该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><p>类的加载</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>JVM类加载机制</p><ul><li><code>全盘负责</code><ul><li>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul></li><li><code>父类委托</code><ul><li>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li></ul></li><li><code>缓存机制</code><ul><li>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</li><li><strong>这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</strong></li></ul></li><li><code>双亲委派机制</code><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上</li><li>因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul></li><li><strong>双亲委派优势</strong><ul><li>系统类防止内存中出现多份同样的字节码，即<strong>避免重复加载</strong></li><li>保证Java程序安全稳定运行，即<strong>避免篡改核心类</strong></li><li>例如，有一个你写了一个Object类，放在ClassPath下去给应用程序加载器加载，此时应用程序加载器会让一层一层往上传递信息，如果父类有Object类，则会加载父类的Object，而不会加载子类的。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring回顾</title>
    <link href="/2023/10/11/Spring%E5%9B%9E%E9%A1%BE/"/>
    <url>/2023/10/11/Spring%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<hr><ul><li>Bean的作用域<ul><li>单例模式<ul><li>只能有一个实例</li></ul></li><li>原型模式<ul><li>能有多个实例，可用来代替new</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-网络层</title>
    <link href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><ul><li>网络层的作用：<ul><li>网络层的主要任务就是<strong>将分组从源主机经过多个网络和多段链路传输到目的主机</strong>，可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。<ul><li>分组转发：根据转发表来确定向自己的哪个接口进行转发（转发表来自路由表）</li><li>路由选择：路由表来自<strong>路由选择协议</strong></li></ul></li></ul></li><li>网络层向上提供的两种服务：<ul><li><p>面向连接的虚电路服务<br><img src="/../img/%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1.png"> </p><ul><li>核心思想：<strong>可靠通信应由网络自身来保证</strong></li><li>必须首<strong>先建立网络层连接</strong>，保证通信双方所需的一切资源</li><li>通信双方沿着<strong>已经建立的虚电路</strong>发送分组</li><li>通信结束后，需要<strong>释放</strong>之前建立的虚电路</li><li>类似于在双方的网络层之间添加了一条“电话线”，不过是通过链路，路由器来模拟的。</li><li>表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li></ul></li><li><p>无连接的数据报服务<br><img src="/../img/%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png"> </p><ul><li>核心思想：<strong>可靠通信应由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li>每个分组可以走<strong>不同的路径</strong>，因此，每个分组的首部<strong>必须携带目的主机的完整地址</strong></li><li>通信结束后，<strong>没有需要释放的连接</strong></li></ul></li></ul></li></ul><h3 id="网际协议（IP）"><a href="#网际协议（IP）" class="headerlink" title="网际协议（IP）"></a>网际协议（IP）</h3><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>为什么要有IP以及其作用是什么？<ul><li>为什么?<ul><li>网络互联时<strong>结构各不相同</strong>，要将众多的异构型网络都互联，并且要让其可以进行<strong>互相通信</strong>，则会面临许多需要解决的问题：如网络接入机制，差错恢复方法，寻址方案等</li></ul></li><li>作用：<br><img src="/../img/ip%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8.png"><ul><li>IP协议使得网络层可以<strong>屏蔽底层细节</strong>而专注网络层的数据转发  </li><li>当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们<strong>看不见互连的各网络的具体异构细节</strong>。</li></ul></li></ul></li></ul><h4 id="IPv4地址及其编制方法"><a href="#IPv4地址及其编制方法" class="headerlink" title="IPv4地址及其编制方法"></a>IPv4地址及其编制方法</h4><ul><li>IPv4地址概述<ul><li>IPv4地址是给因特网（Internet）上的<strong>每一个主机（或路由器）的每一个接口分配的</strong>一个在<strong>全世界范围内唯一</strong>的32比特的标识符。</li></ul></li><li>IPv4表示方法<ul><li>由于IPv4地址由32比特构成，不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</li></ul></li><li>IPv4地址的分类编址方法<ul><li>32比特的IPv4地址分为：<strong>网络号</strong> + <strong>主机号</strong></li><li>网络号<ul><li>标志主机（或路由器）的接口所<strong>连接到的网络</strong></li><li>同一个网络中，<strong>不同主机（或路由器）的接口</strong>的IPv4地址的<strong>网络号必须相同</strong>，表示它们属于同一个网络。</li></ul></li><li>主机号<ul><li>标识主机（或路由器）的接口号</li><li><strong>同一个网络</strong>中，<strong>不同</strong>主机（或路由器）的接口的IPv4地址的主机号必须各不相同，以便<strong>区分各主机（或路由器）的接口</strong>。</li></ul></li><li>分类：<br><img src="/../img/IPv4%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png"><ul><li>分为A,B,C,D,E，差异见图</li><li>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</li><li>主机号为 <strong>“全0”</strong> 的地址是<strong>自身的网络地址</strong>（标识本网络），不能分配给主机（或路由器）的各接口。</li><li>主机号为 <strong>“全1”</strong>的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</li><li><img src="/../img/A%E7%B1%BB%E5%9C%B0%E5%9D%80.png"></li><li><img src="/../img/B%E7%B1%BB%E5%9C%B0%E5%9D%80.png"></li><li><img src="/../img/C%E7%B1%BB%E7%BD%91%E7%BB%9C.png"></li></ul></li><li><img src="/../img/%E5%90%84%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%AF%B9%E6%AF%94.png"></li></ul></li></ul><h4 id="Ipv4地址划分子网编址方法"><a href="#Ipv4地址划分子网编址方法" class="headerlink" title="Ipv4地址划分子网编址方法"></a>Ipv4地址划分子网编址方法</h4><ul><li>为什么？<ul><li>随着更多的中小网络加入因特网，<strong>IPv4分类编址方法</strong>不够灵活、容易造成<strong>大量IPv4地址资源浪费</strong>的缺点就暴露出来了。</li><li>例如一个只有几个接口的网络申请一个A类地址，一个A类地址可以包含数千万接口，但只使用了几个，造成大量浪费。<br><img src="/../img/%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E6%B5%AA%E8%B4%B9.png"></li></ul></li><li>子网<ul><li>子网就是前几位都相同，然后中间使用几位来划分子网，然后后几位再分配给设备接口。</li><li>如145.13.<strong>0</strong>.20和145.13.<strong>1</strong>.20，两者都是网络 145.13 以及用户接口 20，但是是不同子网 0,1，<strong>网络号+子网号+用户号</strong></li><li>子网地址其实属于网络地址</li></ul></li><li>子网掩码<ul><li>产生原因<ul><li>我们如何从网络地址中区分出子网地址在哪里？又是多少位呢？</li></ul></li><li>作用<ul><li><strong>子网掩码</strong>可以表明分类IPv4地址的主机号部分<strong>被借用了几个比特</strong>作为子网号。</li></ul></li><li>与IPv4地址类似，子网掩码也是由32比特构成的。<ul><li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li><li>之后的多个连续的比特0对应IPv4地址中的主机号。</li></ul></li><li>子网计算：<ul><li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，就可得到该IPv4地址所在子网的网络地址。<br><img src="/../img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BD%91%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80.png"><br><img src="/../img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%BE%8B%E9%A2%98.png"></li></ul></li></ul></li></ul><h4 id="Ipv4无分类编址方法"><a href="#Ipv4无分类编址方法" class="headerlink" title="Ipv4无分类编址方法"></a>Ipv4无分类编址方法</h4><ul><li>起因：<ul><li>IPv4地址的划分子网编址方法在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网(𝟐^(𝟐𝟒−𝟑)&#x3D;𝟐𝟎𝟗𝟕𝟏𝟓𝟐)由于其每个网络所包含的地址数量太小(𝟐^𝟖&#x3D;𝟐𝟓𝟔)，因此并没有得到充分使用，而因特网的IPv4地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li><li>为此，因特网工程任务组IETF又提出了<strong>采用无分类编址</strong>的方法，来解决IPv4地址资源紧张的问题，同时还专门成立IPv6工作组负责研究新版本的IP，以彻底解决IPv4地址耗尽问题。</li><li>1993年，因特网工程任务组IETF发布了<strong>无分类域间路由选择（Classless Inter-Domain Routing，CIDR ）</strong>的RFC文档[RFC1517~1519，RFC1520]。<ul><li>CIDR消除了传统A类、B类和C类地址以及划分子网的概念。</li><li>CIDR可以更加有效地分配IPv4地址资源，并且可以在IPv6使用之前允许因特网的规模继续增长。</li></ul></li></ul></li><li>构成<ul><li>无分类编址方法使用的<strong>地址掩码</strong>与划分子网使用的<strong>子网掩码</strong>类似，由32比特构成。<ul><li>左起连续比特1为对应的网络前缀</li><li>之后的连续比特0为对应的主机号<br><img src="/../img/%E6%97%A0%E5%88%86%E7%B1%BB%E6%8E%A9%E7%A0%81%E7%A4%BA%E4%BE%8B.png"></li></ul></li><li>为了简便起见，<strong>可以不明确给出配套的地址掩码的点分十进制形式</strong>，而是在无分类编址的IPv4地址后面<strong>加上斜线“&#x2F;”</strong>，在斜线之后写上网络前缀所占的比特数量（也就是地址掩码中左起连续比特1的数量），这种记法称为<strong>斜线记法</strong>。如：<strong>128.14.35.7 &#x2F; 20</strong>，则标识网络前缀是前20比特，主机号是32-20 &#x3D; 12比特</li></ul></li><li>好处<ul><li>使用无分类编址方法，可以根据客户的<strong>需要分配适当大小的CIDR地址块</strong>，因此可以更加有效地分配IPv4的地址空间。（因为主机号确定了用户数量，根据自定义的地址掩码，也可以操作主机号大小）</li><li>使用无分类编址方法的另一个好处是<strong>路由聚合</strong>（也称为构造超网）。 <ul><li>路由聚合就是：找到最大前缀<br><img src="/../img/%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88.png"></li></ul></li></ul></li></ul><h4 id="IPv4地址与MAC地址"><a href="#IPv4地址与MAC地址" class="headerlink" title="IPv4地址与MAC地址"></a>IPv4地址与MAC地址</h4><ul><li><p>IPv4地址与MAC地址的封装位置<br><img src="/../img/Ip%E5%9C%B0%E5%9D%80%E4%B8%8Emac%E5%9C%B0%E5%9D%80%E7%9A%84%E5%B0%81%E8%A3%85.png"></p></li><li><p>数据报传送过程中IPv4地址与MAC地址的变化情况<br>  <img src="/../img/%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E9%80%81ipmac%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png"></p><ul><li>在数据报的传送过程中，数据报的<strong>源IP地址和目的IP地址保持不变</strong>。</li><li>在数据报的传送过程中，数据报的<strong>源MAC地址和目的MAC地址逐链路（或逐网络）改变</strong>。</li></ul></li><li><p>IPv4地址与MAC地址的关系</p><ul><li>如果仅使用MAC地址进行通信，则会出现以下主要问题：<ul><li>每台<strong>路由器的路由表</strong>中就必须记录因特网上<strong>所有</strong>主机和路由器各接口的MAC地址。</li><li>手工配置表几乎不可能完成，路由表中<strong>海量的MAC地址信息会严重占用通信资源</strong>。</li><li>查找转发表也会带来极大的时延。</li></ul></li><li>因特网的网际层使用<strong>IP地址进行寻址</strong>，就可使因特网中各路由器的路由表中的路由记录的数量大大减少，因为<strong>只需记录部分网络的网络地址</strong>，而不是记录每个网络中各通信设备的各接口的MAC地址。<ul><li>路由器收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的<strong>路由表进行查表转发</strong>。</li><li>查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但<strong>无法指明该IP地址所对应的MAC地址</strong>。</li><li>根据地址解析协议ARP来解决</li></ul></li></ul></li></ul><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><ul><li>地址解析协议ARP<ul><li>根据IP地址获取目标MAC地址</li></ul></li><li>过程<br>  <img src="/../img/arp%E5%8D%8F%E8%AE%AE%E8%BF%87%E7%A8%8B.png"><ul><li>如果a要发送数据报给b<ul><li>a会知道b的ip地址，但是不知道b的mac地址（在自身的arp高速缓存表中查找不到），在数据链路层封装mac帧时会无法填写目的mac地址</li><li>a会向网络发起广播（我是a，我的ip地址是ip-a，我的mac地址是mac-a，我想知道ip-b的mac地址）</li><li>其他设备收到广播后会进行解析，如果与广播中请求的ip地址符合则会接收并且返回，否则不予理会。</li><li>b会接收报文，将a的ip地址以及mac地址存到自己的arp告诉缓存表，并且给a发送arp相应，告知其自己的mac地址</li></ul></li><li>arp包含字段：IP地址、MAC地址以及类型（动态，静态）<ul><li>静态一般是手工配置</li><li>动态一般有生命周期（2分钟）<ul><li>因为ip地址和mac地址不总是一成不变，更换网卡，mac地址就改变了</li></ul></li></ul></li></ul></li></ul><h4 id="IP数据报的发送与转发"><a href="#IP数据报的发送与转发" class="headerlink" title="IP数据报的发送与转发"></a>IP数据报的发送与转发</h4><ul><li>流程<ul><li>主机发送IP数据报<ul><li>在同一个网络中就直接交付，不同网络中间接交付</li><li>源主机如何判断出目的主机是否与自己在同一个网络中？<ul><li>c转发给不同网络的f，c知道f的ip地址，根据分类掩码，将自己的网络前缀和f的对比，查看是否相同（是否属于同一个网络）</li></ul></li><li>交给哪个路由器转发呢？<ul><li>实际上，用户为了让本网络中的主机，能和其它网络中的主机进行通信，就必须给其<strong>指定本网络中的一个路由器</strong>，由该路由器帮忙进行转发，所指定的路由器，也被称为默认网关（就是一个保安）</li><li>这样，当本网络中的主机要和其它主机进行通信时，会将IP数据报传输给默认网关。由默认网关帮主机将IP数据报转发出去。</li></ul></li></ul></li><li>路由器转发IP数据报<ul><li>那么路由器收到IP数据报之后又是如何转发的呢？<ul><li>检查IP数据报首部是否出错：若出错，丢弃并告诉源主机，<strong>没错就转发</strong>。</li><li>根据IP数据报的目的地址在<strong>路由表中找匹配的记录</strong>，找到就转发给下一个该转发的，找不到就丢弃该IP数据报并告诉主机你这个我转发不了。</li><li>路由器不会转发广播</li></ul></li></ul></li></ul></li></ul><h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h4><p><img src="/../img/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><ol><li>**版本(4bit)**：指明了IP协议的版本，IPv4还是IPv6；通信双方的版本要一致</li><li>**首部长度(4bit)**：指明了IP数据报头部的长度，以4字节为单位（和TCP数据报中的数据偏移字段类似）</li><li>**可选字段(1~40字节)**：可增加一些拓展功能，但很少使用，该字段的拓展直接影响了首部长度字段</li><li><strong>填充字段</strong>：IP数据报头部的长度要求是4的整数倍，因此需要该字段填充补0，使头部满足要求</li><li>**区分服务(1字节)**：一般不使用，用于提供不同等级的服务质量</li><li>**总长度(2字节)**：指明了整个IP数据报的长度,以字节为单位，首部长度换算成字节后，总长度 - 首部长度 &#x3D; 数据载荷的长度</li><li><strong>标识、标志、片偏移</strong>：这三个字段共同说明了IP的分片情况<ul><li>标识：16bit，就是一个数字；属于同一个IP数据报的子分片有相同的标识；IP协议栈维持一个计数器，每产生一个数据报，就将标识值加1，然后赋值给标识字段</li><li>标志：3bit，分别是DF、MF、保留位<ul><li>DF：DF&#x3D;1表示不允许分片，DF&#x3D;0表示允许分片</li><li>MF：MF&#x3D;1表示后边还有分片，MF&#x3D;0表示后边没有分片，这就是最后一个分片</li><li>保留位：暂不使用，为0</li><li>片偏移：13bit，以8字节为单位，这也就要求：如果要分片，只要不是最后一个IP片，其数据载荷长度都必须是8的倍数；该字段指明了分片数据报载荷部分首字节相对于其原始数据报偏移了多少字节，如第一个IP分片的数据报为原始数据载荷的0~800，那该IP分片的片偏移为0&#x2F;8&#x3D;0；第二个分片的片偏移就是800&#x2F;8&#x3D;100；</li></ul></li></ul></li><li>**生存时间TTL(Time To Live)(8bit)**：指明了IP数据报的生存时间还有多少<ul><li>当前是以跳数为单位，路由器转发IP数据报时，先将该字段减1，若不为0则转发；若为0，则表示其生存时间无了，也就是该数据包失效了，就不转发</li><li>主要是为了避免发生路由环路时，IP数据报在环路内永久兜圈</li></ul></li><li>**协议字段(8bit)**：指明了IP数据包的数据载荷部分包装的是何种协议数据单元PDU，该字段是网络层与运输层之间的接口，通过该字段的标识，可以将IP数据报正确的交给运输层的某个协议模块处理</li><li>**首部检验和(16bit)**：用于在IP报的转发、发送过程中校验IP头部。因为IP头部是动态变化的，所以该校验和也是动态变化的。这一点与TCP的校验和不同（TCP校验的是头部和数据载荷也即整个TCP报文段，且转发途中不会动态变化）</li><li>**源IP地址和目的IP地址(各占32bit，4字节)**：用于标识发送方的IP地址和接收方的IP地址，可以说是最重要的字段存在了</li></ol><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><ul><li>静态路由<ul><li>静态路由配置是指用户或者网络运维人员使用路由器的相关命令给路由器<strong>人工配置路由表</strong></li><li>人工配置方式<strong>简单、开销小</strong>、但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>，一般只在小规模网络中采用。</li></ul></li><li>默认路由<ul><li>当路由器在路由表中找不到目的地址的具体路由时，会才有用默认路由</li></ul></li><li>静态路由配置可能存在的问题<ul><li>路由条目<strong>配置错误</strong>，可能导致出现<strong>路由环路</strong></li><li>聚合路由条目时可能引入不存在的网络</li></ul></li></ul><h3 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h3><h4 id="路由选择分类"><a href="#路由选择分类" class="headerlink" title="路由选择分类"></a>路由选择分类</h4><ul><li>静态路由选择<ul><li>简单，开销小，但不能及时适应网络状态的变化</li><li>一般只能在小规模网络中使用</li></ul></li><li>动态路由选择<ul><li>动态路由：路由器通过路由选择协议<strong>自动获取</strong>路由信息</li><li>比较复杂，开销大，但是能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ul></li><li>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：<ul><li>自适应：因特网采用动态路由选择，能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li><li>分层次：<ul><li>将整个因特网划分为许多较小的<strong>自治系统（Autonomous System，AS）</strong>。</li><li>在自治系统内部和外部采用<strong>不同类别</strong>的路由选择协议，分别进行路由选择。<br><img src="/../img/%E5%88%86%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png"></li></ul></li></ul></li></ul><h4 id="路由信息协议"><a href="#路由信息协议" class="headerlink" title="路由信息协议"></a>路由信息协议</h4><ul><li>相关概念<ul><li>路由信息协议（Routing Information Protocol)是内部网关协议最先得到广泛使用的协议</li><li>RIP要求自治系统AS内的每一个路由器，都要维护从它<strong>自己到AS内其他每一个网络的距离记录</strong>。这是一组距离，称为距离向量（Distance-Vector，D-V）。</li><li>RIP使用跳数（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。<ul><li>RIP将路由器到直连网络的距离定义为1。</li><li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>RIP允许一条路径最多只能包含15个路由器，距离等于16时相当于不可达。因此RIP只适用于小型互联网。</li></ul></li></ul></li><li>工作流程<ol><li>路由器刚开始工作时，只知道自己到直连网络的RIP距离为1。</li><li>每个路由器仅和相邻路由器周期性的交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本自治系统AS内各网络的最短距离和下一跳路由器，称为收敛。</li></ol></li><li>问题<ul><li>坏消息传播得慢</li><li>当线路故障的消息没有及时更新的时候，一些路由器会被另一些可达的未更新的路由器所误导，导致故障信息传播的十分缓慢。</li><li>优化<ul><li>限制距离</li><li>即时更新，而不是周期性更新</li></ul></li></ul></li></ul><h4 id="开放最短路径优先协议"><a href="#开放最短路径优先协议" class="headerlink" title="开放最短路径优先协议"></a>开放最短路径优先协议</h4><ul><li>概念<ul><li>开放最短路径优先（Open Shortest Path First，OSPF）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的。</li><li>使用了迪杰斯特拉的最短路径算法</li><li>通过相邻路由器之间的互相问候分组，来建立和维护邻居关系</li></ul></li><li>工作过程<ol><li>使用问候发现和维护邻居路由器的可达性</li><li>展示自己的数据给邻居</li><li>互相请求需要的数据</li><li>更新数据（洪泛法）类似广播</li></ol></li><li>优化<ul><li>为了使OSPF协议能够用于规模很大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围，称为区域（area）。</li><li>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统AS，这样就减少了整个网络上的通信量。<br><img src="/../img/ospf%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F.png"></li></ul></li></ul><h4 id="边界网关协议"><a href="#边界网关协议" class="headerlink" title="边界网关协议"></a>边界网关协议</h4><ul><li>概念<ul><li>边界网关协议（Border Gateway Protocol，BGP）属于外部网关协议EGP这个类别，用于<strong>自治系统AS之间</strong>的路由选择协议。</li></ul></li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由。</li></ul><h4 id="路由器的基本工作原理"><a href="#路由器的基本工作原理" class="headerlink" title="路由器的基本工作原理"></a>路由器的基本工作原理</h4><ul><li>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是<strong>转发分组</strong>。<br><img src="/../img/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></li></ul><h3 id="网际控制报文协议"><a href="#网际控制报文协议" class="headerlink" title="网际控制报文协议"></a>网际控制报文协议</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>为了<strong>更有效地转发IP数据报</strong>以及提高IP数据报交付成功的机会，TCP&#x2F;IP体系结构的网际层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）[RFC 792]。</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li><li>ICMP报文被封装在IP数据报中发送。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>差错报告报文</strong>：用来向主机或路由器报告差错情况</p><ul><li>终点不可达<ul><li>当路由器或主机不能交付IP数据报时，就向源点发送重点不可达报文。</li></ul></li><li>源点抑制<ul><li>当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li></ul></li><li>超时<ul><li>收到数据报后，若TTL结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文。</li><li>在预先规定的时间内未能收到一个数据报的全部数据报分片时，也会发送超时报文</li></ul></li><li>参数问题<ul><li>路由器检测到数据报首部误码丢弃该数据报，并且发送参数问题报文</li></ul></li><li>改变路由（重定向）<ul><li>路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样<strong>可以通过更好的路由</strong>到达目的主机。</li></ul></li></ul></li><li><p><strong>询问报文</strong>：用来向主机或路由器询问情况</p><ul><li>回送请求和回答<ul><li>用来测试目的站是否可达以及了解其有关状态。</li></ul></li><li>时间戳请求和回答<ul><li>用来进行时钟同步和测量时间。</li></ul></li></ul></li></ul><h3 id="虚拟专用网和网络地址转换"><a href="#虚拟专用网和网络地址转换" class="headerlink" title="虚拟专用网和网络地址转换"></a>虚拟专用网和网络地址转换</h3><h4 id="虚拟专用网"><a href="#虚拟专用网" class="headerlink" title="虚拟专用网"></a>虚拟专用网</h4><ul><li>虚拟专用网（Vitual Private Network）：<ul><li>我们如何让两个专用网络进行通信呢？<ul><li>直接花钱连线</li><li>使用因特网作为载体</li></ul></li><li>利用公用的因特网作文本机构和专用网之间的通信载体。</li></ul></li><li>公用网和专用网的区别是什么呢？<ul><li>公用网的ip全是公开的，专用网为了安全考虑，ip都是不公开的</li></ul></li><li>如何实现<ul><li>我们需要在两个专用网中分别使用一个路由器，路由器可以连接公网</li><li>将专网的内部ip加密封装到数据报之中，通过路由器转发到公网</li><li>转发的地址是目的专网的路由器的公网地址</li><li>目的专网收到之后，进行解析即可</li></ul></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><ul><li><p>为什么需要？</p><ul><li>主要解决IPv4地址紧缺的问题，通过将<strong>一个公网IP地址和多个私网IP</strong>相对应，从而解决IP地址不够用的情况</li></ul></li><li><p>如何实现</p><ul><li>使用NAT软件，并且至少有一个有效的全球地址ip</li><li>当私网通过NAT时，会将其转换为公网在因特网传输<br><img src="/../img/NAT%E8%BF%87%E7%A8%8B.png"></li></ul></li><li><p>优化:网络地址与端口号转换方法</p><ul><li>由于目前绝大多数基于TCP&#x2F;IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，为了更加有效地利用NAT路由器中的全球IP地址，现在常将NAT转换和运输层端口号结合使用。<ul><li>这样就可以使内部专用网中使用专用地址的大量主机，共用NAT路由器上的1个全球IP地址，因而可以同时与因特网中的不同主机进行通信。<br><img src="/../img/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BD%AC%E6%8D%A2.png"></li></ul></li></ul></li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>多播（Multicast，也称为组播）是一种实现“一对多”通信的技术，与传统单播“一对一”通信相比，多播可以极大地节省网络资源。</li><li>在因特网上进行的多播，称为IP多播。<br><img src="/../img/ip%E5%A4%9A%E6%92%AD.png"></li><li>可以减少网络中资源的消耗</li></ul><h4 id="IP多播地址和多播组"><a href="#IP多播地址和多播组" class="headerlink" title="IP多播地址和多播组"></a>IP多播地址和多播组</h4><ul><li>在IPv4中，<strong>D类地址</strong>被作为多播地址。</li><li><strong>多播地址只能用作目的地址</strong>，而不能用作源地址。</li><li>一个多播地址确定一个多播组</li></ul><h4 id="局域网上进行硬件多播"><a href="#局域网上进行硬件多播" class="headerlink" title="局域网上进行硬件多播"></a>局域网上进行硬件多播</h4><ul><li>硬件多播其实就是多播MAC地址，只需要把IPv4的多播地址转换为MAC地址即可</li><li>由于IP多播地址可变化的28比特的前5个比特无法映射到MAC多播地址，<strong>这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的</strong>。<ul><li>所以在链路层判断MAC地址正确后，还会将数据上传至网络层，进行IP地址的判断，从而确定正确的传输</li></ul></li></ul><h4 id="因特网上进行IP多播需要的两种协议"><a href="#因特网上进行IP多播需要的两种协议" class="headerlink" title="因特网上进行IP多播需要的两种协议"></a>因特网上进行IP多播需要的两种协议</h4><ul><li>引出<ul><li>要在因特网上进行IP多播，<strong>要考虑IP多播数据报经过多个多播路由器进行转发的问题</strong>。<ul><li>多播路由器必须根据IP多播数据报首部中的IP多播地址，将其转发到有该多播组成员的局域网。</li></ul></li><li>那么路由器如何知道自己的接口所在局域网有哪些多播成员呢？<ul><li>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。</li><li>需要使用多播路由选择协议来解决</li></ul></li></ul></li><li>多播路由选择协议<ul><li>过程<ul><li>主要任务是：在多播路由器之间为每个多播组建立一个多播转发树</li><li>多播转发树连接多播源和所有拥有该多播组成员的路由器。</li><li>IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器。</li><li>之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员。</li></ul></li></ul></li><li>网际组管理协议（IGMP）：维护多播组与其成员关系<ul><li>报文类型<ul><li>成员报告报文</li><li>成员查询报文</li><li>离开组报文</li></ul></li><li>加入多播组<ul><li>发送成员报告报文申请加入</li></ul></li><li>监听多播组成员变化<ul><li>多播路由器定时发送成员查询报文（广播）</li><li>成功接收到报文的组员会延时随机时间后发送请求（成员报告报文），</li><li>如果该组有一个成员（延时最短的）已经发送报告报文了，那么该组其他的成员就取消发送，这样可以减少资源浪费</li><li>长时间未收到响应，会将该组从多播组中删除</li></ul></li><li>退出多播组<ul><li>当主机要退出某个多播组时，可<strong>主动发送</strong>一个离开组报文而不必等待多播路由器的查询。</li><li>这样可使多播路由器能够更快地发现某个组有成员离开。</li></ul></li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>背景<ul><li>IPv4不够用</li></ul></li><li>变化<ul><li>IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。</li><li>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</li><li>更大的地址空间</li><li>扩展的地址层次结构，灵活的首部等</li><li>IPv6 的地址主要有以下类型地址：<ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul></li></ul></li></ul><h4 id="IPv6数据报的首部"><a href="#IPv6数据报的首部" class="headerlink" title="IPv6数据报的首部"></a>IPv6数据报的首部</h4><p><img src="/../img/ipv4%E5%AF%B9%E6%AF%94ipv6.png"></p><ul><li>取消了首部校验和字段。</li><li>取消了分片&#x2F;重新组装相关字段。</li><li>取消选项字段。</li></ul><h4 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h4><ul><li>使用双协议栈<ul><li>使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li><li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li><li>根据需要进行转换</li><li>会漏一些信息</li></ul></li><li>使用隧道技术<ul><li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li><li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾收集与内存分配</title>
    <link href="/2023/10/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2023/10/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><ul><li>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</li><li>垃圾收集主要针对<strong>堆和方法区</strong>进行，程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，只存在于线程的生命周期内，线程结束后就会消失，因此不需要进行垃圾回收</li></ul><h4 id="如何判断可以进行垃圾回收"><a href="#如何判断可以进行垃圾回收" class="headerlink" title="如何判断可以进行垃圾回收"></a>如何判断可以进行垃圾回收</h4><ul><li>引用计数算法 <ul><li>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。<ul><li>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；</li><li>当引用失效时，引用计数器就减 1；</li><li>当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</li></ul></li><li>优点：<ul><li>回收没有延迟性，无需等到内存不够时才开始回收</li></ul></li><li>缺点：<ul><li>每次对象被引用时，都需要更新计数器，有时间开销</li><li>浪费cpu资源，内存够用时，计数器统计仍在进行</li><li><strong>无法解决循环引用问题，会引发内存泄漏</strong>（即互相引用的对象永远也无法被回收）</li></ul></li></ul></li><li>可达性分析算法<ul><li>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</li><li>GC Roots 对象：<ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li><li>GC Roots <strong>是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</li></ul></li><li>工作原理：<ul><li>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象<ul><li>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li></ul></li></ul></li></ul></li><li>finalization<ul><li>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</li><li>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</li><li><strong>finalize()只能被调用一次</strong></li></ul></li><li>引用分析<ul><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致内存泄漏<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//使用 new 一个新对象的方式来创建强引用</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>配合引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li></ul></li><li><p>弱引用：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li></ul></li><li><p>虚引用：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，监测对象是否存活</li></ul></li><li><p>终结器引用（finalization）</p></li><li><p>引用队列作用：</p></li></ul></li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ol><li>标记-清除法<ul><li>先标记，再清除 </li><li><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></li><li><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li><li>缺点：<ul><li>因为没有整理，所以会产生不连续的内存碎片</li></ul></li></ul></li><li>标记-整理法<ul><li>与标记-清除法一样，不过清除之后将存活对象都移动到了内存的一端，解决了内存碎片问题</li><li>缺点：<ul><li>需要遍历移动对象，处理效率低</li></ul></li></ul></li><li>标记-复制法<ul><li>前提：每次新生代都会回收大量的垃圾（90%？） </li><li>将内存空间划分成两个部分，一个from，一个to</li><li>当回收垃圾时，会将非垃圾的对象复制到另一块区域（将from区非垃圾复制到to区），并在复制的时候保证了内存的连续性。</li><li>清空from区，将from指针和to指针互换（即from又指向了非垃圾对象区，to又指向了空区）<br><img src="/../img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"> </li><li>缺点：<ul><li>需要占用双倍内存</li></ul></li></ul></li></ol><h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><ul><li><strong>新生代</strong><ul><li>是用来<strong>存放新生的对象</strong>。一般占据堆的1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾 回收。新生代又分为Eden 区、ServivorFrom、 ServivorTo 3个区。</li></ul></li><li><strong>老年代</strong><ul><li>主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以MajorGC（fullGC）不会频繁执行。在进行MajorGC 前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。<br><img src="/../img/%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E7%94%9F%E4%BB%A3.png"></li></ul></li><li><strong>分代回收过程</strong>：<ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc</li></ul></li><li><strong>永久代</strong><ul><li>指内存的永久保存区域，主要存放Class 和Meta (元数据)的信息,Class在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class 的增多而胀满，最终抛出OOM异常。</li><li>在Java8 中，永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代。</li><li>元空间的本质和永久代类似，元空间与永久代之间最大的区别在于:<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，<strong>元空间的大小仅受本地内存限制</strong>。</li><li>类的元数据放入native memory,字符串池和类的静态变量放入java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</li></ul></li><li><strong>回收策略</strong><ul><li>部分收集：不是进行整个java堆的垃圾收集<ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集（很多时候不区分Full GC和Major GC）</li></ul></li><li>整堆收集：<ul><li>Full GC</li></ul></li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器<br><img src="/../img/serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>又叫串行收集器，以串行方式执行</li><li>是单线程收集器，只会使用一个线程进行垃圾收集</li><li>简单高效</li></ul></li><li><p>ParNew收集器<br><img src="/../img/parnew%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>是Serial收集器的多线程版本</li><li>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</li><li>默认开启线程数量与cpu数量相同</li><li>单核下性能绝不会比serial收集器好</li></ul></li><li><p>Parallel Scavenge收集器</p><ul><li>与ParNew一样是多线程收集器，目标是尽可能缩短垃圾收集时用户线程停顿的时间，达到一个可控制的吞吐量，也被称为：吞吐量优先 收集器</li><li>这里的吞吐量指：cpu运行用户代码时间 &#x2F; 总时间</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。（当新生代空间变少，自然用于停顿标识垃圾的时间也就减少了）</li></ul></li><li><p>Serial Old收集器<br><img src="/../img/serialold%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p><ul><li>与Serial收集器对比，回收区域不同，回收方式也不同</li><li>serial收集器的老年代版本</li></ul></li><li><p>Parallel Old收集器<br><img src="/../img/parallelold%E6%94%B6%E9%9B%86%E5%99%A8.jpg">  </p><ul><li>是 Parallel Scavenge 收集器的老年代版本。</li></ul></li><li><p>CMS收集器<br><img src="/../img/cms%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</li><li>流程：<ul><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。（不影响用户线程的运行）</li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除: 不需要停顿。</li></ul></li><li>缺点；<ul><li>吞吐量低，低停顿时间是以牺牲吞吐量为代价，导致cpu利用率不高<ul><li>（为什么呢？因为其并发标记时占用了线程，使用户线程执行的时间变少了）</li></ul></li><li>无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程仍在继续而产生的垃圾，这部分垃圾只能在下一次GC才能进行回收。<ul><li>意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li></ul></li><li>使用的标记-清除算法会导致空间碎片</li></ul></li></ul></li><li><p>Garbage First收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html">G1详解</a><br><img src="/../img/g1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</li><li>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</li><li>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li><li>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</li><li>步骤<ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</li></ul></li><li>使用标记-整理算法，不会产生内存碎片</li><li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul></li><li><p>ZGC收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-zgc.html">ZGC详解</a><br><img src="/../img/zgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png">  </p><ul><li>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：<ul><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；</li><li>支持8MB~4TB级别的堆（未来支持16TB）。</li></ul></li><li>使用关键技术<ul><li>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。<ul><li>染色指针是一种将信息存储在指针中的技术</li></ul></li><li>在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。<ul><li>读屏障类似于aop的环绕方法，在事件发生的前后进行指定的操作</li></ul></li></ul></li></ul></li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul><li>分配流程<ul><li>对象一般在堆上分配</li><li>对象优先在Eden分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-链路层</title>
    <link href="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><ul><li>链路层<ul><li>它的主要功能是在物理介质上<strong>可靠地传输数据帧</strong>，并提供一些基本的<strong>错误检测</strong>和<strong>纠正机制</strong>。</li><li>它负责在物理层提供的传输介质上实现可靠的数据传输，同时进行地<strong>址解析</strong>、<strong>错误检测</strong>和<strong>流量控制</strong>等操作，以确保数据正确、高效地传输。</li></ul></li><li>与物理层的联动<ul><li>物理层和链路层共同协同工作，以实现端到端的数据传输。</li><li>物理层提供了将比特从一台计算机传输到另一台计算机的物理手段，而链路层在这些物理媒体上创建了数据帧，并确保这些数据帧能够准确无误地从一个节点传输到另一个节点。</li></ul></li><li>链路，数据链路，帧<ul><li>链路<ul><li>链路（Link）是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</li></ul></li><li>数据链路<ul><li>数据链路（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li></ul></li><li>帧<ul><li>帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。<br><img src="/../img/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%A7%E7%A4%BA%E6%84%8F.png"></li></ul></li></ul></li></ul><h3 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h3><ul><li>封装成帧和透明传输<ul><li>封装成帧<ul><li>封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加一个首部和一个尾部，使之成为帧。</li><li>帧是数据单元，那么传输的时候是以一连串的比特流进行传输，一次可能传输若干个帧，所以我们如何确定帧呢？<ul><li>我们可以在帧的首部和尾部添加标识进行定界<br><img src="/../img/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png"></li></ul></li><li>此时会面临一些问题<ul><li>当我们传输的数据里面有和定界标识符一样的数据怎么办呢？接收方如何确定该帧的界限呢？</li></ul></li><li>透明传输<ul><li>透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在一样。<ul><li>如何理解呢？<ul><li>首先，我们为什么要使用帧呢？<ul><li>前面已经说了，将数据封装成帧后，可以在链路层实现错误的检测，纠正以及地址的解析。</li></ul></li><li>但是有了帧就会出现一些负面问题，如我们上面所说的，对帧的界限识别出现差错。<ul><li>所以为了得到帧的好处消除帧的坏处，我们就要实现透明传输：实现链路层的功能，但是好像数据链路层不存在一样（消除副作用）。</li></ul></li></ul></li><li>解决帧的界限问题<ul><li>面向字节的物理链路使用字节填充的方法实现透明传输<ul><li>我们发送时对数据进行扫描，在界限符前面，以及转义符前面添加转义符。</li></ul></li><li>面向比特的物理链路使用比特填充的方法实现透明传输<ul><li>即挑选比较特别的码作为帧的界限符（如0111110），我们发送时对数据进行扫描，每5个1就在其中插入一个0，由此实现了数据区不会出现帧的界限符的情况，在接收时，我们再按照指定的方法将数据区的0删除即可还原为原数据。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/source/img/%E8%A7%A3%E5%86%B3%E5%B8%A7%E7%95%8C%E9%99%90%E9%97%AE%E9%A2%98.png"> </p><ul><li><p>差错检测</p><ul><li>误码的相关概念<ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为比特差错）。<ul><li>比特0 -&gt; 比特1，比特1 -&gt; 比特0</li></ul></li><li>使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul></li><li>如何检验呢？<ul><li>奇偶校验<ul><li>奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。</li><li>偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。</li><li>但是此方法容易出现漏检。</li></ul></li><li>循环冗余校验<ul><li>数据链路层广泛使用漏检率极低的循环冗余校验（Cyclic Redundancy Check，CRC）检错技术。<ul><li>收发双方约定好一个生成多项式G(X)。</li><li>发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码（冗余码），将冗余码添加到待发送数据的后面一起传输。</li><li>接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。</li></ul></li></ul></li></ul></li></ul></li><li><p>可靠传输</p><ul><li>可靠传输的相关概念<ul><li>使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特差错）。</li><li>出现差错之后该怎么办呢？<ul><li>数据链路层为上层提供服务有两种情况<ul><li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li><li>可靠传输服务：通过某种机制实现：发送方发送什么，接收方就接收什么。</li></ul></li></ul></li><li>传输差错<ul><li>误码</li><li>分组丢失</li><li>分组失序</li><li>分组重复</li></ul></li><li>可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。</li><li>可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求。</li></ul></li><li>可靠传输的实现<ul><li>停止-等待协议<ul><li>发送方发送数据给接收方 -&gt; 接收方进行差错检测，无差错，则接收，并且返回确认接收了该分组。如果有误码，接收方则丢弃，并且返回否认接收了该分组。</li><li>此时存在问题<ul><li>接收方若未接到数据，会进行无限制的等待<ul><li>所以在发送方添加超时计时器，每当发送一组数据后就启动计时器，长时间未返回结果，则重新发送</li></ul></li><li>传输可能出现重复，接收返回请求也可能出现错乱<ul><li>对发送方的数据分组进行编号</li><li>对接收方返回的接收或者否认进行编号<br><img src="/../img/%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png"></li></ul></li></ul></li></ul></li><li>回退N帧协议<ul><li>是对停止等待协议的优化：回退N帧协议采用流水线传输方式，并且利用发送窗口来限制发送方连续发送数据分组的数量<br><img src="/../img/%E5%9B%9E%E9%80%80n%E5%B8%A7%E4%BC%98%E5%8C%96.png">  </li><li>简单来说就是： 允许发送方连续发送多个数据包，而不需要等待每个数据包的确认。接收方使用一个窗口大小来指示可以接收的下一个期望的数据包序号。这种方法可以提高传输效率。</li><li>具体见高军老师ppt<br><img src="/../img/%E5%9B%9E%E9%80%80n%E5%B8%A7%E7%A4%BA%E6%84%8F.png"> </li><li>回退N帧协议的接收方采用累积确认方式。<ul><li>接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。</li><li>接收方何时发送累积确认分组，由具体实现决定。</li><li>确认分组ACKn表明序号为n及之前的所有数据分组都已正确接收。</li><li>优点：<ul><li>减少向网络中注入确认分组的数量。</li><li>即使确认分组丢失，也可能不必重传数据分组。</li></ul></li><li>缺点：<ul><li>不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。</li></ul></li></ul></li><li>发送窗口𝑾_𝑻的取值范围是𝟏&lt;𝑾_𝑻≤ 2的n次方 - 1 ，如果超出范围，可能会出现分清楚此时传输的比特是新传输的还是重新传输的</li></ul></li><li>选择重传协议<ul><li>是对回退N帧协议的优化</li><li>为了使发送方仅重传出现差错的数据分组，接收方不再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。<br><img src="/../img/%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F.png">  </li><li>发送窗口和接收窗口的最大值为：2的（n-1）次方，若故意取𝑾_𝑻&#x3D;𝟓，使得𝑾_𝑻+𝑾_𝑹≥𝟐^𝟑，接收方将无法分辨新旧数据分组</li></ul></li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>以太网（Ethernet）是一种计算机网络技术，用于在局域网（LAN）中传输数据。它是最常见和广泛应用的局域网技术之一。</li><li>以太网使用一种称为CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection，具有载波侦听和冲突检测的多路访问）的协议来控制多台计算机同时访问网络时的数据冲突问题。</li><li>它采用了一种总线拓扑或星型拓扑的物理结构，允许多台计算机通过共享相同的传输媒介（通常是电缆或光纤）来进行通信。</li></ul><h4 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h4><ul><li>网络适配器和MAC地址<ul><li>网络适配器<ul><li>要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），网络适配器一般简称为“网卡”。</li><li>网络适配器是计算机与网络之间的桥梁，它负责管理数据在计算机和网络之间的传输，确保网络通信的顺畅和可靠性。</li><li>作用：<ul><li>连接计算机到网络</li><li>数据封装和解封</li><li>MAC地址管理：MAC地址用于在局域网中识别计算机和其他设备。网络适配器负责管理和维护这个地址。</li><li>网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换。<ul><li>在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I&#x2F;O总线以并行传输方式进行。</li><li>网卡与外部以太网（局域网）之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以串行方式进行的。</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/../img/%E7%BD%91%E5%8D%A1%E7%9A%84%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.png"></p><ul><li>MAC地址(物理地址，硬件地址)<ul><li>作用：使信息可以被准确的发送和接收</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li><li>在每个主机发送的帧的首部中，都携带有发送主机（源主机）和接收主机（目的主机）的数据链路层地址。由于这类地址是用于媒体接入控制（Medium Access Control，MAC）的，因此被称为MAC地址<br><img src="/../img/mac%E5%9C%B0%E5%9D%80%E4%BD%9C%E7%94%A8.png"> </li><li>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。（如一个交换机有多个接口，所以可能会有多个MAC地址）</li><li>网卡从网络上每收到一个帧，就检查帧首部的目的MAC地址，进行如下的操作：<ol><li>如果目的MAC地址是广播地址（FF-FF-FF-FF-FF-FF），则接受该帧。</li><li>如果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。</li><li>如果目的MAC地址是网卡支持的多播地址，则接受该帧。</li><li>其他情况丢弃该帧</li></ol></li></ul></li><li>CSMA&#x2F;CD协议<ul><li>引出<ul><li>由于共享型以太网有着天然广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点。</li><li>当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。<br><img src="/../img/%E4%BF%A1%E5%8F%B7%E7%A2%B0%E6%92%9E.png"></li></ul></li><li>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA&#x2F;CD，它是载波监听多址接入&#x2F;碰撞检测（Carrier Sense Multiple Access Collision Detection）的英文缩写词。<ul><li>多址接入MA<ul><li>多个站点连接在一条总线上，竞争使用总线。</li></ul></li><li>载波监听CS<ul><li>每个站点在发送帧之前，先要检测一下总线上是否有其他站点在发送帧（“先听后说”）<ul><li>若检测到总线空闲96比特时间（发送96比特所耗费的时间，也称为帧间最小间隔），则发送这个帧；</li><li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。</li></ul></li></ul></li><li>碰撞检测CD<ul><li>每个正在发送帧的站点边发送边检测碰撞（“边说边听”）：<ul><li>一旦发现总线上出现碰撞，立即停止发送，退避一段随机时间后再次从载波监听开始进行发送（“一旦冲突，立即停说，等待时机，重新再说”）。</li></ul></li></ul></li></ul></li><li>共享式以太网的争用期<ul><li>站点从发送帧开始，最多经过时长𝟐𝝉 （即𝜹→𝟎）就可检测出所发送的帧是否遭遇了碰撞。</li><li>共享总线以太网的端到端往返时间𝟐𝝉被称为争用期（Contention Period）或碰撞窗口（Collision Window）</li></ul></li><li>最小帧长和最大帧长<ul><li>最小帧长<ul><li>最小帧长是指以太网数据帧（Ethernet Frame）在物理层上必须具备的最小长度。以太网的最小帧长是64字节（包括64字节的数据和4字节的帧校验序列）。</li><li>这个最小帧长度是为了确保在网络中的数据帧在传输过程中具有足够的时间，以便其他设备能够检测到帧的存在，避免碰撞和丢失数据。</li></ul></li><li>最大帧长<ul><li>最大帧长是指以太网数据帧在物理层上允许的最大长度。以太网的最大帧长是1518字节（包括数据、帧头、帧校验序列和帧间隙）。</li><li>这个最大帧长度限制是为了确保在网络中传输的数据帧不会过大，从而防止网络拥塞和数据丢失。</li></ul></li></ul></li><li>共享式以太网的退避算法<ul><li>在使用CSMA&#x2F;CD协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。</li><li>共享总线以太网中的各站点采用截断二进制指数退避（Truncated Binary Exponential Backoff）算法来选择退避的随机时间。</li></ul></li></ul></li><li>使用集线器的共享式以太网<ul><li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器（Hub）。<br><img src="/../img/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BB%A5%E5%A4%AA%E7%BD%91.png"></li></ul></li><li>物理层扩展以太网<ul><li>扩展传输距离：<ul><li>在10BASE-T星型以太网中，可使用光纤和一对光纤调制解调器来扩展站点与集线器之间的距离。<br><img src="/../img/%E5%85%89%E7%BA%A4%E6%89%A9%E5%B1%95%E8%B7%9D%E7%A6%BB.png"></li></ul></li><li>扩展覆盖范围和数量<ul><li>以太网集线器一般具有8~32个接口，如果要连接的站点数量超过了单个集线器能够提供的接口数量，就需要使用多个集线器，这样就可以连接成覆盖更大范围、连接更多站点的多级星型以太网。<br><img src="/../img/%E9%9B%86%E7%BA%BF%E5%99%A8%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E5%92%8C%E6%95%B0%E9%87%8F.png"> </li><li>碰撞域<ul><li>指的是共享同一物理网络媒介的设备集合，它们在发送数据时可能会发生碰撞<br><img src="/../img/%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E7%9A%84%E7%A2%B0%E6%92%9E%E5%9F%9F.png"> </li><li>在物理层扩展的共享式以太网仍然是一个碰撞域，不能连接太多的站点，否则可能会出现大量的碰撞，导致平均吞吐量太低。</li></ul></li></ul></li></ul></li><li>数据链路层扩展以太网</li><li>网桥<ul><li>网桥是计算机网络中的网络设备，通常用于连接两个或多个局域网（LAN）或网络段，以便在它们之间传输数据</li><li>作用：<ul><li>网桥可以识别帧的结构。</li><li>网桥可以根据帧首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃所收到的帧。<br><img src="/../img/%E7%BD%91%E6%A1%A5%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></li></ul></li><li>网桥的自学习和转发帧<ul><li>转发表是如何建立的呢？<ul><li>透明网桥（Transparent Bridge）通过自学习算法建立转发表。</li><li>透明网桥中的“透明”，是指以太网中的各站点并不知道自己所发送的帧将会经过哪些网桥的转发，最终到达目的站点。也就是说，<strong>以太网中的各网桥对于各站点而言是看不见的</strong>。</li></ul></li><li>自学习和转发流程 ：<ol><li>网桥收到帧后进行登记（即自学习），登记的内容为帧的源MAC地址和进入网桥的接口号。</li><li>网桥根据帧的目的MAC地址和网桥的转发表对帧进行转发，包含以下三种情况：<ol><li><strong>明确转发：</strong>网桥知道应当从哪个接口转发帧。</li><li><strong>盲目转发：</strong>网桥不知道应当从哪个接口转发帧，只能将其通过除进入网桥的接口外的其他所有接口转发。</li><li><strong>丢弃：</strong>网桥知道不应该转发该帧，将其丢弃。</li></ol></li></ol></li></ul></li></ul></li></ul><h4 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h4><ul><li>以太网交换机（以下简称交换机）本质上就是一个多接口的网桥：<ul><li>交换机自学习和转发帧的流程与网桥是相同的</li><li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机。</li><li>当交换机的接口与计算机或交换机连接时，可以工作在全双工方式，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞地传输数据，这样就不需要使用CSMA&#x2F;CD协议了。<br><img src="/../img/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C.png"></li></ul></li></ul><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><ul><li>诞生背景：<ul><li>将多个站点通过一个或多个以太网交换机连接起来就构建出了交换式以太网。</li><li>交换式以太网中的所有站点都属于同一个广播域。</li><li>随着交换式以太网规模的扩大，广播域也相应扩大，<strong>巨大的广播域会带来一系列问题</strong><ul><li>广播风暴：广播风暴会浪费网络资源和各主机的CPU资源</li><li>难以管理和维护，带来潜在安全问题</li></ul></li></ul></li><li>分割广播域可以解决广播域太大导致的问题<ul><li>使用路由器可以隔离广播域（成本高）</li><li>虚拟局域网技术</li></ul></li><li>虚拟局域网（Virtual Local Area Network，VLAN）是一种将<strong>局域网内的站点划分成与物理位置无关的逻辑组的技术</strong>，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求。<ul><li>属于同一VLAN的站点之间可以直接进行通信，而不同VLAN中的站点之间不能直接通信。</li><li>连接在同一交换机上的多个站点可以属于不同的VLAN，而属于同一VLAN的多个站点可以连接在不同的交换机上。</li></ul></li><li>实现机制<ul><li>Access端口（默认）<ul><li>给“未打标签”的MAC帧打标签（根据端口自己的PVID），将PVID存入帧的VID中</li><li>若帧中的VID和接口的PVID值相同，则给帧去除标签，再进行转发，否则不转发</li></ul></li><li>Trunk端口<ul><li>既可以接收“未打标签”的MAC帧，也可以接收“已打标签”的802.1Q帧。若接收到普通以太网MAC帧时，根据接收帧的接口的PVID给帧“打标签”，这与Access接口的处理相同。</li><li>对于帧的VID值等于接口的PVID值的802.1Q帧，将其“去标签”转发；对于<strong>帧的VID值不等于接口的PVID值802.1Q帧</strong>，将其<strong>直接转发</strong>。因此，从Trunk接口转发出的帧，可能是普通以太网MAC帧，也可能是802.1Q帧。</li></ul></li></ul></li></ul><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><ul><li>802.11无线局域网使用CSMA&#x2F;CA协议的原因<ul><li>对于802.11无线局域网，其使用无线信道传输数据，这与共享总线以太网使用有线传输介质不同。因此，802.11无线局域网<strong>不能简单照搬共享总线以太网使用的CSMA&#x2F;CD协议</strong>。<ul><li>由于无线信道的<strong>传输环境复杂且信号强度的动态范围非常大</strong>，在802.11无线网卡上接收到的信号强度一般都<strong>远远小于发送信号的强度</strong>，信号强度甚至相差百万倍。因此，如果要在802.11无线网卡上实现碰撞检测，对硬件的要求非常高。</li><li>即使能够在硬件上实现碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），还会<strong>出现无法检测到碰撞</strong>的情况，因此实现碰撞检测并没有意义。</li></ul></li></ul></li><li>无线局域网不能简单照搬共享总线以太网（有线局域网）使用的CSMA&#x2F;CD协议，而是不再实现碰撞检测CD功能，但在<strong>CSMA的基础上增加碰撞避免CA功能</strong>，即使用CSMA&#x2F;CA协议。<ul><li>CSMA&#x2F;CA协议<ul><li>若站点最初有数据要发送(而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA&#x2F;CA协议的退避算法。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器时间减少到零时(这时信道只可能是空闲的)，站点就发送整个的帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的步骤(2)开始，执行CSMA&#x2F;CA协议的退避算法，随机选定一段退避时间。</li><li>若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间)，就必须重传此帧(再次使用CSMA&#x2F;CA协议争用接入信道)，直到收到确认为止，或者经过若干次的重传失败后放弃发送。<br><img src="/../img/CSMACA%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存结构</title>
    <link href="/2023/10/07/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2023/10/07/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作<br>特点：</p><ul><li>Java 虚拟机基于二进制字节码执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><p>Java代码执行流程：Java 程序 –（编译）–&gt; 字节码文件 –（解释执行）–&gt; 操作系统（Win，Linux）</p><p>JVM、JRE、JDK对比：</p><ul><li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li><li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件<br><img src="/../img/jdk%EF%BC%8Cjre%EF%BC%8Cjvm%E5%AF%B9%E6%AF%94.png"></li></ul><h4 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h4><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡</p><ul><li><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</li><li><strong>运行</strong>：<ul><li>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</li><li>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，JVM 使用的是守护线程，main() 和其他线程使用的是用户线程，守护线程会随着用户线程的结束而结束<ul><li>用户线程是由应用程序代码创建和管理的线程，它们通常用于执行应用程序的业务逻辑和任务。</li><li>守护线程是一种特殊类型的线程，它的存在不会阻止JVM退出。它们通常用于<strong>执行后台任务和服务</strong>，如垃圾回收、定时任务等。</li><li>守护线程在用户线程结束后，如果没有其他用户线程继续运行，它们会自动退出，以确保JVM正常关闭。</li></ul></li><li>执行一个 Java 程序时，真真正正在执行的是一个 Java 虚拟机的进程</li><li>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</li><li>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</li></ul></li><li><strong>死亡</strong>：<ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h4><ul><li>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</li><li>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行<br><img src="/../img/java1.8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></li></ul><h4 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h4><ol><li><p>程序计数器</p><ul><li>作用，记住下一条jvm指令的执行地址</li><li>特点<ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul></li><li>原理<ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul></li></ul></li><li><p>虚拟机栈</p><ul><li>每个线程运行所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存（存储局部变量表，操作数栈，动态链接，方法出口等信息）<ul><li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的定义</li><li>操作数栈或表达式栈和其他一些附加信息</li></ul></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li><li>虚拟机栈特点：<ul><li>栈内存不需要进行GC，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</li><li>方法内的局部变量是否线程安全：<ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul></li></ul></li><li><p>本地方法栈</p><ul><li>本地方法栈是为虚拟机执行本地方法时提供服务的</li></ul></li><li><p>堆<br>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题<br>存放：</p><ul><li>对象实例：类初始化生成的对象，基本数据类型的数组也是对象实例，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放在方法区，JDK7开始存放于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率<br>堆内存诊断工具：</li></ul><ol><li>jps：查看当前系统中有哪些 Java 进程</li><li>jmap：查看堆内存占用情况 jhsdb jmap –heap –pid 进程id</li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测、</li></ol></li><li><p>方法区</p><ul><li>方法区：<ul><li>是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</li><li>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</li></ul></li><li>为了避免方法区出现 OOM(OutOfMemoryError)，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，静态变量和字符串常量池等放入堆中</li><li>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了类在编译期间生成的字面量、符号引用，JVM 为每个已加载的类维护一个常量池<ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul></li><li>运行时常量池是方法区的一部分<ul><li>常量池：<ul><li>常量池是位于Java类文件（.class文件）中的一部分，用于存储各种常量信息，包括字符串常量、类名、方法名、字段名、常量值等。</li><li>常量池中的常量信息在编译期间被收集和生成，并在运行时被加载到内存中供JVM使用。</li><li>常量池中的常量是不可修改的，一旦定义，就不能被更改。</li><li>常量池中的字符串常量通常是被共享的，即多个字符串变量可以引用相同的字符串对象，以减少内存占用。</li></ul></li><li>StringTable<ul><li>StringTable是JVM内部的数据结构，用于管理和存储字符串对象。</li><li>具体请看：<a href="https://blog.csdn.net/cd546566850/article/details/105353791">JVM内存结构之浅析常量池、运行时常量池、StringTable</a><br><img src="/../img/%E5%88%9B%E5%BB%BAJava%E5%AF%B9%E8%B1%A1.png"></li></ul></li></ul></li></ul></li><li><p>直接内存</p><ol><li>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-物理层</title>
    <link href="/2023/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2023/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul><li>物理层关注的是如何在连接各种计算机的传输媒体上传输数据。</li><li>物理层的任务是尽可能的<strong>屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异</strong><ul><li>为什么要进行屏蔽呢？<ul><li>不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。</li><li>所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。</li><li>简单来说就是：物理层使不同设备不同条件 的情况下让上层感受不到差异，因此使得不需要“因地制宜”。</li></ul></li></ul></li></ul><h3 id="物理层之下的传输媒体"><a href="#物理层之下的传输媒体" class="headerlink" title="物理层之下的传输媒体"></a>物理层之下的传输媒体</h3><ul><li><p>传输媒体是计算机网络设备之间的<strong>物理通路</strong>，也称为传输介质或传输媒介。</p><ul><li>传输媒体在物理层之下，并且不包含在计算机网络体系结构之中。<br> <img src="/../img/%E5%8C%85%E5%90%AB%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="包含传输媒体结构"></li></ul></li><li><p>分类：</p><ul><li>导向型传输媒体：<ul><li>导向型传输媒体是一种物理传输媒体，它提供了一个明确的路径，以引导信号或数据传输。<ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li></ul></li></ul></li><li>非导向型传输媒体：<ul><li>也称为无线传输媒体，不提供明确的物理路径来引导信号传输。相反，它们使用无线信号（通常是电磁波或无线电波）来传输数据。<ul><li>无线电波</li><li>红外线</li><li>激光</li></ul></li></ul></li></ul></li><li><p>传输方式</p><ul><li>串行传输和并行传输：<ul><li>串行传输：<ul><li>串行传输是一种将数据位按照顺序一个接一个地传输的方式</li><li>在串行传输中，每个数据位都依次发送或接收，而且它们之间通常使用一个单独的信号线来传输。</li><li>通常用于长距离通信，因为它能够更好地保持数据的完整性，减少干扰和数据丢失的可能性。</li></ul></li><li>并行传输<ul><li>并行传输是一种同时传输多个数据位的方式。</li><li>在并行传输中，每个数据位都有自己的信号线，它们可以同时传输，因此在同一时间段内可以传输多个数据位。</li><li>并行传输同时传输多个数据位，适用于高速数据传输，但通常在短距离内使用。<br><img src="/../img/%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93%E5%92%8C%E5%B9%B6%E8%A1%8C%E4%BC%A0%E8%BE%93.png" alt="串行传输和并行传输"></li></ul></li></ul></li><li>同步传输和异步传输：<ul><li>同步传输<ul><li>同步传输是一种以固定的时间间隔或时钟信号来传输数据的方式。</li><li>在同步传输中，数据被划分为块（帧）并以固定的速率传输，通常使用一个时钟信号来同步发送和接收端的数据传输。这样，接收端知道何时开始接收和解析数据，因为它可以根据时钟信号的节奏来同步数据位。</li></ul></li><li>异步传输<ul><li>异步传输是一种在数据帧之间没有固定的时间间隔或时钟信号的传输方式。</li><li>在异步传输中，数据帧的开始和结束由特殊的控制字符（称为起始位和停止位）标识，而不是通过定期的时钟信号。</li></ul></li></ul></li><li>单向通信、双向交替通信和双向同时通信<ul><li>单向通信：</li><li>双向交替通信：</li><li>双向同时通信：<br><img src="/../img/%E5%8D%95%E5%90%91%E9%80%9A%E8%A1%8C%E7%AD%89.png" alt="单向通信等"></li></ul></li></ul></li></ul><h3 id="调制与编码"><a href="#调制与编码" class="headerlink" title="调制与编码"></a>调制与编码</h3><ul><li>调制与编码的作用<ul><li>编码：编码是将数字数据（0和1）转换为适合于传输媒体的信号的过程。</li><li>调制：调制是将数字信号转换为模拟信号（通常是电磁波）的过程。这是为了在无线通信或光纤通信等介质中传输数据。<br><img src="/../img/%E8%B0%83%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="调制与编码的作用"></li></ul></li><li>码元：在使用时间域的波形表示信号时，代表不同离散数值的<strong>基本波形</strong>称为码元。</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li>信道复用技术：<ul><li>是一种用于在通信系统中有效地共享和利用通信信道的方法。它允许多个通信设备或数据流共享同一个物理信道，从而提高了通信系统的效率和资源利用率。</li><li>就是在一条传输媒体上同时传输多路用户的信号。</li></ul></li><li>常用技术：<ul><li>频分复用：<ul><li>频分复用将频率范围划分为多个不重叠的子信道，每个子信道用于一个通信设备或数据流。每个设备在其分配的频率带宽内进行通信。</li></ul></li><li>时分复用：<ul><li>时分复用将时间划分为若干个时隙（time slots），每个时隙用于一个通信设备或数据流。多个设备按时间顺序轮流使用信道，以便在不同的时间间隙内进行通信。</li></ul></li><li>波分复用：<ul><li>WDM是光纤通信中的一种频分复用技术，它利用不同波长（颜色）的光信号来传输多个数据流。每个波长对应一个不同的通信通道。</li></ul></li><li>码分复用：<ul><li>类似于一句话可以有不同的解释，每个设备都有自己的解释理论，因此实现一句话传输多种信息（每种设备根据自己的解密方式获取一种信息）</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯问题笔记</title>
    <link href="/2023/10/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><ul><li>回溯算法可以解决如下问题：<ul><li>组合问题</li><li>排列问题</li><li>切割问题</li><li>子集问题</li></ul></li><li>回溯模板：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意事项：<ul><li>去重问题<ul><li><p>有重复元素情况的去重：此时元素的值可能重复，但是元素不能重复，答案也不能重复，例如[1,1,2] 中组合 [1,2],[1,2]，两个1来自不同元素，但是因为结果重复，所以需要去重</p><ul><li>对数组排序</li><li>添加全局标识数组used[]</li><li>进行条件判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex;i &lt; candidates.length; i++)&#123;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-comment">//注意是used[i-1]，进行当前元素处理的时候肯定是要判断是否之前有重复元素的访问。</span><br>    <span class="hljs-comment">//树枝可以使用，但是树层间不能使用</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.add(candidates[i]);<br>    helper(candidates,target,currentSum+candidates[i],i+<span class="hljs-number">1</span>);<span class="hljs-comment">//不是startindex + 1，而是i + 1，因为每次遍历都是向自己身后的元素进行搜索</span><br>    used[i] = <span class="hljs-literal">false</span>;<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树层去重：当前层for循环时进行去重</p><ul><li>在for循环之前定义一个set，存储此次for循环之前遍历过的元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;Integer&gt; used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++)&#123;<br>    <span class="hljs-keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="hljs-number">1</span>) &gt; nums[i] || used.contains(nums[i]))&#123;<span class="hljs-comment">//因为不能排序，所以无法像之前的used数组来进行标记</span><br>    <span class="hljs-comment">//这里使用集合来进行同层的判断</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used.add(nums[i]);<br>    path.add(nums[i]);<br>    helper(nums,i+<span class="hljs-number">1</span>);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树枝去重：向下递归时进行去重</p><ul><li>使用used数组进行全局的标识<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>    <span class="hljs-keyword">if</span>(used[i])&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.add(nums[i]);<br>    helper(nums,i+<span class="hljs-number">1</span>);<br>    used[i] = <span class="hljs-literal">false</span>;<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>for遍历去重：递归函数添加starIndex参数，每次迭代时从自身后一个元素进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n; i++)&#123;<span class="hljs-comment">//对根节点开始到最大结点进行组合</span><br>    path.add(i);<span class="hljs-comment">//组合</span><br>    traverse(n,k,i+<span class="hljs-number">1</span>);<span class="hljs-comment">//继续向下组合</span><br>    path.removeLast();<span class="hljs-comment">//回溯</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重复元素组合（不能重复结果）的求和</title>
    <link href="/2023/10/04/%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%9C%EF%BC%89%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/04/%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%9C%EF%BC%89%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p></blockquote><ul><li><p>难点：</p><ul><li>因为本题中的输入可以有相同的元素，所以[1,1,2]是合理的，而本题又不允许重复的结果，所以尽管[1,3]和[1,3]中的1来自不同的元素，但也是不允许的</li><li>因此，我们画图可以得出在树层的添加的时候，是可以允许重复，树间的添加是不允许重复</li><li>参考下图：<img src="/./../img/%E7%BB%84%E5%90%88%E6%B1%82%E5%92%8C%EF%BC%88%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89.jpg" alt="组合"></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-comment">//使用used数组来记录是否元素被访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> currentSum,<span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(currentSum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(currentSum == target)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex;i &lt; candidates.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-comment">//难点在此，因为本题中的输入可以有相同的元素，所以[1,1,2]是合理的，而本题又不允许重复的结果，所以尽管[1,3]和[1,3]中的1来自不同的元素，但也是不允许的</span><br>                <span class="hljs-comment">//因此，我们画图可以得出在树层的添加的时候，是可以允许重复，树间的添加是不允许重复</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(candidates[i]);<br>            helper(candidates,target,currentSum+candidates[i],i+<span class="hljs-number">1</span>);<span class="hljs-comment">//又出现了这个问题，不是startindex + 1，而是i + 1，因为每次遍历都是向自己身后的元素进行搜索</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<span class="hljs-comment">//记录访问过的元素</span><br>        Arrays.fill(used,<span class="hljs-literal">false</span>);<br>        Arrays.sort(candidates);<br>        helper(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {      font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;      font-size: 20px;  }  </style></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列笔记</title>
    <link href="/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><ul><li><p>消息队列（Message Queue）是一种用于在应用程序之间传输异步消息的通信模式。它是一种在分布式系统中广泛应用的通信机制，用于解耦应用程序的组件，实现松耦合和可伸缩性。</p></li><li><p>同步和异步通讯</p><ul><li>同步通讯：类似打电话，实时响应，但通讯期间无法干其他事情<ul><li>缺点：<ul><li>耦合度高，不便于修改</li><li>资源浪费，调用链中的每个服务都需要等待相关前置服务的响应，浪费资源</li><li>级联问题：一个服务出现问题，相关调用服务都会出现问题</li></ul></li></ul></li><li>异步通讯：类似发短信，不是实时，但是可以支持多线程操作<ul><li>优点：<ul><li>耦合度低，服务双方并不是直接通信，而是由一个中间人来代理，发布者发布事件到中间人，订阅者从中间人接收事件。同时也便于修改更新</li><li>增加吞吐量，快服务不会被慢服务耽误，发布事件后即可去继续执行自己的业务。如：一个支付服务只需要向Broker（中间人）发布一个支付成功的事件，剩下的就不用它管了</li><li>故障隔离，无级联问题，服务之间都是去中间人接受事件，一个服务出故障和另一个服务之间并没有直接关系</li><li>流量削峰：不管发布事件流量波动多大，都由中间人接收，进行缓冲，订阅者可以按照自己的速度处理事件</li></ul></li><li>缺点：<ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂时，业务没有明确的流程线，不好追踪管理（出了bug都不好找）</li></ul></li></ul></li></ul></li><li><p>常见MQ对比:</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p></li></ul><h3 id="MQ的基本使用"><a href="#MQ的基本使用" class="headerlink" title="MQ的基本使用"></a>MQ的基本使用</h3><ul><li>SpringAMQP<ul><li>它是基于RabbitMQ封装的一套模板，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现，并且利用SpringBoot对其实现了自动装配，使用起来十分方便</li><li>SpringAMQP提供了三个功能：<ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul></li><li>消息的发送 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-comment">//用于发送消息</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, SpringAMQP! &quot;</span>;<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>消息的接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><span class="hljs-comment">//注解要监听的队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>发布订阅<br>  <img src="/../img/%E5%B8%A6%E6%9C%89exchange%E7%9A%84mq.png" alt="exchangemq"><ul><li>增加了exchange角色<ul><li>Exchange：交换机。一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或者是将消息对其。到底如何操作，取决于Exchange的类型。Exchange有以下三种类型<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key的队列</li><li>Topic：通配符，把消息交给符合routing pattern(路由模式)的队列</li></ul></li></ul></li></ul></li><li>消息转换器<ul><li>Spring会把发送的消息序列化为字节发送给MQ，接收消息的时候，会将字节反序列化为Java对象</li><li>但是默认情况下，Spring采用的序列化方式是JDK序列化，众所周知，JDK序列化存在以下问题<ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul></li><li>使用jackson代替原来的jdk的序列化<ul><li>引入依赖</li><li>在publisher和comsumer启动类添加bean，对原来的序列化进行覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>publis MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>consumer和publisher的序列化器需保持一致，同时consumer中接收数据的类型，也需要和发送数据的类型保持一致</li></ul></li></ul></li></ul></li></ul></li></ul><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker笔记</title>
    <link href="/2023/10/03/docker%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/03/docker%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><ul><li>docker是一个用go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所需要的依赖打包进docker container。</li><li>image：<ul><li>Docker镜像是容器的模板，它包含了应用程序和其依赖项的快照。镜像是只读的，可用于创建运行中的容器实例。</li></ul></li><li>container：<ul><li>Docker容器是一个轻量级的可执行单元，包括应用程序及其运行时环境、依赖项和配置。容器隔离了应用程序和底层操作系统，确保容器在不同环境中具有一致的行为。</li></ul></li><li>dockerhub：<ul><li>类似于github，是官方的一个镜像托管平台，类似的平台有很多，如阿里云镜像库等，这样的平台统称为：docker registry</li><li>我们可以将自己的镜像上传到dockerhub，也可以直接从dockerhub拉取镜像</li></ul></li><li>docker架构：<ul><li>服务端：负责处理docker命令，管理镜像，容器等</li><li>客户端：通过api向docker服务端发送指令</li><li><img src="/./../img/docker%E6%9E%B6%E6%9E%84.jpg" alt="docker架构"></li></ul></li></ul><h3 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h3><ul><li>docker可以解决依赖兼容问题<ul><li>docker打包应用的依赖，配置等，并且进行了隔离</li></ul></li><li>docker可以解决操作系统环境的差异<ul><li>docker不仅打包应用的依赖，也打包了系统的库函数</li><li>所以docker可以解决不同的系统上的环境问题，但是必须底层都是一个系统（如都是linux的Ubuntu，Centos等）</li></ul></li><li>docker和虚拟机的区别：<ul><li>Docker容器非常轻量级，与传统虚拟机相比，它们更快速启动、占用更少的系统资源，并允许在同一物理主机上运行更多的容器。</li><li>Docker便于移植</li></ul></li></ul><h3 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h3><ul><li>建议自行查看docker文档，或者询问chatgpt</li><li>推荐一篇文章<a href="https://zhuanlan.zhihu.com/p/187505981">什么是docker</a><style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修剪二叉搜索树</title>
    <link href="/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树</a></p></blockquote><ul><li><p>与删除结点思路不同</p><ul><li>我们应该利用特性，来递归遍历</li><li>即当根结点值小于low，那么所有左子树可以抛弃，将右子树返回给上层接收即可，此操作删除了根节点也删除了根节点的左子树（大于high同理）</li><li>然后每次递归操作需要递归返回，以及递归完后需要        <ul><li>root.left &#x3D; trimBST(root.left,low,high);</li><li>root.right &#x3D; trimBST(root.right,low,high);</li></ul></li><li>这就是上层接收与下层返回的实现</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment">* public class TreeNode &#123;</span><br><span class="hljs-comment">*     int val;</span><br><span class="hljs-comment">*     TreeNode left;</span><br><span class="hljs-comment">*     TreeNode right;</span><br><span class="hljs-comment">*     TreeNode() &#123;&#125;</span><br><span class="hljs-comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment">*         this.val = val;</span><br><span class="hljs-comment">*         this.left = left;</span><br><span class="hljs-comment">*         this.right = right;</span><br><span class="hljs-comment">*     &#125;</span><br><span class="hljs-comment">* &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; low)&#123;<span class="hljs-comment">//此时越界了，删除所有左子树以及根节点（即让上层接收右子树）</span><br>            <span class="hljs-keyword">return</span> trimBST(root.right,low,high);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &gt; high)&#123;<span class="hljs-comment">//此时越界了，删除所有右子树以及根节点</span><br>            <span class="hljs-keyword">return</span> trimBST(root.left,low,high);<br>        &#125;<br>        <span class="hljs-comment">//上层的接收发起</span><br>        root.left = trimBST(root.left,low,high);<br>        root.right = trimBST(root.right,low,high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除二叉搜索树的结点</title>
    <link href="/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <url>/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></p></blockquote><ol><li>思路分析</li></ol><ul><li>整体思路：<ul><li>依然使用二叉搜索树的性质来查找需要删除的节点</li><li>当找到时执行相应的删除逻辑</li></ul></li><li>在二叉搜索树中删除节点比插入节点难，因为删除节点的时候涉及到了结构的调整。</li><li>所以我们在删除的时候得分情况来进行讨论<ul><li>当找到的节点是叶子节点时，直接返回null，即代表删除（原理是返回null给上层的递归调用的节点来进行接受）</li><li>当只有单个子节点时，直接返回单个子节点，给上层接受</li><li>当有两个节点时（包括有两颗子树），我们需要思考如何调整结构，我们画图后可以很容易想明白，我们可以按照二叉搜索树规则来进行结构调整。<ul><li>比如我们可以选择将待删除的节点的右节点作为新的根节点，于是我们应该将待删除的节点的左子树迁移到右子树上。</li><li>但是迁移到哪里呢？我们知道二叉搜索树是左节点小于根节点，右节点大于根节点，所以右子树全部节点都大于左子树，我们应该将左子树拼接到右子树中最小的节点之中。</li><li>所以我们应该将左子树拼接到右子树的最最左节点上</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<span class="hljs-comment">//找到删除节点</span><br>            <span class="hljs-comment">//分类讨论</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//找到右子树中最小的节点，将左子树拼接上去</span><br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root.val)&#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; root.val)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习笔记</title>
    <link href="/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h3><ul><li>单体架构：将所有的功能集中在一个项目之中开发，打包部署<ul><li>优点<ul><li>架构简单</li><li>部署成本低</li></ul></li><li>缺点<ul><li>耦合度高，维护困难，升级困难</li></ul></li></ul></li><li>分布式架构：根据功能对系统做拆分，每个业务功能模块作为独立的项目进行开发，成为一个服务<ul><li>优点<ul><li>耦合度低</li><li>利于服务的升级拓展</li></ul></li><li>缺点<ul><li>调用关系复杂</li></ul></li></ul></li><li>微服务<ul><li>架构特点：<ul><li>单一职责，每一个服务对应唯一的业务能力，做到单一职责</li><li>自治，团队独立，技术独立，数据独立</li><li>面向服务，服务提供统一标准接口，与语言和技术无关</li><li>隔离性强，服务调用做好隔离，容错，降级，避免出现级联问题（即一个服务挂了影响到另一个服务）<br><img src="/../img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微服务"></li></ul></li></ul></li><li>SpringCloud<ul><li>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验</li><li>常见的组件包括：<ul><li>微服务注册与发现<ul><li>Eureka</li><li>Nacos</li><li>Consul</li></ul></li><li>服务远程调用<ul><li>OpenFeign</li><li>Dubbo</li></ul></li><li>服务链路监控<ul><li>Zipkin</li><li>Sleuth</li></ul></li><li>统一配置管理<ul><li>SpringCloudConfig</li><li>Nacos</li></ul></li><li>统一网关路由<ul><li>SpringCloudGateway</li><li>Zuul</li></ul></li><li>流控，降级，保护<ul><li>Hystix</li><li>Sentinel</li></ul></li></ul></li></ul></li></ul><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><ul><li>假如我们的服务提供者user-service提供了三个实例，占用的分别是8081、8082、8083端口</li><li>我们思考三个问题：<ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时，该如何选择？</li><li>order-service如何得知某个user-service实例是否健康，是不是已经宕机？</li></ul></li><li>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下<br><img src="/./../img/eureka%E7%BB%93%E6%9E%84.jpg" alt="eureka结构"></li><li>我们回答上述问题：<ul><li>order-service如何得知user-service实例地址？<ul><li>user-service服务启动后，会将自己的信息注册到eureka服务端</li><li>eureka保存 服务名称 - 服务实力的地址 的映射</li><li>order-service根据服务名称拉取实例的地址列表</li></ul></li><li>order-service如何从多个user-service实例中选择具体的实例？<ul><li>利用负载均衡的算法进行判断（随机，轮询等）</li></ul></li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？<ul><li>被注册的服务（userservice）会定时向eureka-server发起请求（心跳），报告自己的状态</li><li>当eureka-server一定时间 没有接收到已经注册的服务的请求（心跳）时，eureka-server会认为该服务实例故障，会从服务列表剔除。</li></ul></li></ul></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>为什么要用负载均衡<ul><li>解决单体架构无法应对高请求的问题</li><li>将客户端请求均匀的分发到多台目标服务器</li><li>检测出目标服务器的健康状态，使得客户端不向已经宕机的服务器发送请求。</li></ul></li><li>实现方案<ul><li>基于DNS实现负载均衡</li><li>基于硬件实现负载均衡</li><li>基于软件实现负载均衡</li></ul></li><li>基于软件实现负载均衡<ul><li>SpringCloud底层利用Ribbon组件来实现负载均衡功能<br><img src="/../img/ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="ribbon实现负载均衡"></li><li>ribbon调用详情如下：<br><img src="/../img/ribbon%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt="ribbon调用详情"><ol><li>拦截RestTemplate请求：<a href="http://user-service/user/1">http://user-service/user/1</a></li><li>RibbonLoadBalanceClient会从请求中获取服务名称，即user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost8081，localhost8082</li><li>IRule根据负载均衡规则，选择一个实例</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代user-service，得到<a href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求</li></ol></li></ul></li><li>负载均衡策略：<ul><li>随机，轮询等</li><li>默认的是ZoneAvoidanceRule，是一种轮询方案</li><li>自定义实现：<ul><li>代码方式：在order-service中的OrderApplication类中，定义一个IRule，此种方式定义的负载均衡规则，对所有微服务均有效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>配置文件实现：在order-service中的application.yml文件中，添加新的配置也可以修改规则<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是user-service服务</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure></li></ul></li><li>饥饿加载：饥饿加载是一种在获取主要数据的同时，立即获取相关联的数据的策略。</li><li>懒加载：懒加载是一种在需要数据时才加载的策略。</li><li>Ribbon默认是采用懒加载，即第一次访问时，才回去创建LoadBalanceClient，第一次请求时间会很长</li><li>而饥饿加载在则会在项目启动时创建，降低第一次访问的耗时，可以在配置文件中调整加载方案。</li></ul></li></ul><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><ul><li>认识Nacos<ul><li>Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件，相比于Eureka，功能更加丰富，在国内受欢迎程度较高</li><li>Nacos是SpringCloudAlibaba的组件，而SpringCloud Alibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos与使用Eureka对于微服务来说，依赖不同，服务地址不同，其他基本类似。</li><li>nacos集群：将服务实例分布于全国各地，在一个地方的实例划分为一个集群，增加容灾能力。</li><li>nacos服务分级存储模型：<ol><li>服务：userservice</li><li>集群，杭州的userservice</li><li>实例，杭州的机房的部署了userservice的服务器</li></ol></li><li>nacos在实现负载均衡的时候会优先同集群的实例</li><li>权重配置<ul><li>对于老差设备分配更少的权重</li><li>nacos可以进行权重的配置（设为0，该实例永远不会被访问）</li></ul></li><li>环境隔离：Nacos提供了namespace来实现环境隔离功能<ul><li>nacos中可以有多个namespace</li><li>namespace下可以由group、service等</li><li>不同的namespace之间相互隔离，例如不同的namespace的服务互相不可见</li></ul></li><li>nacos实例分类<ul><li>临时实例（默认类型），宕机超过一定时间，会从服务列表中剔除。</li><li>非临时实例（可手动设置），宕机后不会被剔除。</li></ul></li><li>Nacos与Eureka的共同点<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康监测</li></ul></li><li>Nacos与Eureka的不同点<ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当急群众存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul></li></ul><h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><ul><li>为什么需要配置管理：<ul><li>当服务器部署的实例越来越多时，逐个修改微服务的配置很麻烦，并且容易出错，所以此时需要一个统一的配置管理方案，集中管理所有实例的配置。</li><li>Nacos可以将配置集中管理，也可以在配置变更时，及时通知微服务，实现配置的热更新。</li></ul></li><li>从微服务拉取配置：<ul><li>微服务要拉取Nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动</li><li>既然要拉取nacos中的配置，再读取application.yml，那么如何获取nacos的地址呢？<ul><li>Spring引入了一种新的配置文件：bootstrap.yml文件，会在application.yml之前被读取<ol><li>项目启动</li><li>加载bootstrap.yml,获取nacos地址，配置文件的id（服务名-服务环境-后缀名）</li><li>根据配置文件id，读取nacos中的配置文件</li><li>读取本地的application.yml，与nacos中的配置合并</li><li>创建spring容器</li><li>加载bean</li></ol></li></ul></li></ul></li><li>配置的热更新<ul><li>在@Value注入的变量类上添加注解@RefreshScope（刷新作用域）</li><li>使用@ConfigurationProperties注解代替@Value注解，在user-service服务中，添加一个类，读取pattern.dateformat属性</li></ul></li><li>配置共享：<ul><li>其实微服务启动时，回去Nacos读取多个配置文件，例如<ul><li>[spring.application.name]-[spring.profiles.active].yaml，例如：user-service-dev.yaml</li><li>[spring.application.name].yaml，例如：userservice.yaml</li></ul></li><li>而[spring.application.name].yaml不包含环境，因此可以被多个环境共享</li><li>配置共享优先级<ul><li>服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置<ul><li>user-service-dev.yaml &gt; user-service.yaml &gt; application.yaml</li></ul></li></ul></li></ul></li></ul><h3 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h3><ul><li>为什么要使用feign远程调用：<ul><li>以前的RestTemplate存在以下问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://user-service/user/&quot;</span> + order.getUserId();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, User.class);<br></code></pre></td></tr></table></figure><ul><li>可读性差，编程体验不统一</li><li>对于参数复杂的url难以维护</li></ul></li></ul></li><li>feign的使用<ul><li>使用步骤：引入依赖-&gt;添加注解-&gt;编写feign客户端<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;user-service&quot;)</span><span class="hljs-comment">//服务名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><span class="hljs-comment">//请求方式以及路径</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<span class="hljs-comment">//请求参数以及返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserClient userClient;<span class="hljs-comment">//注入feign客户端</span><br><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-comment">// 1. 查询订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.findById(orderId);<br>        <span class="hljs-comment">// 2. 利用Feign发起http请求，查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.findById(order.getUserId());<br>        <span class="hljs-comment">// 3. 封账user到order</span><br>        order.setUser(user);<br>        <span class="hljs-comment">// 4. 返回</span><br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>feign的使用优化<ul><li>feign的最佳实践<ul><li>继承：<ol><li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserAPI</span>&#123;<br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>Feign客户端和Controller都继承该接口</li></ol><ul><li>实现了代码共享，但是紧耦合</li></ul></li><li>抽取：<ul><li>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</li><li>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用<br><img src="/../img/feign%E7%9A%84%E6%8A%BD%E5%8F%96%E5%AE%9E%E7%8E%B0.jpg" alt="feign的抽取实现">   </li><li>解决包扫描问题：<ul><li>指定Feign应该扫描的包</li><li>指定需要加载的Client接口</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h3><ul><li>为什么需要网关<ul><li>Gateway网关是我们服务的守门神，是所有微服务的统一入口</li></ul></li><li>网关的核心功能为：<ul><li>请求路由:一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫路由。当然路由的目标服务有多个时，还需要做负载均衡</li><li>权限控制:网关作为微服务的入口，需要校验用户是否有请求资格，如果没有则拦截</li><li>限流:当请求量过高时，在网关中按照微服务能够接受的速度来放行请求，避免服务压力过大<br><img src="/../img/%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="网关架构图"> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">## 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment">## 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment">## nacos地址（我这里还是用的nginx反向代理，你们可以启动一个单体的nacos，用8848端口）</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment">## 路由id，自定义，只需要唯一即可</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span> <span class="hljs-comment">## 路由的目标地址，lb表示负载均衡，后面跟服务名称</span><br>          <span class="hljs-comment">## uri: http://localhost:8081 ## 路由的目标地址，http就是固定地址</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">## 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment">## 这个是按照路径匹配，只要是以/user开头的，就符合规则</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span> <span class="hljs-comment">## 按照上面的写法，再配置一下order-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-service</span> <br>          <span class="hljs-attr">predicates:</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span> <br></code></pre></td></tr></table></figure></li></ul></li><li>过滤器：<ul><li>作用：<ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由请求生效</li></ul></li><li>default-filters：<ul><li>对所有路由都生效的过滤器</li></ul></li><li>全局过滤器：<ul><li>使用自己的业务逻辑进行实现的过滤器</li></ul></li><li>过滤器执行顺序<ul><li>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</li><li>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器<br><img src="/../img/%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt="过滤器"> </li><li>排序规则为：<ul><li>每个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前（默认值为2147483647，即int最大值）</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul></li></ul></li></ul></li><li>跨域问题：<ul><li>什么是跨域：域名不一致就是跨域，主要包括<ul><li>域名不同：<a href="http://www.baidu.com和www.baidu.org,www.js.com和miaosha.js.com/">www.baidu.com和www.baidu.org，www.js.com和miaosha.js.com</a></li><li>域名相同，端口不同：localhost:8080和localhost:8081</li><li>请求协议不同，如http:baidu.com和https:baidu.com</li></ul></li><li>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</li><li>解决方案：CORS<ul><li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</li><li>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<style>/* 只设置 markdown 字体 */.markdown-body {font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;font-size: 20px;}</style></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-30记事</title>
    <link href="/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>放假以来一直有点颓废，已经浪费接近三天了。原因有二：</p><ul><li>主要原因还是自己浮躁，懒惰，没能走出宿舍去教室自习。</li><li>在宿舍人容易有惰性，并且还会容易沉迷无限火力。</li><li>还有就是自己的焦虑问题<ul><li>总是想一口吃成大胖子，导致学习不扎实，自己也喜欢幻想自己变成编程大佬的开心生活。</li><li>明明知道自己该做什么，但还是焦虑自己是不是该做这，该做那，然后又去刷点短视频，水点群，真是浪费时间，还极度的影响到了我的睡眠。</li></ul></li><li>解决对策：<ul><li>早上起来，迅速洗漱，走出宿舍去教室自习。</li><li>制定学期计划，月计划，周计划，日计划，并且贯彻执行。</li><li>禁止胡思乱想，一旦胡思乱想请立马查看自己的胡思乱想对策，开始进行自我的提升和学习。</li><li>保持良好的运动习惯，蹲推拉不能少，晚上的有氧也不能少，跑步，骑车都可以。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归回溯解决二叉树所有路径问题】</title>
    <link href="/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径</a></p></blockquote><ul><li>关键在于如何进行所有路径的记录以及遍历。<ul><li>首先肯定是要利用前序遍历的思想的，因为题目要求的顺序和前序遍历的顺序一致，即 根-&gt;子 </li><li>利用回溯来实现非暴力的遍历，此题来说遍历就是向paths加节点，回溯就是向paths删节点。</li></ul></li><li>具体实现参照代码以及自己画图理解</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-comment">//前序遍历进行加入</span><br>        paths.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到达叶子节点</span><br>            <span class="hljs-comment">//构建符合题意的字符串</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; paths.size() - <span class="hljs-number">1</span>; i++) &#123;<br>                sb.append(paths.get(i)+<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>            sb.append(paths.get(paths.size()-<span class="hljs-number">1</span>));<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.left, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//进行回溯,节点指针回退一步，并且让paths重新变为回退的状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.right, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        traversal(root,paths,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-附近商户，签到，uv统计</title>
    <link href="/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h3><ul><li>实现根据当前位置搜索附近商户，并排序。</li></ul><h4 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h4><ul><li>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。</li><li>根据商铺类型为key，写入类型相同的商铺的经度纬度信息，保存在一个ZSet中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取所有shop，并且根据shop类型进行分组，保存在Map中（shopid，shops）</span><br>    List&lt;Shop&gt; shopList = shopService.list();<br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">//map.entrySet()：获取所有的键值对集合</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        List&lt;Shop&gt; shops = entry.getValue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(shops.size());<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            <span class="hljs-comment">//将当前type的商铺都添加到locations集合中</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())));<br>        &#125;<br>        <span class="hljs-comment">//批量写入</span><br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>具体实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">//1. 判断是否需要根据距离查询</span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br>    <span class="hljs-comment">//2. 计算分页查询参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>    <span class="hljs-comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span><br>    <span class="hljs-comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span><br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(key,<br>            GeoReference.fromCoordinate(x, y),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));<br>    <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//4. 解析出id</span><br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    <span class="hljs-keyword">if</span> (list.size() &lt; from) &#123;<br>        <span class="hljs-comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    HashMap&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        ids.add(Long.valueOf(shopIdStr));<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>        distanceMap.put(shopIdStr, distance);<br>    &#125;);<br>    <span class="hljs-comment">//5. 根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        <span class="hljs-comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span><br>        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>    &#125;<br>    <span class="hljs-comment">//6. 返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>如何高效少内存的进行签到统计：<ul><li>使用31位bitMap来统计一个用户的一个月的签到情况，1为签到，0为未签到。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 写入Redis  BITSET key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>如何获取本月连续签到的数据<ul><li>获取签到数据（从当前日期直到月初）</li><li>从末尾往前计算看有多少个连续的1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()<br>            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            count++;<br>        <span class="hljs-comment">//数字右移，抛弃最后一位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="uv统计"><a href="#uv统计" class="headerlink" title="uv统计"></a>uv统计</h3>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数</a></p></blockquote><ul><li>简单方法就是直接遍历<ul><li>可以使用递归</li><li>可以是用迭代（利用队列）</li></ul></li><li>难点在于根据题目条件进行优化，即使用完全二叉树性质。<ul><li>完全二叉树：只有最底层的节点不是满的，并且最底层的节点从左到右必须是连续的。</li><li>一颗满二叉树（所有节点都是满的）的节点个数是2^deep - 1个，所以我们可以判断出满二叉树的个数，然后进行叠加计算。</li><li>完全二叉树是由许多的满二叉树组成的（可画图分析）</li><li>所以使用递归进行计算，如何判断是否是满二叉树呢<ul><li>一个根节点，对其进行左遍历以及右遍历（一直左遍历，一直右遍历）来进行判断， 当其左遍历深度&#x3D;&#x3D;右遍历深度时，其为一棵满二叉树。</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left!=<span class="hljs-literal">null</span>)&#123;<br>            left = left.left;<br>            leftDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>            right = right.right;<br>            rightDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(rightDeepth==leftDeepth)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;leftDeepth) -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> countNodes(root.right) + countNodes(root.left)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-达人探店，好友关注</title>
    <link href="/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/"/>
    <url>/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能实现"><a href="#点赞功能实现" class="headerlink" title="点赞功能实现"></a>点赞功能实现</h4><ol><li><p>基本功能实现</p><ul><li>要求：<ul><li>同一个用户只能对同一篇笔记点赞一次，再点赞即取消点赞</li><li>当前用户若点赞则显示高亮（前端页面会根据是否点赞决定是否高亮），根据isLike属性判断</li></ul></li><li>实现：<ul><li>使用redis中的set集合来进行判断是否点赞过（下文会具体介绍）。</li><li>点赞判断使用blog实体中的isliked进行判断，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注解通常用于实体类属性上，表示该属性不对应数据库表中的列。</span><br><span class="hljs-comment">//在这里，属性 isLike 被标记为 exist = false，</span><br><span class="hljs-comment">//意味着这个属性不会映射到数据库表的任何列。</span><br><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span>&#123;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//防止空指针</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;blog:liked&quot;</span>+blog.getId();<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key,userId.toString());<br>    blog.setIsLike(score != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>点赞排行榜实现</p><ul><li>要求：根据时间顺序展示点赞用户。</li><li>目前的问题：我们之前的点赞是放入set集合，无法进行时间的判断，所以我们此时可以使用Sortset（Zset），包含分数作为优先级。<br> <img src="/../img/list%EF%BC%8Cset%EF%BC%8Csortedset%E5%AF%B9%E6%AF%94.png" alt="对比"></li><li>解决方案：<ul><li>点赞使用zset保存，key是：”blog:liked”+id;（id是被点赞blogid），存储的元素是（userid（点赞人），分数（当前毫秒时间戳））<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br><br>       <span class="hljs-comment">// 获取当前登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>       <span class="hljs-type">Double</span> <span class="hljs-variable">haveScore</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>       <span class="hljs-keyword">if</span> (haveScore==<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//未点赞，可点赞</span><br>           <span class="hljs-comment">//数据库点赞数据+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//保存用户到redis的set集合</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().add(key,userId.toString(),System.currentTimeMillis());<span class="hljs-comment">//点赞榜单，使用sortedSet进行优化，以时间戳作为优先级排序</span><br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//已点赞，取消点赞</span><br>           <span class="hljs-comment">//数据库-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//将用户从redis的set集合移除</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>排行榜实现：根据博客查询redis集合（点赞人）-&gt; 按照指定顺序返回点赞人集合</li><li>关注点：如何在in的情况下按照指定顺序返回数据：见注释<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">//查询top5的点赞用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//解析出用户id</span><br>    <span class="hljs-keyword">if</span> (top5==<span class="hljs-literal">null</span>||top5.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">//in查询数据库是按照默认id顺序，所以需要进行指定顺序，order by field(id,5,1)#根据id按照5，1进行返回</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>    List&lt;User&gt; users = userService.query().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br>            .last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>)<br>            .list();<br>    List&lt;UserDTO&gt; userDTOS = users.stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">//返回userdto</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><h4 id="关注功能实现"><a href="#关注功能实现" class="headerlink" title="关注功能实现"></a>关注功能实现</h4><ul><li>简单实现 <ul><li>建立数据库表tb_follow，有userid，followUserid字段来实现关注功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">//获取当前登录的userId</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//查询当前用户是否关注了该笔记的博主</span><br>        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>        <span class="hljs-comment">//只查询一个count就行了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count(queryWrapper);<br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFellow)</span> &#123;<br>        <span class="hljs-comment">//获取当前用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//判断是否关注</span><br>        <span class="hljs-keyword">if</span> (isFellow) &#123;<br>            <span class="hljs-comment">//关注，则将信息保存到数据库</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//取关，则将数据从数据库中移除</span><br>            LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>            remove(queryWrapper);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>共同关注功能实现<ul><li>利用redis的set集合存储用户的关注对象，对两个用户的关注对象集合求交集即可求出共同关注。下面为修改之后的关注功能实现，即将关注的对象加入redis中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>     <span class="hljs-comment">//获取用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userDTO.getId();<br>     <span class="hljs-comment">//判断是否关注</span><br>     <span class="hljs-keyword">if</span> (isFollow)&#123;<br>         <span class="hljs-comment">//关注则新增数据</span><br>         <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>         follow.setUserId(userId);<br>         follow.setFollowUserId(followUserId);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注的用户的id，放进redis的set集合 ： sadd userId followerUserId</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().add(key,followUserId.toString());<br>         &#125;<br>     &#125;<span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//取关，删除数据</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                 .eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId)<br>                 .eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>,followUserId));<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注用户的id从redis移除</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().remove(key,followUserId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="推送功能实现"><a href="#推送功能实现" class="headerlink" title="推送功能实现"></a>推送功能实现</h4><ul><li>feed流<ul><li>当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂。</li><li>feed流有两种模式：<ul><li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等)</li><li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</li></ul></li></ul></li><li>Timeline三种模式：<ul><li>推</li><li>拉</li><li>推拉结合</li></ul></li><li>我们使用推模式进行实战<ul><li>需求：<ul><li>修改新增博客的业务，在博客保存到数据库的时候，也推送到粉丝的收件箱。</li><li>收件箱按时间戳排序</li><li>收件箱实现分页查询</li></ul></li><li>难点：<ul><li>传统情况下分页查询是根据角标进行，但是因为我们的feed数据会更新，同时脚标也会更新，所以不能使用脚标。<ul><li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页<br><img src="/../img/%E8%A7%92%E6%A0%87%E5%8F%98%E5%8C%96.png" alt="角标变化"></li></ul></li><li>使用score来进行分页可以解决问题<ul><li>score使用时间戳来进行记录</li><li>根据集合名（当前登录id的关注集合），最小分数，最大分数，开始偏移量，查询个数 reverseRangeByScoreWithScores(key, 0, max, offset, 2);</li><li>每次查询完毕后需要返回最小时间戳，作为下次查询条件</li><li>偏移量的作用是防止出现相同时间戳的情况，为上次查询返回的相同最小时间戳的个数，关键，1最小时间戳（即最后一个），2相同</li><li>封装返回</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">//获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//查询用户收件箱（set(key（feed:userid),粉丝的id）)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;feed:&quot;</span>+userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>            <span class="hljs-comment">//查询的集合，最小分数值，最大分数值，起始偏移，查询数量</span><br>            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples==<span class="hljs-literal">null</span>||typedTuples.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//解析数据</span><br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple:typedTuples)&#123;<br>        <span class="hljs-comment">//获取id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> typedTuple.getValue();<br>        ids.add(Long.valueOf(id));<br>        <span class="hljs-comment">//获取score（时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (time==minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//解决sql in无法排序问题，手动指定顺序为传入的ids</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);              <span class="hljs-comment">//&quot;order by field(id,&quot; + &quot;3,4,5&quot; + &quot;)&quot;</span><br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>,ids).last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog:blogs)&#123;<br>        <span class="hljs-comment">//查询发布blog的用户信息</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">//查询当前用户是否给该blog点过赞</span><br>        isBlogLiked(blog);<br>    &#125;<br>    <span class="hljs-comment">//封装结果并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">scrollResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    scrollResult.setList(blogs);<br>    scrollResult.setOffset(os);<br>    scrollResult.setMinTime(minTime);<br>    <span class="hljs-keyword">return</span> Result.ok(scrollResult);<br>&#125;<br></code></pre></td></tr></table></figure> <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-优惠券秒杀</title>
    <link href="/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/"/>
    <url>/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="全局id"><a href="#全局id" class="headerlink" title="全局id"></a>全局id</h4><ul><li>原因：<ul><li>抢购商品时，订单保存到订单表之中，如果将订单id设置为数据库的自增id的话，规律性太明显，并且单表数据量有限制。</li></ul></li><li>实现：<ul><li>符号位 + 时间戳 + 序列号 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span>&#123;<br>        <span class="hljs-comment">//生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">//生成序列号</span><br>        <span class="hljs-comment">//获取当前日期，精确到天（将key以天分组，方便管理，并且解决redis自增上限问题）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">//自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">//拼接并且返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<span class="hljs-comment">//先左移32位，再或运算将count补上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="实现秒杀"><a href="#实现秒杀" class="headerlink" title="实现秒杀"></a>实现秒杀</h4><ul><li>秒杀券和其他普通优惠券类似，普通优惠券可以任意购买，而秒杀券需要在特定时间并且一人一单的方式进行抢购。券在一张表，包含所有的券，其中用一个字段标明其是否是秒杀券，并且还有一张秒杀券表，可采用类似于外键进行关联，其中包含的是秒杀券的一些特定信息（抢购时间，结束时间，库存等）。</li><li>抢秒杀券：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5. 扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>,voucherId)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">//6.1 设置订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">//6.2 设置用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//6.3 设置代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(id);<br>    <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>    save(voucherOrder);<br>    <span class="hljs-comment">//8. 返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><ul><li>上面代码有很明显的问题，就是在高并发场景下会出现超卖现象。原因就在于，在库存判断和库存扣除两步中并没有锁来约束。</li><li>我们可以进行加锁来解决：<ul><li>悲观锁<ul><li>悲观锁认为线程安全一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock等，都是悲观锁。</li></ul></li><li>乐观锁：<ul><li>乐观锁认为线程安全问题不一定发生，因此不加锁，只在数据更新的时候再去判断有没有其他线程对数据就进行了修改。<ul><li>如果没有修改，则认为自己是安全的，自己可以更新数据。</li><li>如果被其他线程进行了修改，则说明发生了安全问题，此时继续重试或者异常。</li></ul></li></ul></li><li>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</li><li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。</li></ul></li><li>在本项目中，并不需要指定版本号，可以使用stock进行替代，比较查询时的stock数据和修改时的数据库中的stock数据是否一致（因为stock只会减少，不会增加，因此不会出现aba问题，所以可以代替版本号）。</li></ul><h4 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h4><ul><li>操作逻辑，进行库存判断之后，根据订单表中的数据，判断用户是否已经购买过。<ul><li>购买过则不能下单</li></ul></li><li>初步逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一人一单逻辑</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果在多线程情况下，在执行一人一单的逻辑之前，在这个区间如果进来了多个线程，仍然能抢多张优惠券。即 线程1:库存充足-&gt;判断一人一单（此时该优惠券中并没有写入userid）-&gt;此时线程2：库存充足-&gt;优惠券无userid-&gt;线程2写入userid-&gt;线程1写入userid</li><li>解决办法<ul><li>添加悲观锁<ul><li>将一人一单后的逻辑写入一个方法createVouherOrder，并对该方法加锁。</li><li>但是此时的粒度太粗，当该方法有锁时，所有用户都无法进行此方法，而我们的目的是一人一单，所以这个锁，应该加在单个用户上，使用userid来标识。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 一人一单逻辑</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<span class="hljs-comment">//需要根据userid的字面量来进行加锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//5. 扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//6. 创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">//6.1 设置订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">//6.2 设置用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//6.3 设置代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setUserId(id);<br>        <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>        save(voucherOrder);<br>        <span class="hljs-comment">//8. 返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>    <span class="hljs-comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用AopContext.currentProxy()来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去IVoucherOrderService中创建createVoucherOrder方法</li><li>并且导入依赖aspectjweaver，以及在启动类加上注解@EnableAspectJAutoProxy(exposeProxy &#x3D; true)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h4><ul><li>通过加锁可以解决在单机情况下的一人一单问题，但是在集群模式下就不行了。<br><img src="/../img/jvm%E9%94%81.png" alt="jvm锁"></li><li>如上图所示，jvm中的锁都是按照单机为域划分的，所以在集群模式下我们需要使用分布式锁，即让锁不在jvm内部，而是让锁在jvm外，为公用的锁。</li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><ul><li>分布式锁：满足分布式系统或者集群模式下的多线程可见的并且可以互斥的锁。<br><img src="/./../img/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="分布式锁"></li><li>分布式锁应该满足的条件：<ul><li>可见性：每个线程，每个服务器都能看到锁</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全</li></ul></li><li>常见的分布式锁：<ul><li>mysql</li><li>redis</li><li>zookeeper<br><img src="/../img/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="常见分布式锁"></li></ul></li><li>redis实现分布式锁：<ul><li>核心思路：利用redis的SETNX方法，当多个线程进入时，利用该方法获取锁，第一个线程进入时，redis则有这个key，返回1，表示他抢到了锁，那么他去执行业务，完成后，再删除锁，退出锁，没有抢到锁的线程则等待重试。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">//锁的前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//自动拆箱可能会出现null，这样写更稳妥</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//通过DEL来删除锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br><span class="hljs-comment">// 获取锁对象</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock(<span class="hljs-number">120</span>);<br><span class="hljs-comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许抢多张优惠券&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取代理对象</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    redisLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>redis分布式锁误删问题：<ul><li>逻辑说明：<ul><li>如果持有锁的线程1在内部出现了阻塞，导致锁ttl过期，自动释放。</li><li>此时线程2来获取锁，因为线程1已经释放了锁，所以线程2拿到了锁</li><li>现在线程1阻塞结束，继续执行业务，再释放锁。&#x2F;</li><li>此时会将线程2的锁释放。</li></ul></li><li>解决办法<ul><li>在线程释放锁的时候判断该锁是否是自己的。</li><li>实现：存入锁的时候放入自己的线程标识，释放的时候再对锁进行判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标识是否一致</span><br>    <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>分布式锁的原子性问题：<ul><li>更为极端的误删逻辑说明</li><li>假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制）</li><li>于是锁的TTL到期了，自动释放了</li><li>那么现在线程2趁虚而入，拿到了一把锁</li><li>但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑</li><li>但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了</li><li>那么就相当于判断标识那行代码没有起到作用</li><li>这就是删锁时的原子性问题</li><li>因为线程1的拿锁，判断标识，删锁，不是原子操作，所以我们要防止刚刚的情况</li></ul></li><li>使用lua脚本解决多条命令的原子性问题<ul><li>Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;其他参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure></li></ul></li><li>但是此时分布式锁仍然存在问题：锁不住。<ul><li>因为当锁的ttl快到期的时候，我们并没有实现续期功能。</li><li>所以得依赖redisson来解决续期问题。</li></ul></li></ul><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><ul><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题<br><img src="/../img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="可重入锁"></li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h4><ul><li>我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br><img src="/../img/%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96.png" alt="异步优化"></li><li></li></ul><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在力扣中有许多层序遍历相关的题目，但基本都是以下面这题为基础进行修改的，所以记录一下，加强理解。</p><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p></blockquote><p>  [TOC]</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>类似于图的广度优先遍历，利用队列的性质，每次先入队一个节点，然后对其进行出队，出队后判断其是否还有子节点，有子节点则再次入队，并且用for循环进行当前层级的遍历，因为当前每次进行节点出队前的deque的size就是当前层次的节点数量。</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//存储列表的列表</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//为空则返回空列表</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.add(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<span class="hljs-comment">//定义个数，用来分层</span><br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//定义每个层次的节点列表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">//用来对当前层进行操作</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                level.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><ol><li>前后序遍历：<br>前序遍历和后续遍历比较简单，类似于图的广度优先遍历。前序遍历利用栈来保存节点，当栈不为空，弹出节点，进行左右节点的判断，有的话将左右节点入栈。需要考虑一下的就是入栈和出栈的顺序问题，因为栈先进后出的特点，所以需要逆向存储，前序遍历中，本该是中左右，但是由于栈的特性，我们应该先中，右，左。而后续遍历考虑一下左右顺序并将list反转一下即可。</li><li>中序遍历：利用栈存储已经浅层次访问的节点（未进行遍历，以及右节点的判断），再利用cur指针，进行遍历，cur先深入最左底部，并存储访问的节点，如果该节点的左节点访问完全，则输出根节点，再进行右节点的访问。有点绕，具体见代码：</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;            <br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-comment">//cur!=null代表的是向左还没走完，stack!=null代表的是已经走过的节点还未完全判断访问（例如右节点）</span><br>            <span class="hljs-comment">//左节点访问：</span><br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到了最左</span><br>                stack.push(cur);<span class="hljs-comment">//存储访问过的元素</span><br>                cur = cur.left;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = stack.pop();<br>                result.add(cur.val);<span class="hljs-comment">//进行左的遍历</span><br>                cur = cur.right;<span class="hljs-comment">//这一步就决定上面需要使用else</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//先判断有无左右节点，有则反方向放入节点，如右左根</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-商户缓存</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="缓存的基本知识"><a href="#缓存的基本知识" class="headerlink" title="缓存的基本知识"></a>缓存的基本知识</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><ol><li>缓存是数据交换的缓冲区，一般从数据库中获取，存储在本地。</li><li>redis缓存:由于其被static修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被final修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build();<br></code></pre></td></tr></table></figure></li></ol><h4 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h4><ol><li>速度快</li><li>缓存数据存储在代码之中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户并发访问给服务器带来的读写压力。</li><li>实际开发之中，数据量往往很大，如果没有缓存作为“减震器”，系统很难支撑。</li><li>缓存会增加代码复杂度和运营成本。</li><li>降低后端负载，提高读写速度。</li><li>数据一致性成本，代码维护成本，运维成本。</li></ol><h4 id="商户缓存的使用"><a href="#商户缓存的使用" class="headerlink" title="商户缓存的使用"></a>商户缓存的使用</h4><ol><li>缓存作用模型：<br><img src="/../img/%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg" alt="缓存作用模型"></li></ol><h3 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h3><ol><li>什么是缓存更新<ul><li>缓存更新就是为了节约内存而设计的，因为内存数据宝贵，当向redis插入太多数据时，可能会导致缓存中数据过多，所以需要对redis中的数据进行更新，或者淘汰。</li><li>内存淘汰：当redis数据大过我们设定的max_memory时，会自动触发淘汰机制，淘汰不重要的数据（可以自己设置策略）。</li><li>超时剔除：给redis数据设置ttl（time to live），redis会将超时的数据进行删除。</li><li>主动更新：手动调用方法删除缓存，通常用来解决缓存和数据库不一致的问题。</li></ul></li><li>业务场景<ul><li>低一致需求：使用内存淘汰机制，如店铺类型的查询缓存。</li><li>高一致需求：主动更新，以超时剔除兜底，如店铺详情查询。</li></ul></li><li>缓存不一致的解决方案：<ol><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li><li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li><li>目前采用的方案：方案一<ol><li>如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来</li><li>因为更新缓存读写操作麻烦，所以直接删除缓存，等有新数据再直接写入缓存，完成更新。</li></ol></li><li>保证数据库和缓存同时成功和失败：</li></ol><ul><li>单体系统：将缓存和数据库操作放在一个事务之中。</li><li>分布式系统：利用TCC等分布式事务方案</li></ul><ol start="6"><li>数据库 缓存：<ul><li>出现问题的原因就在于，在数据库操作和缓存更新中间的时间里，可能会有其他线程进行操作。比如当线程1进行删除操作时，在更新数据库完成前，另一个线程2进来查询，发现此时缓存未命中，于是查询未更新完的数据库，写入缓存。然后线程1的更新完成了，但是此时缓存中已经被线程2以脏数据写入，此时的缓存等于并没有更新，所以此时数据库和缓存仍然不一致。<br> <img src="/../img/%E5%85%88%E7%BC%93%E5%AD%98%E5%86%8D%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="先缓存再数据库"></li><li>因为数据库操作时间长，所以先删除缓存再更新数据库，在数据操作和删除缓存之间的危险时间更长。</li><li>先操作数据库，再删除缓存<br> 线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题。<br> <img src="/../img/%E5%85%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E7%BC%93%E5%AD%98.png" alt="先数据库再缓存"></li></ul></li></ol></li></ol><h3 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透： 缓存穿透是指客户请求的数据在缓存和数据库之中都不存在，这样的请求会导致频繁的访问数据库。</p><pre><code class="hljs">1. 解决方案：缓存空对象  - 优点：实现简单，维护方便  - 缺点：额外的内存消耗，造成短期的不一致2. 布隆过滤  - 优点：内存占用少，没有多余key  - 实现复杂，可能误判</code></pre><ul><li><p>缓存空对象：当数据库和redis都没有该数据时，直接生成该数据&lt;key-“”&gt;存储到redis之中。所以有了额外的内存消耗，短期不一致是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过（因为这是插入语句，一般来说插入语句就是直接插入到数据库，然后通过key查询缓存，发现没有缓存再查询数据库，将key-value保存到redis，此时因为又存在redis，所以并不会对redis进行更新，得等到ttl过才会更新），所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了。</p></li><li><p>布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突</p></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul><li>缓存雪崩：是指在同一时间段，大量缓存的key同时失效，或者redis服务器宕机，导致大量的请求到达数据库，带来巨大的压力。</li><li>解决方案<ul><li>给不同的key添加不同的TTL，让其分批失效。</li><li>使用熔断机制，给流量设置一定阈值。</li><li>搭建redis集群（防止redis宕机）</li></ul></li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul><li>缓存击穿：与缓存雪崩类似，缓存雪崩是大规模的key失效，而缓存击穿是 一个 热点的Key（高并发访问，缓存业务重建业务复杂），有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。例如：一件抢购中的商品的key失效。</li><li>解决方案：<ul><li>互斥锁</li><li>逻辑过期</li></ul></li><li>互斥锁：利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题，线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。<br><img src="/../img/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"><ul><li>逻辑过期：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案<br>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据<br>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据。<br><img src="/../img/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png" alt="逻辑过期"></li></ul></li><li>互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响</li><li>逻辑过期方案：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦。<style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-登录注册实现</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="整体思维框架"><a href="#整体思维框架" class="headerlink" title="整体思维框架"></a>整体思维框架</h3><h3 id="基于Redis优化session来进行短信登陆"><a href="#基于Redis优化session来进行短信登陆" class="headerlink" title="基于Redis优化session来进行短信登陆"></a>基于Redis优化session来进行短信登陆</h3><h4 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h4><ol><li>发送验证码<br>首先根据用户的手机号进行判断，是否合法，合法则可以进行发送验证码。通过session进行保存。</li><li>通过验证码进行登录，注册<br>通过实体LoginFormDTO，封装手机号，验证码，密码（暂时只考虑手机号和验证码），先进行手机号合法性的判断，合法再判断手机号和验证码是否与session中存储的一致。</li></ol><hr><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：当客户端访问某一个地址时，会将请求交给服务器进行处理，在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理，在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息，浏览器在接受响应后会按照cookie信息在客户端简历cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="/../img/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 </li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="/../img/session%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li>cookie和session的比较：<ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="/../img/cookie%EF%BC%8Csession%EF%BC%8C%E4%BB%A4%E7%89%8C%E5%AF%B9%E6%AF%94.png" alt="Alt text"></li></ul></li></ul><hr><ol><li>校验登陆状态，实现拦截<br>用户在进行请求时，会从cookie中携带JsessionId到服务端，服务端通过JsessionId从session中获取信息，没有session信息则进行拦截，有session信息则将用户信息保存到threadLocal中，并放行。<br>拦截器的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2. 获取session中的用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4. 不存在，则拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        <span class="comment">//6. 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Redis优化登录注册"><a href="#Redis优化登录注册" class="headerlink" title="Redis优化登录注册"></a>Redis优化登录注册</h4><ol><li>为什么需要优化？<br>因为session是存储在服务器之中的，所以当有多台tomcat时，会出现session共享问题，比如用户第一次访问了tomcat1，第二次访问了tomcat2，那么tonmcat2中肯定没有存放用户的session信息，所以此时登录拦截会出现问题。不改变session存储的解决方案有：将完整session拷贝到每一台tomcat中，并且及时同步，这就带来了两个问题：<ol><li>每个tomcat都有完整session，会造成服务器压力过大。</li><li>拷贝session数据时，可能会出现延迟。</li><li>所以我们使用redis进行实现，因为redis本身就是可以共享的。</li></ol></li><li>redis实现</li><li>设计key</li></ol><ul><li>由于redis全局共享，所以我们需要设计不重复，不暴露信息的key。可以直接让后台生成token进行业务。</li></ul><ol><li>登录后，根据手机号查询判断是否有用户信息 ，无则新建，将用户数据保存到redis，生成token作为key。有则进行校验，根据token判断数据是否存在。不存在则拦截，存在则将用户信息保存到threadLocal，并放行（token也存在请求头中）。</li><li>拦截器通过判断threadLocal是否为空进行判断拦截还是放行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="comment">//校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验验证码（从redis中）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();<span class="comment">//获取用户输入的code</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCode==<span class="literal">null</span>||!cacheCode.toString().equals(code))&#123;</span><br><span class="line">        <span class="comment">//不一致则报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);<span class="comment">//(user接收，便于保存)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存信息到redis</span></span><br><span class="line">    <span class="comment">//随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">    <span class="comment">//将user对象转为hash存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);</span><br><span class="line">    <span class="comment">//设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//返回token</span></span><br><span class="line">    <span class="comment">//session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>登录刷新问题<br>- 通过拦截器查看用户是否在操作，如果没有操作超过30分钟，删除token，用户重新登录<br>- 通过查看请求，如果请求头中有token，那么我们刷新token存活时间。<br>- 拦截器优化：在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br>   <img src="/../img/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96.png" alt="Alt text"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取请求头之中的token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于token获取redis中的用户（get是根据key以及字段取值，entries是根据key取值）</span></span><br><span class="line">    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash()</span><br><span class="line">            .entries(token);</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (userMap == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将查询到的hash数据转为userDTO</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap,<span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//将userDTO信息保存到threadLocal</span></span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    <span class="comment">//刷新token的有效期</span></span><br><span class="line">    stringRedisTemplate.expire(token,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-26记事</title>
    <link href="/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：闲来无聊，本应该是记单词的时间，但是又想练习打字，于是开始用电脑码一下今天的日记吧</p><h3 id="学习状态总结"><a href="#学习状态总结" class="headerlink" title="学习状态总结"></a>学习状态总结</h3><p>总体可以给自己打分80吧，今天又没去上课，在宿舍学习，效率一般，任务完成度还行，但是吸收的并不多，也进行了运动，下面是今日的统计情况，累计时长接近9小时</p><h4 id="23年09月26日"><a href="#23年09月26日" class="headerlink" title="23年09月26日"></a>23年09月26日</h4><blockquote><p><strong>08:00至09:58 【redis学习】  1小时58分钟</strong></p></blockquote><p>&emsp;redisson 联锁，可重用锁，</p><blockquote><p><strong>10:20至11:31 【redis学习】  1小时11分钟</strong></p></blockquote><p>&emsp;秒杀优化 异步下单，阻塞队列</p><blockquote><p><strong>14:30至15:50 【redis学习】  1小时20分钟</strong></p></blockquote><p>&emsp;调傻逼bug，总算解决了，但是不知道原因</p><blockquote><p><strong>15:50至17:30 【leetcode刷题】  1小时40分钟</strong></p></blockquote><p>&emsp;一道半力扣，小颓废唉</p><blockquote><p><strong>19:15至20:42 【redis学习】  1小时27分钟</strong></p></blockquote><p>&emsp;redis消息队列看完，不过没咋吸收全是api，语法</p><blockquote><p><strong>20:42至20:55 【leetcode刷题】  13分钟</strong></p></blockquote><p>&emsp;三道sql</p><blockquote><p><strong>20:55至22:00 【运动健身】  1小时5分钟</strong></p></blockquote><p>&emsp;引体，弯举，划船，卷腹</p><h3 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h3><p>自己这段时间还是太焦虑和着急了，基于求成进度，想快速的学完java进行实习，这样使自己草草的看完视频，码一下代码就安慰自己是学完了，说实话这真的是致命毒药，因为做项目的关键在于去面试找工作，面试官拷打你的项目的时候就是直接根据项目的技术栈来进行询问的，如果你回答不上来那么等于是没做，所以我现在的改变我的心态，必须吃透项目，并且看完一章节后根据网上资料以及ppt进行总结归纳，不要急于求成，每天起码画两三个小时去总结。<br>关于自己实习的问题也不能着急，你现在如果去一个垃圾小厂实习的话，一是可能学不到东西，赚不到钱，还有挂科的风险，并且最主要的是浪费了时间，这学期应该好好静下心来，学习java（redis，mq，sprincloud等），学习计网，还有备战六级，并且反复刷leetcode，最后一两个月，差不读学习完springcloud课程之后再进行八股，准备面试以及期末考试。<br>好吧就这样吧，加油，睡觉了！</p><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配下标-KMP算法</title>
    <link href="/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：尽管之前大二学数据结构我就学过kmp，但是由于这个算法比较复杂，并且自己划水一年，所以基本上是新学差不多，今天花了接近三个小时，重新梳理一下kmp的思路，以及注意事项。</p><p>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><ol><li>根据前后缀来进行快速匹配，使得不需要使用两个for循环来进行匹配，如图 <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="使用前后缀匹配" title="Magic Gardens"></li><li>如何进行匹配呢，我们借助next数组，next数组是一个和字串长度相等的int数组，相应的存储以该节点为后缀的最大公共前后缀长度，什么是公共前后缀呢？例如：aabaa字串的公共前后缀就是a,aa，所以其最大长度为2。</li><li>那么next数组如何发挥作用呢，我们依次匹配串，当有冲突时，我们利用next进行回溯，回溯到的位置就是 next[冲突位置索引-1] ，为什么呢，我们可以举一个例子，比如 串 a a b a a f，对应的next数组为0 1 0 1 2 0，当父串为：a a b a a b a a f,我们可以知道当匹配到父串的第二个b时会有冲突，所以回溯，根据next，父串指针不动，字串指针回溯到next[indexOf(‘f’)-1]即2，所以我们再次从子串的第一个b开始匹配。</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next,String s)</span>&#123;<br>    <span class="hljs-comment">//初始化 j 以及 next数组</span><br>    <span class="hljs-comment">//i：后缀末尾   j：前缀末尾</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length();i++)&#123;<span class="hljs-comment">//对于每一个后缀的结尾</span><br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))&#123;<span class="hljs-comment">//判断是否前后缀相等</span><br>            j = next[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//不匹配则 j 回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>    <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>    getNext(next,needle);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>        <span class="hljs-comment">//关键此处的 while和下面的if不能交换顺序！！</span><br>        <span class="hljs-comment">//反例如 父串 sads 子串 sad</span><br>        <span class="hljs-comment">//若是if(==)在前，当第一个匹配 s时，j++，此时i还没有++，所以在进行接下来的while时会进入while导致bug</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) <span class="hljs-comment">//不匹配则查找不匹配字符的前一个位置的next值，进行回溯</span><br>            j = next[j - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) <span class="hljs-comment">//匹配则两个指针同时后移，进行下一个的匹配</span><br>            j++;<br>        <span class="hljs-keyword">if</span> (j == needle.length()) <br>            <span class="hljs-keyword">return</span> i - needle.length() + <span class="hljs-number">1</span>;<span class="hljs-comment">//返回子字符串在父字符串中的匹配位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的单词</title>
    <link href="/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体思路为：整体的字符反转，字符中额外空格的删除，字符单词反转</p><p>字符反转很简单，使用双指针即可<br>删除字符中的额外空格有点麻烦，可以使用双指针（参考之前的数组移除元素），具体思路如下：定义快慢指针，用快指针遍历数组，当快指针指向非目标值时，将快指针的内容拷贝到慢指针处，然后fast++，slow++。主要留心中间空格以及两端空格的处理。<br>字符单词反转不麻烦但是得考虑全。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">char</span>[] sChars = s.toCharArray();<br>      <span class="hljs-comment">//字符串整体反转</span><br>      reverse(sChars,<span class="hljs-number">0</span>,sChars.length-<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//去除额外空格</span><br>      sChars = removeExtraSpace(sChars);<br>      <span class="hljs-comment">//单词内反转</span><br>      reverseEachWord(sChars);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sChars);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt;= chars.length; end++) &#123;<span class="hljs-comment">//便于让end总是指向每一个单词的末尾</span><br>          <span class="hljs-keyword">if</span>(end == chars.length || chars[end] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>              reverse(chars,start,end-<span class="hljs-number">1</span>);<br>              start = end + <span class="hljs-number">1</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] removeExtraSpace(<span class="hljs-type">char</span>[] chars)&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; chars.length; fast++) &#123;<br>          <span class="hljs-keyword">if</span> (chars[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<span class="hljs-comment">//整体为去除空格模板</span><br>              <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在非首位的每个单词后面添加一个空格</span><br>                  chars[slow] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                  slow ++;<br>              &#125;<br>              <span class="hljs-keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] !=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                  <span class="hljs-comment">//删除所有空格</span><br>                  <span class="hljs-comment">//将快指针的内容（非空格的字母）赋值给慢指针</span><br>                  chars[slow] = chars[fast];<br>                  slow++;<br>                  fast++;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//同时slow也就是到达了最后的有效位置，slow的大小就是处理完后的数组大小。</span><br>      <span class="hljs-type">char</span>[] newChar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[slow];<br>      <span class="hljs-comment">//数组拷贝，System.arraycopy(拷贝数组, 起始索引, 新数组, 起始索引, 拷贝长度); </span><br>      System.arraycopy(chars, <span class="hljs-number">0</span>, newChar, <span class="hljs-number">0</span>, slow); <br>      <span class="hljs-keyword">return</span> newChar;<br>  &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> end)</span>&#123;<br>      <span class="hljs-type">char</span> tmp;<br>      <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>          tmp = chars[start];<br>          chars[start] = chars[end];<br>          chars[end] = tmp;<br>          start ++;<br>          end --;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
