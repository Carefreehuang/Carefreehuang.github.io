<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络-网络层</title>
    <link href="/2023/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2023/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><ul><li>网络层的作用：<ul><li>网络层的主要任务就是<strong>将分组从源主机经过多个网络和多段链路传输到目的主机</strong>，可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。<ul><li>分组转发：根据转发表来确定向自己的哪个接口进行转发（转发表来自路由表）</li><li>路由选择：路由表来自<strong>路由选择协议</strong></li></ul></li></ul></li><li>网络层向上提供的两种服务：<ul><li><p>面向连接的虚电路服务<br><img src="/../img/%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1.png"> </p><ul><li>核心思想：<strong>可靠通信应由网络自身来保证</strong></li><li>必须首<strong>先建立网络层连接</strong>，保证通信双方所需的一切资源</li><li>通信双方沿着<strong>已经建立的虚电路</strong>发送分组</li><li>通信结束后，需要<strong>释放</strong>之前建立的虚电路</li><li>类似于在双方的网络层之间添加了一条“电话线”，不过是通过链路，路由器来模拟的。</li><li>表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li></ul></li><li><p>无连接的数据报服务<br><img src="/../img/%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png"> </p><ul><li>核心思想：<strong>可靠通信应由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li>每个分组可以走<strong>不同的路径</strong>，因此，每个分组的首部<strong>必须携带目的主机的完整地址</strong></li><li>通信结束后，<strong>没有需要释放的连接</strong></li></ul></li></ul></li></ul><h3 id="网际协议（IP）"><a href="#网际协议（IP）" class="headerlink" title="网际协议（IP）"></a>网际协议（IP）</h3><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>为什么要有IP以及其作用是什么？<ul><li>为什么?<ul><li>网络互联时<strong>结构各不相同</strong>，要将众多的异构型网络都互联，并且要让其可以进行<strong>互相通信</strong>，则会面临许多需要解决的问题：如网络接入机制，差错恢复方法，寻址方案等</li></ul></li><li>作用：<br><img src="/../img/ip%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8.png"><ul><li>IP协议使得网络层可以<strong>屏蔽底层细节</strong>而专注网络层的数据转发  </li><li>当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们<strong>看不见互连的各网络的具体异构细节</strong>。</li></ul></li></ul></li></ul><h4 id="IPv4地址及其编制方法"><a href="#IPv4地址及其编制方法" class="headerlink" title="IPv4地址及其编制方法"></a>IPv4地址及其编制方法</h4><ul><li>IPv4地址概述<ul><li>IPv4地址是给因特网（Internet）上的<strong>每一个主机（或路由器）的每一个接口分配的</strong>一个在<strong>全世界范围内唯一</strong>的32比特的标识符。</li></ul></li><li>IPv4表示方法<ul><li>由于IPv4地址由32比特构成，不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</li></ul></li><li>IPv4地址的分类编址方法<ul><li>32比特的IPv4地址分为：<strong>网络号</strong> + <strong>主机号</strong></li><li>网络号<ul><li>标志主机（或路由器）的接口所<strong>连接到的网络</strong></li><li>同一个网络中，<strong>不同主机（或路由器）的接口</strong>的IPv4地址的<strong>网络号必须相同</strong>，表示它们属于同一个网络。</li></ul></li><li>主机号<ul><li>标识主机（或路由器）的接口号</li><li><strong>同一个网络</strong>中，<strong>不同</strong>主机（或路由器）的接口的IPv4地址的主机号必须各不相同，以便<strong>区分各主机（或路由器）的接口</strong>。</li></ul></li><li>分类：<br><img src="/../img/IPv4%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png"><ul><li>分为A,B,C,D,E，差异见图</li><li>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</li><li>主机号为 <strong>“全0”</strong> 的地址是<strong>自身的网络地址</strong>（标识本网络），不能分配给主机（或路由器）的各接口。</li><li>主机号为 <strong>“全1”</strong>的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</li><li><img src="/../img/A%E7%B1%BB%E5%9C%B0%E5%9D%80.png"></li><li><img src="/../img/B%E7%B1%BB%E5%9C%B0%E5%9D%80.png"></li><li><img src="/../img/C%E7%B1%BB%E7%BD%91%E7%BB%9C.png"></li></ul></li><li><img src="/../img/%E5%90%84%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%AF%B9%E6%AF%94.png"></li></ul></li></ul><h4 id="Ipv4地址划分子网编址方法"><a href="#Ipv4地址划分子网编址方法" class="headerlink" title="Ipv4地址划分子网编址方法"></a>Ipv4地址划分子网编址方法</h4><ul><li>为什么？<ul><li>随着更多的中小网络加入因特网，<strong>IPv4分类编址方法</strong>不够灵活、容易造成<strong>大量IPv4地址资源浪费</strong>的缺点就暴露出来了。</li><li>例如一个只有几个接口的网络申请一个A类地址，一个A类地址可以包含数千万接口，但只使用了几个，造成大量浪费。<br><img src="/../img/%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E6%B5%AA%E8%B4%B9.png"></li></ul></li><li>子网<ul><li>子网就是前几位都相同，然后中间使用几位来划分子网，然后后几位再分配给设备接口。</li><li>如145.13.<strong>0</strong>.20和145.13.<strong>1</strong>.20，两者都是网络 145.13 以及用户接口 20，但是是不同子网 0,1，<strong>网络号+子网号+用户号</strong></li><li>子网地址其实属于网络地址</li></ul></li><li>子网掩码<ul><li>产生原因<ul><li>我们如何从网络地址中区分出子网地址在哪里？又是多少位呢？</li></ul></li><li>作用<ul><li><strong>子网掩码</strong>可以表明分类IPv4地址的主机号部分<strong>被借用了几个比特</strong>作为子网号。</li></ul></li><li>与IPv4地址类似，子网掩码也是由32比特构成的。<ul><li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li><li>之后的多个连续的比特0对应IPv4地址中的主机号。</li></ul></li><li>子网计算：<ul><li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，就可得到该IPv4地址所在子网的网络地址。<br><img src="/../img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BD%91%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80.png"><br><img src="/../img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%BE%8B%E9%A2%98.png"></li></ul></li></ul></li></ul><h4 id="Ipv4无分类编址方法"><a href="#Ipv4无分类编址方法" class="headerlink" title="Ipv4无分类编址方法"></a>Ipv4无分类编址方法</h4><ul><li>起因：<ul><li>IPv4地址的划分子网编址方法在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网(𝟐^(𝟐𝟒−𝟑)&#x3D;𝟐𝟎𝟗𝟕𝟏𝟓𝟐)由于其每个网络所包含的地址数量太小(𝟐^𝟖&#x3D;𝟐𝟓𝟔)，因此并没有得到充分使用，而因特网的IPv4地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li><li>为此，因特网工程任务组IETF又提出了<strong>采用无分类编址</strong>的方法，来解决IPv4地址资源紧张的问题，同时还专门成立IPv6工作组负责研究新版本的IP，以彻底解决IPv4地址耗尽问题。</li><li>1993年，因特网工程任务组IETF发布了<strong>无分类域间路由选择（Classless Inter-Domain Routing，CIDR ）</strong>的RFC文档[RFC1517~1519，RFC1520]。<ul><li>CIDR消除了传统A类、B类和C类地址以及划分子网的概念。</li><li>CIDR可以更加有效地分配IPv4地址资源，并且可以在IPv6使用之前允许因特网的规模继续增长。</li></ul></li></ul></li><li>构成<ul><li>无分类编址方法使用的<strong>地址掩码</strong>与划分子网使用的<strong>子网掩码</strong>类似，由32比特构成。<ul><li>左起连续比特1为对应的网络前缀</li><li>之后的连续比特0为对应的主机号<br><img src="/../img/%E6%97%A0%E5%88%86%E7%B1%BB%E6%8E%A9%E7%A0%81%E7%A4%BA%E4%BE%8B.png"></li></ul></li><li>为了简便起见，<strong>可以不明确给出配套的地址掩码的点分十进制形式</strong>，而是在无分类编址的IPv4地址后面<strong>加上斜线“&#x2F;”</strong>，在斜线之后写上网络前缀所占的比特数量（也就是地址掩码中左起连续比特1的数量），这种记法称为<strong>斜线记法</strong>。如：<strong>128.14.35.7 &#x2F; 20</strong>，则标识网络前缀是前20比特，主机号是32-20 &#x3D; 12比特</li></ul></li><li>好处<ul><li>使用无分类编址方法，可以根据客户的<strong>需要分配适当大小的CIDR地址块</strong>，因此可以更加有效地分配IPv4的地址空间。（因为主机号确定了用户数量，根据自定义的地址掩码，也可以操作主机号大小）</li><li>使用无分类编址方法的另一个好处是<strong>路由聚合</strong>（也称为构造超网）。 <ul><li>路由聚合就是：找到最大前缀<br><img src="/../img/%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88.png"></li></ul></li></ul></li></ul><h4 id="IPv4地址与MAC地址"><a href="#IPv4地址与MAC地址" class="headerlink" title="IPv4地址与MAC地址"></a>IPv4地址与MAC地址</h4><ul><li><p>IPv4地址与MAC地址的封装位置<br><img src="/../img/Ip%E5%9C%B0%E5%9D%80%E4%B8%8Emac%E5%9C%B0%E5%9D%80%E7%9A%84%E5%B0%81%E8%A3%85.png"></p></li><li><p>数据报传送过程中IPv4地址与MAC地址的变化情况<br>  <img src="/../img/%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E9%80%81ipmac%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png"></p><ul><li>在数据报的传送过程中，数据报的<strong>源IP地址和目的IP地址保持不变</strong>。</li><li>在数据报的传送过程中，数据报的<strong>源MAC地址和目的MAC地址逐链路（或逐网络）改变</strong>。</li></ul></li><li><p>IPv4地址与MAC地址的关系</p><ul><li>如果仅使用MAC地址进行通信，则会出现以下主要问题：<ul><li>每台<strong>路由器的路由表</strong>中就必须记录因特网上<strong>所有</strong>主机和路由器各接口的MAC地址。</li><li>手工配置表几乎不可能完成，路由表中<strong>海量的MAC地址信息会严重占用通信资源</strong>。</li><li>查找转发表也会带来极大的时延。</li></ul></li><li>因特网的网际层使用<strong>IP地址进行寻址</strong>，就可使因特网中各路由器的路由表中的路由记录的数量大大减少，因为<strong>只需记录部分网络的网络地址</strong>，而不是记录每个网络中各通信设备的各接口的MAC地址。<ul><li>路由器收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的<strong>路由表进行查表转发</strong>。</li><li>查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但<strong>无法指明该IP地址所对应的MAC地址</strong>。</li><li>根据地址解析协议ARP来解决</li></ul></li></ul></li></ul><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><ul><li>地址解析协议ARP<ul><li>根据IP地址获取目标MAC地址</li></ul></li><li>过程<br>  <img src="/../img/arp%E5%8D%8F%E8%AE%AE%E8%BF%87%E7%A8%8B.png"><ul><li>如果a要发送数据报给b<ul><li>a会知道b的ip地址，但是不知道b的mac地址（在自身的arp高速缓存表中查找不到），在数据链路层封装mac帧时会无法填写目的mac地址</li><li>a会向网络发起广播（我是a，我的ip地址是ip-a，我的mac地址是mac-a，我想知道ip-b的mac地址）</li><li>其他设备收到广播后会进行解析，如果与广播中请求的ip地址符合则会接收并且返回，否则不予理会。</li><li>b会接收报文，将a的ip地址以及mac地址存到自己的arp告诉缓存表，并且给a发送arp相应，告知其自己的mac地址</li></ul></li><li>arp包含字段：IP地址、MAC地址以及类型（动态，静态）<ul><li>静态一般是手工配置</li><li>动态一般有生命周期（2分钟）<ul><li>因为ip地址和mac地址不总是一成不变，更换网卡，mac地址就改变了</li></ul></li></ul></li></ul></li></ul><h4 id="IP数据报的发送与转发"><a href="#IP数据报的发送与转发" class="headerlink" title="IP数据报的发送与转发"></a>IP数据报的发送与转发</h4><ul><li>流程<ul><li>主机发送IP数据报<ul><li>在同一个网络中就直接交付，不同网络中间接交付</li><li>源主机如何判断出目的主机是否与自己在同一个网络中？<ul><li>c转发给不同网络的f，c知道f的ip地址，根据分类掩码，将自己的网络前缀和f的对比，查看是否相同（是否属于同一个网络）</li></ul></li><li>交给哪个路由器转发呢？<ul><li>实际上，用户为了让本网络中的主机，能和其它网络中的主机进行通信，就必须给其<strong>指定本网络中的一个路由器</strong>，由该路由器帮忙进行转发，所指定的路由器，也被称为默认网关（就是一个保安）</li><li>这样，当本网络中的主机要和其它主机进行通信时，会将IP数据报传输给默认网关。由默认网关帮主机将IP数据报转发出去。</li></ul></li></ul></li><li>路由器转发IP数据报<ul><li>那么路由器收到IP数据报之后又是如何转发的呢？<ul><li>检查IP数据报首部是否出错：若出错，丢弃并告诉源主机，<strong>没错就转发</strong>。</li><li>根据IP数据报的目的地址在<strong>路由表中找匹配的记录</strong>，找到就转发给下一个该转发的，找不到就丢弃该IP数据报并告诉主机你这个我转发不了。</li><li>路由器不会转发广播</li></ul></li></ul></li></ul></li></ul><h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h4><p><img src="/../img/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><ol><li>**版本(4bit)**：指明了IP协议的版本，IPv4还是IPv6；通信双方的版本要一致</li><li>**首部长度(4bit)**：指明了IP数据报头部的长度，以4字节为单位（和TCP数据报中的数据偏移字段类似）</li><li>**可选字段(1~40字节)**：可增加一些拓展功能，但很少使用，该字段的拓展直接影响了首部长度字段</li><li><strong>填充字段</strong>：IP数据报头部的长度要求是4的整数倍，因此需要该字段填充补0，使头部满足要求</li><li>**区分服务(1字节)**：一般不使用，用于提供不同等级的服务质量</li><li>**总长度(2字节)**：指明了整个IP数据报的长度,以字节为单位，首部长度换算成字节后，总长度 - 首部长度 &#x3D; 数据载荷的长度</li><li><strong>标识、标志、片偏移</strong>：这三个字段共同说明了IP的分片情况<ul><li>标识：16bit，就是一个数字；属于同一个IP数据报的子分片有相同的标识；IP协议栈维持一个计数器，每产生一个数据报，就将标识值加1，然后赋值给标识字段</li><li>标志：3bit，分别是DF、MF、保留位<ul><li>DF：DF&#x3D;1表示不允许分片，DF&#x3D;0表示允许分片</li><li>MF：MF&#x3D;1表示后边还有分片，MF&#x3D;0表示后边没有分片，这就是最后一个分片</li><li>保留位：暂不使用，为0</li><li>片偏移：13bit，以8字节为单位，这也就要求：如果要分片，只要不是最后一个IP片，其数据载荷长度都必须是8的倍数；该字段指明了分片数据报载荷部分首字节相对于其原始数据报偏移了多少字节，如第一个IP分片的数据报为原始数据载荷的0~800，那该IP分片的片偏移为0&#x2F;8&#x3D;0；第二个分片的片偏移就是800&#x2F;8&#x3D;100；</li></ul></li></ul></li><li>**生存时间TTL(Time To Live)(8bit)**：指明了IP数据报的生存时间还有多少<ul><li>当前是以跳数为单位，路由器转发IP数据报时，先将该字段减1，若不为0则转发；若为0，则表示其生存时间无了，也就是该数据包失效了，就不转发</li><li>主要是为了避免发生路由环路时，IP数据报在环路内永久兜圈</li></ul></li><li>**协议字段(8bit)**：指明了IP数据包的数据载荷部分包装的是何种协议数据单元PDU，该字段是网络层与运输层之间的接口，通过该字段的标识，可以将IP数据报正确的交给运输层的某个协议模块处理</li><li>**首部检验和(16bit)**：用于在IP报的转发、发送过程中校验IP头部。因为IP头部是动态变化的，所以该校验和也是动态变化的。这一点与TCP的校验和不同（TCP校验的是头部和数据载荷也即整个TCP报文段，且转发途中不会动态变化）</li><li>**源IP地址和目的IP地址(各占32bit，4字节)**：用于标识发送方的IP地址和接收方的IP地址，可以说是最重要的字段存在了</li></ol><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><ul><li>静态路由<ul><li>静态路由配置是指用户或者网络运维人员使用路由器的相关命令给路由器<strong>人工配置路由表</strong></li><li>人工配置方式<strong>简单、开销小</strong>、但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>，一般只在小规模网络中采用。</li></ul></li><li>默认路由<ul><li>当路由器在路由表中找不到目的地址的具体路由时，会才有用默认路由</li></ul></li><li>静态路由配置可能存在的问题<ul><li>路由条目<strong>配置错误</strong>，可能导致出现<strong>路由环路</strong></li><li>聚合路由条目时可能引入不存在的网络</li></ul></li></ul><h3 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h3><h4 id="路由选择分类"><a href="#路由选择分类" class="headerlink" title="路由选择分类"></a>路由选择分类</h4><ul><li>静态路由选择<ul><li>简单，开销小，但不能及时适应网络状态的变化</li><li>一般只能在小规模网络中使用</li></ul></li><li>动态路由选择<ul><li>动态路由：路由器通过路由选择协议<strong>自动获取</strong>路由信息</li><li>比较复杂，开销大，但是能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ul></li><li>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：<ul><li>自适应：因特网采用动态路由选择，能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li><li>分层次：<ul><li>将整个因特网划分为许多较小的<strong>自治系统（Autonomous System，AS）</strong>。</li><li>在自治系统内部和外部采用<strong>不同类别</strong>的路由选择协议，分别进行路由选择。<br><img src="/../img/%E5%88%86%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png"></li></ul></li></ul></li></ul><h4 id="路由信息协议"><a href="#路由信息协议" class="headerlink" title="路由信息协议"></a>路由信息协议</h4><ul><li>相关概念<ul><li>路由信息协议（Routing Information Protocol)是内部网关协议最先得到广泛使用的协议</li><li>RIP要求自治系统AS内的每一个路由器，都要维护从它<strong>自己到AS内其他每一个网络的距离记录</strong>。这是一组距离，称为距离向量（Distance-Vector，D-V）。</li><li>RIP使用跳数（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。<ul><li>RIP将路由器到直连网络的距离定义为1。</li><li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>RIP允许一条路径最多只能包含15个路由器，距离等于16时相当于不可达。因此RIP只适用于小型互联网。</li></ul></li></ul></li><li>工作流程<ol><li>路由器刚开始工作时，只知道自己到直连网络的RIP距离为1。</li><li>每个路由器仅和相邻路由器周期性的交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本自治系统AS内各网络的最短距离和下一跳路由器，称为收敛。</li></ol></li><li>问题<ul><li>坏消息传播得慢</li><li>当线路故障的消息没有及时更新的时候，一些路由器会被另一些可达的未更新的路由器所误导，导致故障信息传播的十分缓慢。</li><li>优化<ul><li>限制距离</li><li>即时更新，而不是周期性更新</li></ul></li></ul></li></ul><h4 id="开放最短路径优先协议"><a href="#开放最短路径优先协议" class="headerlink" title="开放最短路径优先协议"></a>开放最短路径优先协议</h4><ul><li>概念<ul><li>开放最短路径优先（Open Shortest Path First，OSPF）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的。</li><li>使用了迪杰斯特拉的最短路径算法</li><li>通过相邻路由器之间的互相问候分组，来建立和维护邻居关系</li></ul></li><li>工作过程<ol><li>使用问候发现和维护邻居路由器的可达性</li><li>展示自己的数据给邻居</li><li>互相请求需要的数据</li><li>更新数据（洪泛法）类似广播</li></ol></li><li>优化<ul><li>为了使OSPF协议能够用于规模很大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围，称为区域（area）。</li><li>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统AS，这样就减少了整个网络上的通信量。<br><img src="/../img/ospf%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F.png"></li></ul></li></ul><h4 id="边界网关协议"><a href="#边界网关协议" class="headerlink" title="边界网关协议"></a>边界网关协议</h4><ul><li>概念<ul><li>边界网关协议（Border Gateway Protocol，BGP）属于外部网关协议EGP这个类别，用于<strong>自治系统AS之间</strong>的路由选择协议。</li></ul></li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由。</li></ul><h4 id="路由器的基本工作原理"><a href="#路由器的基本工作原理" class="headerlink" title="路由器的基本工作原理"></a>路由器的基本工作原理</h4><ul><li>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是<strong>转发分组</strong>。<br><img src="/../img/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></li></ul><h3 id="网际控制报文协议"><a href="#网际控制报文协议" class="headerlink" title="网际控制报文协议"></a>网际控制报文协议</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>为了<strong>更有效地转发IP数据报</strong>以及提高IP数据报交付成功的机会，TCP&#x2F;IP体系结构的网际层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）[RFC 792]。</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li><li>ICMP报文被封装在IP数据报中发送。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>差错报告报文</strong>：用来向主机或路由器报告差错情况</p><ul><li>终点不可达<ul><li>当路由器或主机不能交付IP数据报时，就向源点发送重点不可达报文。</li></ul></li><li>源点抑制<ul><li>当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li></ul></li><li>超时<ul><li>收到数据报后，若TTL结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文。</li><li>在预先规定的时间内未能收到一个数据报的全部数据报分片时，也会发送超时报文</li></ul></li><li>参数问题<ul><li>路由器检测到数据报首部误码丢弃该数据报，并且发送参数问题报文</li></ul></li><li>改变路由（重定向）<ul><li>路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样<strong>可以通过更好的路由</strong>到达目的主机。</li></ul></li></ul></li><li><p><strong>询问报文</strong>：用来向主机或路由器询问情况</p><ul><li>回送请求和回答<ul><li>用来测试目的站是否可达以及了解其有关状态。</li></ul></li><li>时间戳请求和回答<ul><li>用来进行时钟同步和测量时间。</li></ul></li></ul></li></ul><h3 id="虚拟专用网和网络地址转换"><a href="#虚拟专用网和网络地址转换" class="headerlink" title="虚拟专用网和网络地址转换"></a>虚拟专用网和网络地址转换</h3><h4 id="虚拟专用网"><a href="#虚拟专用网" class="headerlink" title="虚拟专用网"></a>虚拟专用网</h4><ul><li>虚拟专用网（Vitual Private Network）：<ul><li>我们如何让两个专用网络进行通信呢？<ul><li>直接花钱连线</li><li>使用因特网作为载体</li></ul></li><li>利用公用的因特网作文本机构和专用网之间的通信载体。</li></ul></li><li>公用网和专用网的区别是什么呢？<ul><li>公用网的ip全是公开的，专用网为了安全考虑，ip都是不公开的</li></ul></li><li>如何实现<ul><li>我们需要在两个专用网中分别使用一个路由器，路由器可以连接公网</li><li>将专网的内部ip加密封装到数据报之中，通过路由器转发到公网</li><li>转发的地址是目的专网的路由器的公网地址</li><li>目的专网收到之后，进行解析即可</li></ul></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><ul><li><p>为什么需要？</p><ul><li>主要解决IPv4地址紧缺的问题，通过将<strong>一个公网IP地址和多个私网IP</strong>相对应，从而解决IP地址不够用的情况</li></ul></li><li><p>如何实现</p><ul><li>使用NAT软件，并且至少有一个有效的全球地址ip</li><li>当私网通过NAT时，会将其转换为公网在因特网传输<br><img src="/../img/NAT%E8%BF%87%E7%A8%8B.png"></li></ul></li><li><p>优化:网络地址与端口号转换方法</p><ul><li>由于目前绝大多数基于TCP&#x2F;IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，为了更加有效地利用NAT路由器中的全球IP地址，现在常将NAT转换和运输层端口号结合使用。<ul><li>这样就可以使内部专用网中使用专用地址的大量主机，共用NAT路由器上的1个全球IP地址，因而可以同时与因特网中的不同主机进行通信。<br><img src="/../img/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BD%AC%E6%8D%A2.png"></li></ul></li></ul></li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>多播（Multicast，也称为组播）是一种实现“一对多”通信的技术，与传统单播“一对一”通信相比，多播可以极大地节省网络资源。</li><li>在因特网上进行的多播，称为IP多播。<br><img src="/../img/ip%E5%A4%9A%E6%92%AD.png"></li><li>可以减少网络中资源的消耗</li></ul><h4 id="IP多播地址和多播组"><a href="#IP多播地址和多播组" class="headerlink" title="IP多播地址和多播组"></a>IP多播地址和多播组</h4><ul><li>在IPv4中，<strong>D类地址</strong>被作为多播地址。</li><li><strong>多播地址只能用作目的地址</strong>，而不能用作源地址。</li><li>一个多播地址确定一个多播组</li></ul><h4 id="局域网上进行硬件多播"><a href="#局域网上进行硬件多播" class="headerlink" title="局域网上进行硬件多播"></a>局域网上进行硬件多播</h4><ul><li>硬件多播其实就是多播MAC地址，只需要把IPv4的多播地址转换为MAC地址即可</li><li>由于IP多播地址可变化的28比特的前5个比特无法映射到MAC多播地址，<strong>这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的</strong>。<ul><li>所以在链路层判断MAC地址正确后，还会将数据上传至网络层，进行IP地址的判断，从而确定正确的传输</li></ul></li></ul><h4 id="因特网上进行IP多播需要的两种协议"><a href="#因特网上进行IP多播需要的两种协议" class="headerlink" title="因特网上进行IP多播需要的两种协议"></a>因特网上进行IP多播需要的两种协议</h4><ul><li>引出<ul><li>要在因特网上进行IP多播，<strong>要考虑IP多播数据报经过多个多播路由器进行转发的问题</strong>。<ul><li>多播路由器必须根据IP多播数据报首部中的IP多播地址，将其转发到有该多播组成员的局域网。</li></ul></li><li>那么路由器如何知道自己的接口所在局域网有哪些多播成员呢？<ul><li>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。</li><li>需要使用多播路由选择协议来解决</li></ul></li></ul></li><li>多播路由选择协议<ul><li>过程<ul><li>主要任务是：在多播路由器之间为每个多播组建立一个多播转发树</li><li>多播转发树连接多播源和所有拥有该多播组成员的路由器。</li><li>IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器。</li><li>之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员。</li></ul></li></ul></li><li>网际组管理协议（IGMP）：维护多播组与其成员关系<ul><li>报文类型<ul><li>成员报告报文</li><li>成员查询报文</li><li>离开组报文</li></ul></li><li>加入多播组<ul><li>发送成员报告报文申请加入</li></ul></li><li>监听多播组成员变化<ul><li>多播路由器定时发送成员查询报文（广播）</li><li>成功接收到报文的组员会延时随机时间后发送请求（成员报告报文），</li><li>如果该组有一个成员（延时最短的）已经发送报告报文了，那么该组其他的成员就取消发送，这样可以减少资源浪费</li><li>长时间未收到响应，会将该组从多播组中删除</li></ul></li><li>退出多播组<ul><li>当主机要退出某个多播组时，可<strong>主动发送</strong>一个离开组报文而不必等待多播路由器的查询。</li><li>这样可使多播路由器能够更快地发现某个组有成员离开。</li></ul></li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>背景<ul><li>IPv4不够用</li></ul></li><li>变化<ul><li>IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。</li><li>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</li><li>更大的地址空间</li><li>扩展的地址层次结构，灵活的首部等</li><li>IPv6 的地址主要有以下类型地址：<ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul></li></ul></li></ul><h4 id="IPv6数据报的首部"><a href="#IPv6数据报的首部" class="headerlink" title="IPv6数据报的首部"></a>IPv6数据报的首部</h4><p><img src="/../img/ipv4%E5%AF%B9%E6%AF%94ipv6.png"></p><ul><li>取消了首部校验和字段。</li><li>取消了分片&#x2F;重新组装相关字段。</li><li>取消选项字段。</li></ul><h4 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h4><ul><li>使用双协议栈<ul><li>使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li><li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li><li>根据需要进行转换</li><li>会漏一些信息</li></ul></li><li>使用隧道技术<ul><li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li><li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-物理层</title>
    <link href="/2023/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2023/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul><li>物理层关注的是如何在连接各种计算机的传输媒体上传输数据。</li><li>物理层的任务是尽可能的<strong>屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异</strong><ul><li>为什么要进行屏蔽呢？<ul><li>不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。</li><li>所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。</li><li>简单来说就是：物理层使不同设备不同条件 的情况下让上层感受不到差异，因此使得不需要“因地制宜”。</li></ul></li></ul></li></ul><h3 id="物理层之下的传输媒体"><a href="#物理层之下的传输媒体" class="headerlink" title="物理层之下的传输媒体"></a>物理层之下的传输媒体</h3><ul><li><p>传输媒体是计算机网络设备之间的<strong>物理通路</strong>，也称为传输介质或传输媒介。</p><ul><li>传输媒体在物理层之下，并且不包含在计算机网络体系结构之中。<br> <img src="/../img/%E5%8C%85%E5%90%AB%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="包含传输媒体结构"></li></ul></li><li><p>分类：</p><ul><li>导向型传输媒体：<ul><li>导向型传输媒体是一种物理传输媒体，它提供了一个明确的路径，以引导信号或数据传输。<ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li></ul></li></ul></li><li>非导向型传输媒体：<ul><li>也称为无线传输媒体，不提供明确的物理路径来引导信号传输。相反，它们使用无线信号（通常是电磁波或无线电波）来传输数据。<ul><li>无线电波</li><li>红外线</li><li>激光</li></ul></li></ul></li></ul></li><li><p>传输方式</p><ul><li>串行传输和并行传输：<ul><li>串行传输：<ul><li>串行传输是一种将数据位按照顺序一个接一个地传输的方式</li><li>在串行传输中，每个数据位都依次发送或接收，而且它们之间通常使用一个单独的信号线来传输。</li><li>通常用于长距离通信，因为它能够更好地保持数据的完整性，减少干扰和数据丢失的可能性。</li></ul></li><li>并行传输<ul><li>并行传输是一种同时传输多个数据位的方式。</li><li>在并行传输中，每个数据位都有自己的信号线，它们可以同时传输，因此在同一时间段内可以传输多个数据位。</li><li>并行传输同时传输多个数据位，适用于高速数据传输，但通常在短距离内使用。<br><img src="/../img/%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93%E5%92%8C%E5%B9%B6%E8%A1%8C%E4%BC%A0%E8%BE%93.png" alt="串行传输和并行传输"></li></ul></li></ul></li><li>同步传输和异步传输：<ul><li>同步传输<ul><li>同步传输是一种以固定的时间间隔或时钟信号来传输数据的方式。</li><li>在同步传输中，数据被划分为块（帧）并以固定的速率传输，通常使用一个时钟信号来同步发送和接收端的数据传输。这样，接收端知道何时开始接收和解析数据，因为它可以根据时钟信号的节奏来同步数据位。</li></ul></li><li>异步传输<ul><li>异步传输是一种在数据帧之间没有固定的时间间隔或时钟信号的传输方式。</li><li>在异步传输中，数据帧的开始和结束由特殊的控制字符（称为起始位和停止位）标识，而不是通过定期的时钟信号。</li></ul></li></ul></li><li>单向通信、双向交替通信和双向同时通信<ul><li>单向通信：</li><li>双向交替通信：</li><li>双向同时通信：<br><img src="/../img/%E5%8D%95%E5%90%91%E9%80%9A%E8%A1%8C%E7%AD%89.png" alt="单向通信等"></li></ul></li></ul></li></ul><h3 id="调制与编码"><a href="#调制与编码" class="headerlink" title="调制与编码"></a>调制与编码</h3><ul><li>调制与编码的作用<ul><li>编码：编码是将数字数据（0和1）转换为适合于传输媒体的信号的过程。</li><li>调制：调制是将数字信号转换为模拟信号（通常是电磁波）的过程。这是为了在无线通信或光纤通信等介质中传输数据。<br><img src="/../img/%E8%B0%83%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="调制与编码的作用"></li></ul></li><li>码元：在使用时间域的波形表示信号时，代表不同离散数值的<strong>基本波形</strong>称为码元。</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li>信道复用技术：<ul><li>是一种用于在通信系统中有效地共享和利用通信信道的方法。它允许多个通信设备或数据流共享同一个物理信道，从而提高了通信系统的效率和资源利用率。</li><li>就是在一条传输媒体上同时传输多路用户的信号。</li></ul></li><li>常用技术：<ul><li>频分复用：<ul><li>频分复用将频率范围划分为多个不重叠的子信道，每个子信道用于一个通信设备或数据流。每个设备在其分配的频率带宽内进行通信。</li></ul></li><li>时分复用：<ul><li>时分复用将时间划分为若干个时隙（time slots），每个时隙用于一个通信设备或数据流。多个设备按时间顺序轮流使用信道，以便在不同的时间间隙内进行通信。</li></ul></li><li>波分复用：<ul><li>WDM是光纤通信中的一种频分复用技术，它利用不同波长（颜色）的光信号来传输多个数据流。每个波长对应一个不同的通信通道。</li></ul></li><li>码分复用：<ul><li>类似于一句话可以有不同的解释，每个设备都有自己的解释理论，因此实现一句话传输多种信息（每种设备根据自己的解密方式获取一种信息）</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/13/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/13/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><h4 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h4><p>关系型数据库就是一种建立在关系模型的基础上的数据库</p><ul><li>在关系模型之中，数据被组织成表，而表又由行列组成，行代表一个记录，列代表一个属性。</li></ul><h3 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="MySQL 字段类型"></a>MySQL 字段类型</h3><p>mysql字段可以分成三大类：</p><ul><li>数值类型、字符类型、日期时间类型</li><li><img src="D:\Blog\source\img\sql字段类型.png"></li></ul><h4 id="VARCHAR-10-和VARCHAR-100-区别？"><a href="#VARCHAR-10-和VARCHAR-100-区别？" class="headerlink" title="VARCHAR(10) 和VARCHAR(100)区别？"></a>VARCHAR(10) 和VARCHAR(100)区别？</h4><ul><li>varchar(100)能存100个字符，varchar(10)只能存10个字符</li><li>但是二者所占用的存储空间一样</li><li>但是varchar(100)消耗的内存更大，因为varchar类型在内存中操作时，会被分配内存块来传递值，内存块大小与字符定义长度相关</li></ul><h4 id="DECIMAL可以存更高精度的小数"><a href="#DECIMAL可以存更高精度的小数" class="headerlink" title="DECIMAL可以存更高精度的小数"></a>DECIMAL可以存更高精度的小数</h4><h4 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="DATETIME 和 TIMESTAMP 的区别是什么？"></a>DATETIME 和 TIMESTAMP 的区别是什么？</h4><p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h4 id="NULL-和-‘’-的区别？"><a href="#NULL-和-‘’-的区别？" class="headerlink" title="NULL 和 ‘’ 的区别？"></a>NULL 和 ‘’ 的区别？</h4><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><h4 id="为什么-MySQL-不建议使用-NULL-作为列默认值？"><a href="#为什么-MySQL-不建议使用-NULL-作为列默认值？" class="headerlink" title="为什么 MySQL 不建议使用 NULL 作为列默认值？"></a>为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？</h4><p><strong>语义模糊：</strong> <code>NULL</code> 的语义是未知或缺失的值，因此在某些情况下，使用 <code>NULL</code> 作为默认值可能使列的语义变得模糊。默认值应该是具有明确定义含义的常规值，而不是表示未知的 <code>NULL</code>。</p><h4 id="Boolean类型如何表示？"><a href="#Boolean类型如何表示？" class="headerlink" title="Boolean类型如何表示？"></a>Boolean类型如何表示？</h4><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true</p><h3 id="SQL语句在MySQL中的执行过程"><a href="#SQL语句在MySQL中的执行过程" class="headerlink" title="SQL语句在MySQL中的执行过程"></a>SQL语句在MySQL中的执行过程</h3><h5 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h5><p><img src="D:\Blog\source\img\mysql基础架构.png"></p><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p><p><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p><p><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p><h5 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_student  A <span class="hljs-keyword">where</span> A.age<span class="hljs-operator">=</span><span class="hljs-string">&#x27;18&#x27;</span> <span class="hljs-keyword">and</span> A.name<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 张三 &#x27;</span>;<br><br></code></pre></td></tr></table></figure><ul><li>先连接器检查该语句是否有权限，没有权限直接返回错误信息，在8.0前 有权限则去缓存中查 询，如果有则返回，否则执行分析器步骤</li><li>通过分析器进行词法分析，并且检查语法问题，没有问题就继续执行下一步</li><li>通过优化器进行语句优化，如：先判断年纪、先判断名字，确认好方案后再进行下一步</li><li>执行器执行前还会再进行一次权限校验，判断使用的一些接口是否能行</li></ul><p>第一次的校验是：判断该用户是否有足够权限</p><p>第二次的校验是：判断执行计划的具体操作是否有足够权限：尽管用户在执行语句前有足够的权限，但在具体的执行计划中可能涉及多个表、索引，每个表可能有不同的权限要求。</p><h5 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_student A <span class="hljs-keyword">set</span> A.age<span class="hljs-operator">=</span><span class="hljs-string">&#x27;19&#x27;</span> <span class="hljs-keyword">where</span> A.name<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 张三 &#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>更新时需要记录日志，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>先查询到数据</li><li>根据查询语句进行更新，本例中就是将age设为19，然后写入数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><h5 id="MySQL底层写入数据的过程涉及到存储引擎、Redo-Log和磁盘I-O等多个方面。下面是一个基本的数据写入过程的概述："><a href="#MySQL底层写入数据的过程涉及到存储引擎、Redo-Log和磁盘I-O等多个方面。下面是一个基本的数据写入过程的概述：" class="headerlink" title="MySQL底层写入数据的过程涉及到存储引擎、Redo Log和磁盘I&#x2F;O等多个方面。下面是一个基本的数据写入过程的概述："></a>MySQL底层写入数据的过程涉及到存储引擎、Redo Log和磁盘I&#x2F;O等多个方面。下面是一个基本的数据写入过程的概述：</h5><ol><li><strong>接收客户端请求：</strong><ul><li>当客户端发送写入请求（例如插入、更新、删除数据）时，MySQL的连接管理器接收并处理请求。</li></ul></li><li><strong>查询分析器和优化器：</strong><ul><li>查询分析器解析并验证SQL语句的语法，优化器选择最佳的执行计划。</li></ul></li><li><strong>锁定和并发控制：</strong><ul><li>MySQL使用并发控制机制，例如锁，来确保事务的隔离性和一致性。在写入数据之前，必须获取适当的锁。</li></ul></li><li><strong>Redo Log记录：</strong><ul><li>在写入数据之前，相关的修改操作被记录到Redo Log中。这是为了确保在发生故障时，可以通过重新应用Redo Log来还原数据库的状态。</li><li>Redo Log的记录是追加写入的，通常是顺序写入，以减少磁盘I&#x2F;O的寻址开销。</li></ul></li><li><strong>数据写入内存缓存：</strong><ul><li>数据修改首先写入到内存中的缓存，包括Buffer Pool（用于存储数据页和索引页）和其他内存结构。</li><li>这样可以提高写入性能，因为内存的访问速度比磁盘快得多。</li></ul></li><li><strong>刷新到磁盘：</strong><ul><li>缓存中的数据被定期刷新到磁盘，以确保数据的持久性。</li><li>刷新可以通过不同的机制完成，包括后台线程、用户提交事务时的刷新等。</li></ul></li><li><strong>物理文件写入：</strong><ul><li>最终，数据被写入到磁盘上的物理文件，包括数据文件和索引文件。</li><li>存储引擎负责将数据写入适当的文件，并确保数据在物理层面的安全性。</li></ul></li></ol><h5 id="为什么要使用两个日志模块？"><a href="#为什么要使用两个日志模块？" class="headerlink" title="为什么要使用两个日志模块？"></a>为什么要使用两个日志模块？</h5><ol><li><strong>redo log（重做日志）：</strong><ul><li><strong>目的：</strong> redo log的主要目的是确保事务的持久性，即使在数据库发生故障时也能够恢复数据。</li><li><strong>使用场景：</strong> redo log是针对存储引擎的日志，在事务进行更新时，它会首先将修改操作记录到redo log中，然后再将数据修改写入磁盘。这种方式可以提高性能，因为磁盘写入是相对较慢的操作，而redo log的写入速度更快。如果数据库在写入数据到磁盘之前崩溃，可以通过重放redo log来恢复数据。</li></ul></li><li><strong>binlog（归档日志）：</strong><ul><li><strong>目的：</strong> binlog的主要目的是记录数据库的逻辑变更，而不是物理变更。它用于实现数据备份、主从复制等高级功能。</li><li><strong>使用场景：</strong> binlog记录了对数据库执行的高级语句，例如INSERT、UPDATE、DELETE等。这样的记录可以用于还原数据、进行数据备份、以及在主从复制中用于将变更传播到其他MySQL服务器。通过分发binlog，可以实现主从复制，其中一个服务器（主服务器）上的更新操作会被传递到其他服务器（从服务器）上。</li></ul></li></ol><p>简单来说：redolog实现数据库出现问题的数据恢复，而binlog实现数据库的备份和复制</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>作用：<ul><li>MySQL中的存储引擎是负责管理和操作底层数据存储的组件。存储引擎定义了如何存储、检索、更新和处理MySQL数据库中的数据。</li></ul></li></ul><h4 id="MyISAM-和-InnoDB的区别？"><a href="#MyISAM-和-InnoDB的区别？" class="headerlink" title="MyISAM 和 InnoDB的区别？"></a>MyISAM 和 InnoDB的区别？</h4><ul><li><p>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</p></li><li><p>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</p></li><li><p>MyISAM 不支持外键，而 InnoDB 支持。</p></li><li><p>MyISAM 不支持 MVCC，而 InnoDB 支持。</p></li><li><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p></li><li><p>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</p></li><li><p>InnoDB 的性能比 MyISAM 更强大</p></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>作用：构造适合查询的数据结构，实现高效的查找</li><li>优点<ul><li>提高检索效率</li><li>降低排序成本（索引本身就需要排序（树形））</li></ul></li><li>缺点<ul><li>占用空间</li><li>降低了更新表的速度（<code>insert</code>,<code>update</code>,<code>delete</code>）<ul><li>因为更新数据的时候也要对索引进行更新</li></ul></li></ul></li></ul><h4 id="实现结构"><a href="#实现结构" class="headerlink" title="实现结构"></a>实现结构</h4><p><strong>B-树和B+树</strong></p><p><img src="D:\Blog\source\img\b-树和b+树.png"></p><ul><li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p></li><li><p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</p></li><li><p>B+Tree</p><ul><li>所有数据存放在叶子节点</li><li>叶子节点形成单链表（mysql中的B+Tree进行了优化，实现了双向链表）</li><li>非叶子节点仅仅起到索引数据的作用</li></ul></li><li><p>Hash</p><ul><li>使用hashTable实现</li><li>只能实现精确查找</li><li>无法利用索引进行排序</li><li>查找效率更高</li></ul></li></ul><h4 id="为什么MySQL使用B-树结构作为索引呢？"><a href="#为什么MySQL使用B-树结构作为索引呢？" class="headerlink" title="为什么MySQL使用B+树结构作为索引呢？"></a>为什么MySQL使用B+树结构作为索引呢？</h4><ol><li><strong>有序性：</strong> 在B+树中，相邻的节点之间有顺序关系，使得范围查询可以通过按顺序遍历叶子节点链表来实现，而不需要进行额外的排序操作。</li><li><strong>顺序遍历效率高：</strong> 由于B+树的叶子节点形成有序链表，这使得顺序遍历的效率非常高。例如，在执行范围查询或执行<code>ORDER BY</code>语句时，B+树的结构使得查询引擎能够更有效地遍历索引。</li><li><strong>范围查询效率高：</strong> B+树的有序性也使得范围查询非常高效。数据库引擎可以通过在叶子节点链表上进行顺序查找，快速找到满足查询条件的数据。</li></ol><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul><li>按数据结构维度划分<ul><li>BTree索引</li><li>哈希索引</li><li>RTree索引</li><li>全文索引</li></ul></li><li>按底层存储方式划分<ul><li><p>聚集索引</p><ul><li>索引结构和数据一起存放的索引，InnoDB中的主键索引就是聚集索引，简单来说就是索引字段与行数据在一个叶子节点之中（BTree索引）<br><img src="/../img/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png"></li></ul></li><li><p>非聚集索引</p><ul><li>索引结构和数据分开放的索引，二级索引（辅助索引）就属于非聚集索引，MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。<br><img src="/../img/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></li></ul></li></ul></li><li>按照应用划分<ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li>唯一索引：加速查询 + 列值唯一（可以有NULL）<ul><li>确保字段的值的唯一性：一个字段建立了唯一索引的话，如果对其新增一个已经存在的值，那么索引会识别出来并且抛出异常。</li></ul></li><li>覆盖索引：一个索引包含了（覆盖）所有需要查询的字段</li><li>联合索引：多列值组成一个索引，用于组合搜索，效率高于单个创建多个单列索引（注意最左前缀法则）</li><li>全文索引：对文本的内容进行分词，进行搜索。（通常使用es）</li></ul></li></ul><h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><ul><li>二级索引的叶子节点存储的数据是主键，也就是说，通过二级索引，可以定位主键的位置</li><li>唯一索引，普通索引，前缀索引都属于二级索引</li><li>前缀索引：只适用于字符串类型的数据，对字段值的前几个字符创建索引，节约了空间。<ul><li>当前缀索引已经匹配后，还会进一步对完整值进行匹配，确认最终值</li></ul></li></ul><h5 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h5><ul><li><p>聚集索引： 索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</p><ul><li>优点：<ul><li><strong>查询速度快</strong>：因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作（即一次回表操作）。</li><li><strong>可以排序以及范围查找</strong></li></ul></li><li>缺点：<ul><li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。<ul><li>并且插入的时候可能会涉及到表的修改（主键不有序）</li></ul></li><li><strong>更新代价大</strong>：因为索引存储了数据，其对应列的修改也会造成索引的修改，而聚集索引中存放了整行的数据，所以修改发生的更为频繁，代价更大</li></ul></li></ul></li><li><p>非聚集索引：索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><ul><li>索引中存放指针（或者主键）等，可以查找后再进行回表查询整行数据的标识</li><li>优点：<ul><li>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</li></ul></li><li>缺点：<ul><li><strong>依赖于有序的数据</strong>:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li>很大可能<strong>需要进行二次查询（回表）</strong>： 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul></li></ul></li></ul><h5 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h5><ul><li><p>覆盖索引：索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 覆盖索引（也就是无需回表）</p></li><li><p>联合索引 ：使用表中的多个字段创建索引，就是 联合索引</p><ul><li>实现：<strong>采用多个键值的形式（第一个键相同，再对其中的第二个键排序）</strong></li><li><strong>最左前缀匹配原则</strong>：最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。<ul><li>其实只要查找时联合索引（创建时）的最左边字段存在，索引就会生效，中间跳过了某个字段，那么后面的字段索引就会失效</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建立联合索引，此时的最左侧索引就是column1，是指的创建时的索引</span><br><span class="hljs-keyword">create</span> index index_name <span class="hljs-keyword">on</span> table_name(column1,column2)<br></code></pre></td></tr></table></figure><ul><li>范围查询：联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</li></ul></li></ul><p><img src="D:\Blog\source\img\联合索引.png"></p><blockquote><p>如图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。</p><p>因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态! <em>什么意思呢？</em></p><p>从全局来看，b的值为1，2，1，4，1，2，是无序的，因此直接执行<code>b = 2</code>这种查询条件没有办法利用索引。</p><p>从局部来看，当a的值确定的时候，b是有序的。例如a &#x3D; 1时，b值为1，2是有序的状态。当a&#x3D;2时候，b的值为1,4也是有序状态。 因此，你执行<code>a = 1 and b = 2</code>是a,b字段能用到索引的。而你执行<code>a &gt; 1 and b = 2</code>时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段用不上索引。</p><p>综上所示，最左匹配原则，在遇到范围查询的时候，就会停止匹配</p></blockquote><h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul><li>不要在索引列上进行运算操作， 索引将失效</li><li>字符串类型字段使用时，不加引号，索引将失效。</li><li>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</li><li>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会<br>被用到。</li></ul><h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><ul><li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率</li></ul><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><ul><li>如果出现既有联合索引又有单列索引等这种索引重复的情况的话，MySQL会根据自己底部的优化器进行自行分析，选择使用哪种索引更优。</li><li>但是我们也能够自己提供使用索引的建议，以及强制指定</li><li>提示：<ul><li>use index</li><li>ignore index</li><li>force index<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user use index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br><br><span class="hljs-comment">-- ignore index ： 忽略指定的索引。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user ignore index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br><br><span class="hljs-comment">-- force index ： 强制使用索引。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user force index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h4><ul><li>查看执行频率：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <span class="hljs-comment">-- session 是查看当前会话 ;</span><br><span class="hljs-comment">-- global 是查询全局数据 ;</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>Explain，查看执行信息</li></ul><table><thead><tr><th>主要字段</th><th align="center">含义</th></tr></thead><tbody><tr><td>id</td><td align="center">select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>type</td><td align="center">表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td align="center">显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td align="center">实际使用的索引，如果为NULL，则没有使用索引。</td></tr></tbody></table><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h4><ul><li><p>insert</p><ul><li>如果插入多条记录的话，可以考虑如下的优化：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 批量插入优于一个一个插入</span><br><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><br><span class="hljs-comment">-- 再优化 手动控制事务</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></li><li><strong>主键顺序插入，性能高于乱序插入</strong><ul><li>顺序插入不会出现 “页分裂” 的情况</li><li>因为主键会要构造主键索引，而索引是有序的，并且存放在页之中，如果是顺序插入，该页可以存放下新的插入数据，那么直接插入即可，该页存放不下，那么开辟后一页存放即可。</li><li>如果乱序插入，那么会先找到需要插入的位置，判断该页能否插入<ul><li>如果不能插入，会开辟新页，然后将其应该插入页的后面的数据，以及本身放到新开辟页</li><li>然后修改页指针，使顺序正常<br><img src="/../img/%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A51.png"><br><img src="/../img/%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A52.png"><br><img src="/../img/%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A53.png"></li></ul></li></ul></li></ul></li><li><p>大批量插入数据</p><ul><li>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile</span><br>mysql –<span class="hljs-operator">-</span><span class="hljs-keyword">local</span><span class="hljs-operator">-</span>infile <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中</span><br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h4><ul><li>count(主键)<ul><li>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层，服务层拿到主键后，直接进行累加</li></ul></li><li>count(字段)<ul><li>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</li><li>有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li></ul></li><li>count(数字)<ul><li>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</li></ul></li><li>count(*)<ul><li>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</li></ul></li><li><strong>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count( * )，所以尽量使用 count( * )。</strong></li></ul><h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><h5 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h5><ul><li><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表<br><img src="/../img/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8.png"></p></li><li><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。<br><img src="/../img/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"> </p></li><li><p>页分裂</p><ul><li>参上</li></ul></li><li><p>页合并</p><ul><li>对数据进行删除时，不会真正的物理删除，而是会被标记，使得被标记的空间允许其他记录声明使用<br><img src="/../img/%E9%A1%B5%E5%90%88%E5%B9%B61.png"> </li><li>当删除的记录达到MERGE_THRESHOLD（默认50%），innoDB会开始寻找最近的页（前或后）来看看是否可以进行页的合并操作<br><img src="/../img/%E9%A1%B5%E5%90%88%E5%B9%B62.png"></li></ul></li></ul><h5 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h5><ul><li>满足业务的情况下，尽量降低主键的长度<ul><li>节约空间，减少页的开辟</li></ul></li><li>插入数据尽量选择顺序插入，选择自增主键<ul><li>减少页分裂现象</li></ul></li><li>业务操作时，避免对主键进行修改<ul><li>主键通常会自动创建唯一索引，用于加速数据的检索和关联操作。对主键进行频繁的修改可能导致索引的维护成本增加，并且可能会导致查询性能下降。</li></ul></li></ul><h4 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h4><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><h4 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h4><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><ul><li>一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</li></ul><h4 id="update-优化"><a href="#update-优化" class="headerlink" title="update 优化"></a>update 优化</h4><ul><li>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁(性能降低) 。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>按照锁的粒度划分，可以分成如下三类</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><ul><li>数据库备份可能用到</li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul><li>表共享读锁<ul><li>自己可以读，自己无法写</li><li>阻塞其他客户端的写，不阻塞其他客户端的读</li><li>不阻塞其他客户端加锁</li></ul></li><li>表独占写锁<ul><li>自己可以读，自己可以写</li><li>其他客户端无法读，无法写</li><li>阻塞其他加锁操作</li></ul></li><li>意向锁<ul><li>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</li></ul></li></ul><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li><li>间隙锁&amp;临键锁<ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁。（如查询数据90，但是表中只有88，92，此时会给88-92上锁，防止查询时出现修改）</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul></li></ul><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><ul><li>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</li><li>特点：<ul><li>DML操作遵循ACID（原子性，一致性，隔离性，持久性）模型，支持事务</li><li>有行级锁，提高并发访问性能</li><li>支持外键约束</li></ul></li></ul><h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p><img src="/../img/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E6%83%85.png"></p><ol><li>表空间：<ul><li>逻辑结构的最高层，每张表对应一个表空间</li><li>一个mysql实例可以对应多个表空间（即有多张表）</li><li>表空间存储记录，索引等数据</li></ul></li><li>段：<ul><li>分为数据段，索引段，回滚段</li><li>InnoDB是索引组织表，数据段就是B+树的 叶子节点，索引段就是B+树的非叶子节点</li><li>一个段里面管理了多个区</li></ul></li><li>区：<ul><li>每个区大小为1M</li><li>默认情况下，InnoDB存储引擎页的大小为16k，即一个区中有64个页</li></ul></li><li>页：<ul><li>是InnoDB存储引擎磁盘管理的最小单元，默认大小为16k</li><li>为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<ul><li>为什么要连续呢，因为通过一次性申请多个连续的区，可以增加数据在磁盘上的连续性，减少随机磁盘访问的次数，减少寻道的时间。</li></ul></li></ul></li><li>行：<ul><li>InnoDB存储引擎的数据是按行存放的</li><li>行中有三个隐藏字段<ul><li>Trx_id：记录最近操作该行的事务id，每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li><li>Row_id：当没有主键时，会自动产生rowid作为自增主键，用于创建聚集索引。</li></ul></li></ul></li></ol><ul><li>架构图：<br><img src="/../img/innodb%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></li></ul><h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5><p><img src="/../img/innodb%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"><br>内存结构主要分为四块：Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer</p><ol><li><p>Buffer Pool</p><ul><li>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，<strong>避免每次访问都进行磁盘I&#x2F;O</strong>。</li><li>Buffer Pool是主内存中的一个区域，里面缓存用于操作的真实数据</li><li>执行增删查改时，会先操作缓冲池中的数据（没有就去磁盘中加载到缓冲池），然后再一定频率将缓冲池数据刷新到磁盘，从而减少磁盘IO，加快处理速度。</li><li><strong>以页为单位：</strong><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul></li></ul></li><li><p>Change Buffer</p><ul><li>更改缓冲区（针对于非唯一二级索引页）,如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</li><li>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</li></ul></li><li><p>Adaptive Hash Index</p><ul><li>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</li></ul></li><li><p>Log Buffer</p><ul><li>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</li></ul></li></ol><h5 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h5><p><img src="/../img/innodb%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png"></p><ol><li>System Tablespace<ul><li>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。</li></ul></li><li>General Tablespaces<ul><li>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</li></ul></li><li>Undo Tablespaces<ul><li>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</li></ul></li><li>Temporary Tablespaces<ul><li>使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</li></ul></li><li>Doublewrite Buffer Files<ul><li>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</li></ul></li><li>Redo Log<ul><li>重做日志，是用来<strong>实现事务的持久性</strong>。该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</li></ul></li></ol><h5 id="双写缓冲区和-redo-log"><a href="#双写缓冲区和-redo-log" class="headerlink" title="双写缓冲区和 redo log"></a>双写缓冲区和 redo log</h5><ol><li><p><strong><code>Doublewrite Buffer</code>（双写缓冲区）：</strong></p><ul><li><strong>问题：</strong> 主要处理的是在写入数据页到磁盘时，防止由于系统崩溃导致的部分数据页写入磁盘，部分未写入的情况。</li><li><strong>解决方式：</strong> 在将数据页从内存写入磁盘之前，先将数据页的内容写入到双写缓冲区文件中。即使在系统崩溃时，部分数据页已经写入磁盘，部分写入双写缓冲区，仍然能够通过双写缓冲区进行恢复。</li></ul></li><li><p><strong><code>Redo Log</code>（重做日志）：</strong></p><ul><li><strong>问题：</strong> 主要处理的是事务的原子性和持久性，确保在系统崩溃时，能够重新应用事务的修改操作，保证事务的完整性。</li><li><strong>解决方式：</strong> 在事务进行修改操作时，将相关的修改记录到Redo Log中。在事务提交前，Redo Log的记录就已经被持久化到磁盘。即使系统崩溃，可以通过重新应用Redo Log中的记录来还原事务的修改。</li></ul><p>当系统在启动时需要进行恢复时，Redo Log中的记录通常会被重新应用到<code>Buffer Pool</code>中，而不是直接写入磁盘。</p><p>具体过程如下：</p><ol><li><strong>读取Redo Log：</strong><ul><li>在系统启动时，数据库管理系统会检查Redo Log，以确定在上一次正常关闭之前发生了哪些事务修改。</li></ul></li><li><strong>重新应用到Buffer Pool：</strong><ul><li>恢复进程会将Redo Log中的记录重新应用到<code>Buffer Pool</code>中。</li><li>在这一过程中，不是直接写入磁盘，而是将事务的修改操作在内存中的数据结构中进行重演，即在<code>Buffer Pool</code>中模拟事务的执行。</li></ul></li><li><strong>刷新到磁盘：</strong><ul><li>一旦事务的修改在<code>Buffer Pool</code>中被重演，系统会逐渐将这些修改刷新到磁盘，确保数据的持久性。</li></ul></li></ol></li></ol><p><strong>关系：</strong></p><ul><li>两者都是为了数据恢复，但面向的问题和提供的解决方案略有不同。<code>Doublewrite Buffer</code>解决了数据页写入磁盘的原子性问题，而<code>Redo Log</code>解决了事务的原子性和持久性问题。</li><li>组合使用两者，可以在系统异常时提供更加可靠的数据恢复机制，确保数据的完整性和一致性。</li></ul><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><p> 事务 是一组操作的集合，它是一个<strong>不可分割的工作单位</strong>，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败。</strong></p><ul><li><p>特性（ACID）：</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul></li><li><p>特性的实现：</p><ul><li><strong>原子性的实现：</strong><ul><li>通过事务日志的使用，MySQL能够在崩溃后通过重放Redo Log来重新应用事务的修改，或者通过Undo Log来回滚事务的修改，从而确保事务的原子性。</li></ul></li><li><strong>持久性的实现：</strong><ul><li>事务日志（Redo Log）的记录是在事务提交之前就写入磁盘的，这确保了事务的修改在数据库崩溃后能够被可靠地恢复。</li></ul></li><li><strong>一致性的实现：</strong><ul><li>事务日志的使用以及各种锁机制确保了数据库在执行事务时保持一致状态。当事务提交时，相关的修改操作会以一致的方式应用到数据库。</li></ul></li><li><strong>隔离性的实现：</strong><ul><li>隔离性由事务隔离级别来控制。MySQL通过锁机制和多版本并发控制（MVCC）来实现不同隔离级别下事务的隔离性。</li></ul></li><li><img src="/../img/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0.png"></li></ul></li><li><p>redo log<br>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。<br><img src="/../img/redolog%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><ul><li><p>过程：</p><ul><li>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。</li><li>在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。</li><li>过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。</li><li>而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的</li></ul></li><li><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><ul><li>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</li></ul></li></ul></li><li><p>undo log<br>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制)</p><ul><li>undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：<ul><li>undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</li></ul></li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><blockquote><p>全称 Multi-Version Concurrency Control，多版本并发控制。用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p></blockquote><h4 id="当前读（锁定读）"><a href="#当前读（锁定读）" class="headerlink" title="当前读（锁定读）"></a>当前读（锁定读）</h4><ul><li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li><li>如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</li><li>在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</li></ul><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><h5 id="为什么需要快照读？"><a href="#为什么需要快照读？" class="headerlink" title="为什么需要快照读？"></a>为什么需要快照读？</h5><ul><li>提供读取一致性数据：<ul><li>比如一个读，一个改，如果没有快照，那读事务第一个读和第二个读的数据都不一样，无法进行正确的逻辑操作，会有并发安全问题。</li></ul></li><li>解决读取冲突：<ul><li>一个读一个写，传统读操作可能会被写操作阻塞，通过快照读，事务可以读取到事务开始时的一致数据快照，与其他并发事务的修改操作相互独立，避免了读取冲突，提供了读取操作的隔离性。</li></ul></li></ul><h5 id="如何实现快照读？"><a href="#如何实现快照读？" class="headerlink" title="如何实现快照读？"></a>如何实现快照读？</h5><p>MVCC</p><ul><li><p>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：</p><ul><li><p>对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</p></li><li><p>如果某个数据行有多个版本，事务会选择<strong>不晚于其开始时间</strong>的最新版本，确保事务只读取在它开始之前已经存在的数据。</p></li><li><p>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</p></li><li><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p></li></ul></li><li><p>每次读取从快照进行读</p></li><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><h4 id="版本链："><a href="#版本链：" class="headerlink" title="版本链："></a>版本链：</h4><p><img src="D:\Blog\source\img\记录隐藏字段.png"></p><p> 即数据的历时记录</p><p><img src="/../img/%E7%89%88%E6%9C%AC%E9%93%BE%E4%BE%8B%E5%AD%90.png"></p><h4 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h4><blockquote><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>先确认readview，rr和rc的readview有不同</p><ul><li>rr是会更新的每次都需要计算</li><li>rc是会复用该事务的第一个readview</li><li>然后根据访问规则以及对应的readview就能知道应该访问哪个版本数据</li></ul></blockquote><ul><li>核心字段：<br><img src="/../img/readview%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5.png"> <ul><li>未提交的事务就是活跃事务</li></ul></li></ul><blockquote><p>RR（Read-Repeatable）和 RC（Read-Committed）是数据库中的两个事务隔离级别。不同的隔离级别在性能和数据一致性之间存在权衡，需要综合考虑应用程序的具体场景和要求。</p></blockquote><ul><li><p>RC隔离级别例子：<br><img src="/../img/readview%E5%8C%B9%E9%85%8D%E4%BE%8B%E5%AD%90.png"> </p></li><li><p>RR隔离级别：</p><ul><li>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。<br><img src="/../img/RR%E4%BE%8B%E5%AD%90.png"> </li><li>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</li></ul></li></ul><h3 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><ul><li>作用：<ul><li>主要实现数据库数据的恢复，比如在操作数据库的时候，数据库突然宕机了，重启之后，redolog可以帮助数据库复原</li></ul></li><li>实现恢复的基本流程<ul><li>当一个事务对数据库进行修改时，innoDB首先会将修改记录记录到redolog缓冲池中</li><li>redolog缓冲池中的数据会根据刷盘策略刷到redolog文件之中，redolog文件保存在磁盘上<ul><li>0：每一秒刷一次</li><li>1：事务提交就刷一次，后台每一秒也刷一次</li><li>2：事务提交就刷到page cache</li><li>日志区满等情况也会刷盘</li></ul></li><li>redolog采用的是顺序写，效率优于一般的数据页写入，从而保证在重启时redolog先于数据页写入磁盘，确保使用redolog文件的数据来恢复<ul><li>顺序写就可以直接将数据一条一条的写入磁盘，无需寻找数据，减少磁盘寻道时间</li></ul></li><li>当数据库非正常关闭，在重启时，innoDB会先检查redolog文件，将其中的数据恢复到数据库，以此来实现宕机的数据恢复</li></ul></li><li>为什么不在每次修改后直接将修改过的数据页刷盘（将数据页直接更新到磁盘）呢？<ul><li>因为数据页大小为16k，每次可能就修改了数据页中的几个byte的信息，这样也刷盘浪费资源</li><li>数据页刷盘是随机写，速度慢<ul><li>比如两次修改，第一次修改页的第一块，第二次修改了页的第十个块，第三次修改了页的第五个块，这样会有磁盘的寻道，写入慢，redolog就是依次记录每次的修改</li><li>redolog只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</li></ul></li></ul></li></ul><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h4><ul><li><p>作用：</p><ul><li><p>逻辑日志，记录语句的逻辑，任何存储引擎都有，只要表数据有更新，都会产生binlog日志</p></li><li><p>实现数据库的数据备份、主从复制、主从同步等</p><p><img src="D:\Blog\source\img\binlog作用.png"></p></li></ul></li><li><p>存储形式：</p><ul><li>statement：光记录sql，如在updade_time &#x3D; now()时就没有实现记录的有用，会导致与原库数据不一致</li><li>row：记录信息，占用空间大</li><li>mix：<code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li></ul></li><li><p>写入时机：</p><ul><li>事务执行先写入binlog_cache，事务提交时，写入binlog文件（磁盘中）</li></ul></li></ul><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><ul><li>如果写完redolog后，binlog写出现了异常，那么：<ul><li>binlog里面没有对应修改记录，如果将主数据库数据复制到从数据库，会使用binlog来实现，但是binlog此时没有修改记录，那么此时主从数据库不一致了</li></ul></li><li>所以使用两阶段提交：将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code></li><li><img src="D:\Blog\source\img\两阶段提交.png"></li></ul><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p><img src="D:\Blog\source\img\两阶段提交binlog问题.png"></p><p><img src="D:\Blog\source\img\两阶段提交relogcommit问题.png"></p><ul><li><code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？<ul><li>不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</li></ul></li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制)</p><ul><li>undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：<ul><li>undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程笔记</title>
    <link href="/2023/11/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/11/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>进程是程序的一次执行过程，是系统运行程序的基本单位。</li><li>在java中，我们启动main函数就是启动了一个jvm进程，而main函数就是其中的一个线程</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是比进程更小的一个执行单位，一个进程在执行的过程中可以产生多个线程。</li><li>多个线程共享进程之间的<strong>堆和方法区资源</strong>，但是每个线程有自己的<strong>程序计数器</strong>、虚拟机栈、<strong>本地方法栈</strong>。所以在线程中切换时负担要小于进程，因此，线程又叫做<strong>轻量级进程</strong>。</li></ul><p><img src="D:\Blog\source\img\java线程和进程.png"></p><h4 id="程序计数器为什么是私有呢？"><a href="#程序计数器为什么是私有呢？" class="headerlink" title="程序计数器为什么是私有呢？"></a>程序计数器为什么是私有呢？</h4><ul><li>程序计数器的作用：<ul><li>字节码解释器通过程序计数器来读取指令（程序计数器记录了下一个指令的地址或者编号）</li><li>多线程情况下，程序计数器用于记录当前线程执行到的位置，从而使切换回来后知道上次该程序运行到哪里了</li></ul></li><li>为什么私有？<ul><li><strong>为了线程切换后能够恢复到正确的执行位置</strong></li></ul></li></ul><h4 id="虚拟机栈和本地方法栈为什么是私有呢？"><a href="#虚拟机栈和本地方法栈为什么是私有呢？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有呢？"></a>虚拟机栈和本地方法栈为什么是私有呢？</h4><ul><li>虚拟机栈：<ul><li>每个方法执行前会创建一个栈帧，用于存储局部变量、操作数栈（暂存执行过程中的操作数（中间结果））、方法返回值等信息，一个方法的调用过程，就对应一个栈帧在java虚拟机栈中入栈和出栈的过程</li></ul></li><li>本地方法栈：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></li><li>为什么私有？<ul><li><strong>为了保证当前线程中的局部变量不被其他线程访问</strong></li></ul></li></ul><h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><ul><li><strong>堆</strong>和<strong>方法区</strong>是所有线程共享的资源</li><li><strong>堆</strong>是进程中最大的内存，主要用于存放<strong>新创建的对象</strong></li><li><strong>方法区</strong>主要存放<strong>已被加载的类信息</strong>、常量、<strong>静态变量</strong>、即时编译器编译后的代码等数据</li></ul><h3 id="并行和并发，同步和异步"><a href="#并行和并发，同步和异步" class="headerlink" title="并行和并发，同步和异步"></a>并行和并发，同步和异步</h3><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li>并行：多个作业在同一时刻执行，如多人跑步</li><li>并发：多个作业同一时间段内执行，如接力跑</li></ul><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul><li>同步：发出调用后，必须等到结果才可以返回，否则一直等待</li><li>异步：调用发出后，不需要等待结果，直接返回</li></ul><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h4><ul><li>cpu、内存、IO设备的速度有极大差异，为了更加合理的利用cpu的高性能，有了如下优化：<ul><li>cpu增加了缓存（比内存快），避免了每次读取数据都要去内存中读，去缓存中读取速度更快，这同时也带了可见性问题<ul><li>如何带来可见性问题呢？和 JMM的关系在哪里呢？<ul><li>JMM 规定，每个线程都有自己的工作内存，用于缓存自己在主内存中常用的数据</li><li>而线程的工作内存里的数据在物理上就是存储在cpu的缓存之中</li></ul></li></ul></li></ul></li></ul><h4 id="使用多线程会带来什么问题？"><a href="#使用多线程会带来什么问题？" class="headerlink" title="使用多线程会带来什么问题？"></a>使用多线程会带来什么问题？</h4><ul><li><strong>死锁：</strong>死锁是指两个或多个线程相互等待对方持有的资源，导致所有线程无法继续执行的情况。</li><li><strong>内存泄漏：</strong>长期存活的线程持有了其他对象的引用，导致该引用无法被垃圾回收</li><li><strong>线程不安全：</strong>对于同一份数据，多个线程同时访问可能会导致数据混乱，错误或者丢失，需使用适当的同步机制来避免。</li><li><strong>上下文切换开销</strong></li><li><strong>调试测试困难</strong></li></ul><h4 id="单核CPU运行多个线程效率一定高吗"><a href="#单核CPU运行多个线程效率一定高吗" class="headerlink" title="单核CPU运行多个线程效率一定高吗"></a>单核CPU运行多个线程效率一定高吗</h4><ul><li>CPU密集型则效率低<ul><li>CPU密集型会频繁使用CPU，会导致线程频繁的切换，增加开销</li></ul></li><li>IO密集型则效率高<ul><li>IO密集型则可以让多个线程在等待IO时的CPU空闲时间里来运行，增加效率</li></ul></li></ul><h4 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态"></a>说说线程的生命周期和状态</h4><ul><li>NEW：初始状态，线程刚被创建还没有调用<code>start()</code></li><li>RUNNABLE：运行状态，线程被调用<code>start()</code>等待运行的状态</li><li>BLOCKED：阻塞状态，需要等待锁的释放</li><li>WAITING：等待状态，此时条件不满足，需要等待其他线程执行特定动作才能继续执行</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="D:\Blog\source\img\状态图.png"></p><h4 id="什么是线程的上下文切换"><a href="#什么是线程的上下文切换" class="headerlink" title="什么是线程的上下文切换"></a>什么是线程的上下文切换</h4><ul><li>线程切换意味着需要保存当前线程的上下文，留给线程下次占用 CPU 的时候恢复现场。</li><li>并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</li></ul><h4 id="可以直接调用Thread类中的run方法吗？"><a href="#可以直接调用Thread类中的run方法吗？" class="headerlink" title="可以直接调用Thread类中的run方法吗？"></a>可以直接调用Thread类中的run方法吗？</h4><ul><li>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 </li><li><code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</li><li>但是，<strong>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行</strong>，并不会在某个线程中执行它，所以这并不是多线程工作</li><li><strong>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>synchronized在早期是属于 重量级锁，后期synchronized引入了大量的优化如 自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁。</p></blockquote><ul><li>可以修饰代码块</li><li>修饰静态方法</li><li>修饰实例方法</li><li><strong>不可修饰构造方法</strong></li></ul><h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><blockquote><p>monitor叫做监视器或者管程，辅助实现synchronized锁<br><img src="/../img/java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%BC%E5%BC%8F.png"></p><ul><li><p>每个java对象底层实现会有一个Mark Word的字段</p></li><li><p>如果使用synchronized给对象a上锁之后，该对象a的 Mark Word中就会设置为一个Monitor对象的指针（monitor对象来自操作系统)</p></li><li><p>然后monitor对象的owner字段就会绑定为该线程（即加锁的线程）</p></li><li><p>如果其他线程需要对相同对象（对象a）加锁，则会对对象a绑定的monitor对象的owner字段进行判断，为空则直接绑定该线程（即没有加锁，或者锁被释放），不为空则添加到EntryList链表之中，进行排队</p></li><li><p>当owner为空后（原来加锁的对象释放了锁），再根据调度法则，选取一个排队对象设置为owner。<br><img src="/../img/monitor%E5%AE%9E%E7%8E%B0%E9%94%81.png"></p></li></ul></blockquote><ul><li>轻量级锁的哈希码存在线程栈帧之中，解锁还原</li><li>重量级锁的哈希码存在Monitor之中，解锁还原</li><li>偏向锁和轻量级锁都是线程错开的，不会有线程竞争的情况，如果出现了竞争的情况，那么会膨胀为重量级锁</li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>就是monitor，使用底层的互斥，成本非常的高</p><ul><li>自旋<ul><li>内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。</li><li>具体流程：<ul><li>线程竞争锁失败，应该进行自我阻塞，但是自旋机制，减少状态的切换，减少开销</li><li>不阻塞自己，自旋（循环等待，需要消耗cpu，但比状态切换好）</li><li>自旋的同时一直请求锁</li><li>自旋结束前获取到了，则获取到了，没获取到则阻塞自己。</li></ul></li></ul></li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗。</p><ul><li>过程：<ul><li>线程对对象加锁，会在线程的栈帧中创造一个锁记录结构</li><li>如果对象没有加锁（根据markword判断），让锁记录中 Object reference 指向锁对象，并尝试用 <strong>cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</strong><ul><li>为什么要cas呢？如何cas呢？<ul><li>因为涉及到了数据的交换，而且此时并没有加锁，可能会在交换的时候（比如第一个轻量级锁写入的时候），另一个锁又来了，然后也获取，再写入，此时可能就会发生线程不安全，导致可能两个锁的锁记录的object reference都指向了这个对象，导致这个对象加了两个锁，所以必须使用cas，看是否在加锁的时候有其他对象来加锁。</li></ul></li></ul></li><li>如果有轻量级锁了，那么会进行锁的膨胀，将markword指向一个monitor，实现重量级锁</li><li>如果是同一个锁，那么会进行锁的重入，在锁记录中添加一条记录</li></ul></li><li>特点：<ul><li>轻量级锁通过在对象头部的标志位和指针记录锁的状态和持有者线程的标识，尝试使用CAS（compare and swap）操作来获取锁。如果获取失败，线程会进行自旋等待，以避免阻塞和线程切换的开销。</li><li>在对象 markword 中存储的是锁记录地址，锁记录里面存储了被锁的对象引用 。</li><li>可重入：如果是同一个线程来获取同一个对象，那么会添加一个 LockRecord 作为重入计数。</li><li>如果被竞争了，那么膨胀为重量级锁。</li></ul></li></ul><p><img src="/../img/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>比轻量级锁更加轻，具体在锁重入的时候无需继续cas操作</p><blockquote><p>重量级锁就类似于一个防盗锁</p><p>轻量级锁就类似于将书包挂在门上，每一次判断都需要翻一翻书包进行判断</p><p>偏向锁就是直接将名字刻在门上</p></blockquote><p>偏向锁为什么不需要cas操作来加锁呢？</p><ul><li><p>因为偏向锁直接将线程的id给加到了对象头的markword区域，不会存在上面的线程不安全问题。直接在设置的时候进行判断就行，如果这个值为空或者为自己，那么就可以直接设置，否则证明有竞争。</p></li><li><p>特点：</p><ul><li>使用对象头的 markword 来记录获取该对象的线程id（相当于刻名字）</li></ul></li><li><p>应用场景：</p><ul><li>适用于无竞争的情况</li></ul></li><li><p>多个线程交错访问同一个加锁对象，那么会有如下变化</p><ul><li>首先创建对象会进行偏向锁的标记</li><li>第一个线程访问并获取锁时，会加偏向锁（让mark word标记该线程id）</li><li>另一个线程又访问该对象并获取锁时（之前的锁已经释放），会升级为轻量锁</li><li>释放轻量锁后，会变为无锁状态，并且取消偏向状态</li></ul></li><li><p>如果重新偏向的次数太多（20）的话，那么会直接批量偏向新线程，而不会升级为轻量级锁。</p></li><li><p>如果重新偏向更多（40），那么直接撤销</p></li><li><p>偏向锁的失效：</p><ul><li>哈希码只有在使用的时候才会产生比如 <code>d.hashCode()</code> ，并且存储在对象头的mark word中，如果没有产生哈希码，那么默认为0，在使用偏向锁的时候，会使用这些位（存储哈希码的位）来存储线程id。所以一旦使用哈希码，那么偏向锁会失效。</li></ul></li></ul><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h3><ul><li>wait：释放对象的锁，让线程进入等待队列中进行等待</li><li>notify：挑选一个等待队列中的线程进行唤醒（唤醒并不代表运行，还要看是否有运行条件等）</li><li>notifyAll：唤醒等待队列中的所有线程 </li><li>关于唤醒和notifyAll：<ul><li>唤醒不一定运行，唤醒的所有线程得按照自己的资源条件和调度策略再竞争，让自己运行，没有竞争过的就加入阻塞对列</li></ul></li><li><code>wait()</code>为什么不能定义在线程内部？<ul><li>因为wait需要释放当前线程的锁，所以需要操作当前线程所锁住的锁对象<code>Object</code>，锁对象位于线程之外，所以要操作锁对象，必须定义在线程外。</li></ul></li></ul><h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park unpark"></a>park unpark</h3><ul><li><p>park：暂停当前线程，<code>park()</code>方法会<strong>使当前线程进入阻塞状态，并且不会释放线程所持有的锁。</strong></p></li><li><p>unpark：恢复某个线程</p></li><li><p>理解：</p><ul><li>类似于信号量</li><li>park 可以类比于要吃东西然后前进，没有东西则暂停等待</li><li>unpark 可以类比于放置一个东西</li></ul></li><li><p>与wait notify对比：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必，对象,wait()，线程.await();</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul></li></ul><h4 id="sleep-，wait-，park方法对比"><a href="#sleep-，wait-，park方法对比" class="headerlink" title="sleep() ，wait()，park方法对比"></a>sleep() ，wait()，park方法对比</h4><ul><li>三者都可以暂停线程</li><li><code>sleep()</code>方法没有释放锁，<code>wait()</code>方法会释放锁，<code>park()</code>方法不释放锁（不依赖监视器）</li><li><code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。<code>park()</code>也不涉及到对象类，不需要获得锁。</li><li><code>sleep()</code>调用后线程会自动苏醒，<code>park()</code> <code>wait()</code>不会自动苏醒，分别需要<code>unpark()</code>，<code>notify()/notifyAll()</code>才苏醒</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>基本语法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 释放锁</span><br>reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>特点：<ul><li>可重入<ul><li>指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</li></ul></li><li>支持多个条件变量<ul><li>在synchronized中，wait后都是统一加入到同一个等待队列之中，notify随机唤醒一个，notifyAll唤醒所有，可能导致虚假唤醒（即唤醒了根本不需要唤醒的线程）</li><li>而在ReentrantLock中，可以设置条件变量，await之后将不同的线程加入到不同的阻塞队列之中，到时候再对相应的等待队列进行唤醒。</li></ul></li><li>可中断<ul><li><strong>可中断锁</strong>：获取锁的过程中就可以被中断</li><li><strong>不可中断锁</strong>：一旦申请锁，必须等到拿到锁之后才能进行其他的逻辑处理，<code>synchronized</code> 就属于不可中断锁</li></ul></li><li>可以设置超时时间</li><li>可以设置为公平锁<ul><li><strong>公平锁</strong>：锁被释放后，先申请的线程先得到锁，性能较差</li><li><strong>非公平锁</strong>：锁被释放后，按照随机或者其他优先级排序获取锁，可能会导致某些线程永远无法获得锁</li></ul></li></ul></li></ul><h3 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型 JMM"></a>Java内存模型 JMM</h3><blockquote><p>JMM 即java memory model，定义了主存，工作内存等抽象概念，底层对应着CPU寄存器，缓存，硬件内存，CPU指令优化等</p></blockquote><p>JMM体现在以下几个方面：</p><ul><li>原子性：保证指令集不会受到线程上下文切换的影响</li><li>可见性：保证指令不会受到CPU缓存的影响</li><li>有序性：保证指令不会受到CPU指令重排的影响</li></ul><h4 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h4><ul><li>JMM可以看作是java定义并发编程的一组规范</li><li>遵守该规范就能够<strong>解决 CPU多级缓存和指令重排等对并发编程的问题</strong><ul><li><p>为什么会有CPU多级缓存？</p><ul><li>当CPU执行程序的时候，需要从主存中获取数据和指令，但是主存访问速度慢，所以引入了CPU多级缓存</li><li>将常用的数据存在缓存之中</li><li>使用一些协议解决缓存数据一致性问题</li></ul></li><li><p>为什么会有指令重排？</p><ul><li>为了提高程序的执行效率和性能</li><li>比如有些指令依赖前面指令的结果，但是前面指令还未执行完成，需要等待，所以处理器会进行优化，将后面一些不依赖的指令放在等待期里面执行，防止空等待</li></ul></li></ul></li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul><li><p>什么是可见性问题：</p><ul><li>即一个线程对某共享变量修改后，另一个线程无法看到最新的变量值的情况</li></ul></li><li><p>为什么会产生可见性问题：</p><ul><li><p>主内存，本地内存：</p><ul><li>主内存：所有线程创建的实例对象（无论成员还是局部）</li><li>本地内存：存储了该线程以读 &#x2F; 写共享变量的副本</li></ul></li><li><p>因为不同线程之间的通信需要通过主存传递数据，当一个线程修改了共享变量，这个修改可能会存储在线程的本地缓存中，而不会立即同步到主内存中，因此其他线程可能无法立刻看到这个修改。</p></li><li><p>也有一说是线程频繁读取主存中的值，JIT（just in time compiler）会直接将该值存入线程工作区（相当于线程的缓存），用来提高速度，所以此时即使其他线程修改了主内存中的值，此线程仍然读取自己的缓存，缓存没有得到即使更新。</p></li></ul></li><li><p>解决办法：</p><ul><li>volatile：它可以用来修饰成员变量和静态成员变量，线程对于被volatile修饰的变量的操作总是直接操作主存，实现最新的修改和查询。<br><img src="D:\Blog\source\img\jmm结构.png"></li></ul></li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul><li>为什么会有有序性问题？<ul><li>在不改变程序的语义的前提下，可能会对指令进行重排序以提高性能。</li></ul></li><li>如何解决：<ul><li><code>volatile</code>变量的读取和写入操作会引入内存屏障，阻止编译器和处理器对操作进行重排序。这确保了<code>volatile</code>变量的操作顺序不会被重排序。</li><li>进行写时，会确保写之前的代码安排在写之前</li><li>进行读时，会确保读之后的代码安排在读之后</li></ul></li></ul><h4 id="Java内存区域和-JMM-有什么区别"><a href="#Java内存区域和-JMM-有什么区别" class="headerlink" title="Java内存区域和 JMM 有什么区别"></a>Java内存区域和 JMM 有什么区别</h4><ul><li>JVM 内存结构和 Java虚拟机的运行时区域相关，定义了JVM在运行时如何分区存储程序数据</li><li>Java 内存模型和 Java并发编程相关，抽象了线程中工作内存和主内存之间的关系，并且规定了相关的可执行指令的原则和规范，主要目的是为了简化多线程编程，增强可移植性（因为有了规范）</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote><p>cas 就是 compare and swap 或者 compare and set，用于实现乐观锁。</p></blockquote><p><strong>乐观锁：</strong>总是乐观的认为共享资源在访问的时候不会出现问题，所以无需加锁也无需等待，仅仅只需要在提交修改的时候进行验证即可。</p><p><strong>悲观锁：</strong>总是悲观的认为共享资源在访问的时候会出现问题，所以每次获取资源操作的时候都进行加锁操作。即共享资源只给一个线程使用，阻塞其他想要的线程。</p><h4 id="CAS使用"><a href="#CAS使用" class="headerlink" title="CAS使用"></a>CAS使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目的：将 balance 的值减少 amount</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">//获取修改前的balance值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>    <span class="hljs-comment">//计算出减去amount后balance的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>    <span class="hljs-comment">//如果balance的值 == prev，那么 balance 赋值为 next，表达式返回true，</span><br>    <span class="hljs-comment">//否则返回false，不进行操作，继续进行循环</span><br>    <span class="hljs-comment">//返回false，则代表prev和最新的balance不相等，证明有其他线程在此期间对balance进行了修改</span><br>    <span class="hljs-comment">//balance总是需要获取最新的，所以需要用volatile修饰，保证可见性</span><br>    <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next))&#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="为什么无锁效率更高呢？"><a href="#为什么无锁效率更高呢？" class="headerlink" title="为什么无锁效率更高呢？"></a>为什么无锁效率更高呢？</h4><ul><li>在无锁的情况下，即使失败重试，线程也在高速运行，没有停歇，而synchronized在没有获得锁的情况下，会让线程发生上下文切换（保存上下文，之后唤醒又需要加载上下文），进入阻塞状态，浪费时间和空间</li><li>但是无锁情况效率高也需要一定条件，就是需要cpu保证该线程的运行，不然没有cpu，进入可运行状态（等待）还是会导致上下文的切换。</li></ul><h4 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h4><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong></li><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul><li>一个变量第一次读取的值是 A，然后赋值的时候任然是 A，此时并不能说该变量没有被修改过。有可能另一个线程在此期间将该变量的值 先改为 B ，然后又改为 A。</li><li><strong>解决方法：</strong><ul><li>给变量追加一个版本号即可</li></ul></li></ul><h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ul><li>基本类型：使用原子的方式更新基本类型<ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul></li><li>数组类型：使用原子的方式更新数组中的某个元素<ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul></li><li>引用类型：<ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</li></ul></li></ul><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>ThreadLocal作用是什么？</strong></p><p>为线程创建一个线程私有的 <code>数据盒</code>，存放线程的私有数据。</p><h4 id="ThreadLocal原理（简要）"><a href="#ThreadLocal原理（简要）" class="headerlink" title="ThreadLocal原理（简要）"></a>ThreadLocal原理（简要）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Thread类之中以后一个<code>threadlocals</code> 变量和一个<code>inheritableThreadLocals</code>变量，都是<code>ThreadLocalMap</code>类型的对象，我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>set()</code>、<code>get()</code>方法。</p><p>得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><p><code>ThreadLocal</code> 数据结构如下图所示：</p><p><img src="D:\Blog\source\img\threadlocalmap结构.png"></p><h4 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><blockquote><p>当一个<code>ThreadLocal</code>对象没有被外部强引用持有时，在垃圾回收的时候，<code>ThreadLocal</code>对象会被判定为不再被引用，从而可以被垃圾回收器回收。一旦<code>ThreadLocal</code>对象被回收，对应的弱引用也会被清理掉。</p><p>然而，<code>ThreadLocalMap</code>中的值（线程局部变量）是使用强引用来持有的。强引用意味着被引用的对象不会被垃圾回收器主动回收，只有当没有任何强引用指向该对象时，才会被回收。</p></blockquote><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h4><p>线程池就是一系列线程的资源池，当有任务需要处理时，直接从线程中获取线程来处理，处理完之后，线程不会被销毁，而是等待下一个任务。</p><h4 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h4><p>池化技术应用广泛，如线程池、HTTP连接池、数据库连接池等，<strong>池化技术的思想主要是为了减少每次获取资源的消耗，提高资源的利用率。</strong></p><p>线程池提供了一种限制和管理资源（执行一个任务也算资源管理）的方式，每个线程池还维护一些基本统计信息，如已完成任务的数量等。</p><p>其好处有：</p><ul><li><strong>降低资源的消耗</strong>：重复利用已经创建好的线程，减少线程创建和销毁带来的消耗</li><li><strong>提高响应的速度</strong>：任务到达后，无需等待线程的创建，直接从线程池中获取线程就可以执行</li><li><strong>提高线程的可管理性</strong>：线程池可以进行线程的统一管理</li></ul><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><blockquote><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p>信息存储在原子变量ctl中，目的是让线程状态和线程个数合二为一，可以用一次CAS原子操作进行赋值</p></blockquote><ul><li>RUNNING</li><li>SHUTDOWN：不会接收新任务，但会处理阻塞队列剩余任务</li><li>STOP：会中断正在执行的任务，并抛弃阻塞队列任务</li><li>TIDYING：任务全执行完毕，活动线程为 0 即将进入 终结</li><li>TERMINATED：终结状态</li></ul><p>从上往下，数字越来越大</p><h4 id="线程池构造方法"><a href="#线程池构造方法" class="headerlink" title="线程池构造方法"></a>线程池构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//核心线程数（最多保留线程数）</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//救急线程生存时间</span><br><span class="hljs-params">                          TimeUnit unit,//救急线程生存时间的时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂（可以为线程创建时取名）</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略</span><br><span class="hljs-params">                         )</span><br></code></pre></td></tr></table></figure><h4 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h4><ul><li>线程池<strong>刚开始没有线程</strong>，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务</li><li>当池中线程数达到corePoolSize并且没有线程空闲，这时再加入任务，新加的任务会加入到workQueue队列排队，直到有空闲的线程</li><li>如果队列是有界队列，那么当任务超过队列大小时，会创建 maximumPoolSize - corePoolSize 数目的救急线程来进行救急</li><li>如果线程数达到maximumPoolSize，此时又来了新任务，那么会执行拒绝策略，jdk提供了四种实现：<ul><li><strong>AbortPolicy</strong> 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong> 让调用者运行任务 <ul><li>如果使用abort策略，队列满了之后，ThreadPoolExecutor会抛出异常，拒接该任务。</li><li>如果不想放弃掉该任务，可以使用CallerRun策略，它不会抛弃任务，也不会抛出异常，而是将任务退回给调用者，使用调用者的线程来执行任务</li></ul></li><li><strong>DiscardPolicy</strong> 放弃本次任务</li><li><strong>DiscardOldestPolicy</strong> 放弃队列中最早的任务，本任务取而代之 </li><li><strong>Dubbo</strong> 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题 </li><li><strong>Netty</strong> 的实现，是创建一个新线程来执行任务</li><li><strong>ActiveMQ</strong> 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </li><li><strong>PinPoint</strong> 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li><li>超过corePoolSize的救急线程会在一定时间后自行结束</li></ul><h4 id="几种常见内置线程池"><a href="#几种常见内置线程池" class="headerlink" title="几种常见内置线程池"></a>几种常见内置线程池</h4><ul><li><p>FixedThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                               <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>特点：<ul><li>核心线程数 &#x3D;&#x3D; 最大线程数，无救急线程，因此无需超时时间</li><li>阻塞队列是无界的</li></ul></li><li>适用于任务量已知，相对耗时的任务</li></ul></li><li><p>CachedThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                               <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>特点：<ul><li>核心线程数为0，最大线程数为Integer.MAX_VALUE，救急线程生存时间60s<ul><li>意味着：全是救急线程执行任务（60s后回收）</li><li>救急线程可无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，<strong>没有线程来取是放不进去的</strong>，即需要有 <strong>取</strong> 的线程才开辟一个空间，用来 <strong>放</strong></li></ul></li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</li></ul></li><li><p>SingleThreadExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                         <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>特点：<ul><li>线程固定为1，任务多于1时，会被放入无界队列，任务执行完毕，该唯一线程也不会被释放</li><li>相比于创建一个线程：<ul><li>单个线程执行完任务后会被释放，执行失败也会释放，没有补救措施</li><li>而此线程池可以总是确保有一个线程</li></ul></li><li>相比于newFixedThradPool(1)<ul><li>newFixedThradPool 初始化为1后，之后还能修改大小</li><li>newSIngleThreadPool 不能修改</li></ul></li></ul></li></ul></li></ul><p><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。</p><p><code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程</p><h3 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h3><h4 id="Future类有什么作用？"><a href="#Future类有什么作用？" class="headerlink" title="Future类有什么作用？"></a>Future类有什么作用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio<br><br>&#125;<br></code></pre></td></tr></table></figure><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h4 id="Callable-和-Runnable"><a href="#Callable-和-Runnable" class="headerlink" title="Callable 和 Runnable"></a><code>Callable</code> 和 <code>Runnable</code></h4><ol><li><strong>Runnable：</strong><br><code>Runnable</code> 是一个函数式接口，它定义了一个无返回值的 <code>run()</code> 方法。我们可以通过实现 <code>Runnable</code> 接口来创建一个可执行的任务。<code>Runnable</code> 接口适合那些不需要返回结果的简单任务。</li><li><strong>Callable：</strong><br><code>Callable</code> 是一个泛型接口，它定义了一个有返回值的 <code>call()</code> 方法。与 <code>Runnable</code> 不同，<code>Callable</code> 接口的 <code>call()</code> 方法可以返回一个值，并且可以抛出受检查的异常。我们可以通过实现 <code>Callable</code> 接口来创建一个可执行的任务，可以将其提交给线程池执行，并获取任务的执行结果。</li></ol><p>与 <code>Runnable</code> 相比，<code>Callable</code> 更加灵活，可以返回计算结果或抛出异常。通过 <code>Callable</code> 可以实现更复杂的任务，例如需要耗时计算、需要返回结果的任务，或者需要捕获异常并进行处理的任务。</p><p>在线程池中，可以使用 <code>submit()</code> 方法来提交 <code>Runnable</code> 或 <code>Callable</code> 对象，以便让线程池执行任务。</p><ul><li>对于 <code>Runnable</code> 提交的任务，线程池只会执行其 <code>run()</code> 方法；</li><li>对于 <code>Callable</code> 提交的任务，线程池会执行其 <code>call()</code> 方法，并返回一个 <code>Future</code> 对象，可以通过该对象获取任务的执行结果。</li></ul><p>总结来说，<code>Runnable</code> 适用于不需要返回结果的简单任务，而 <code>Callable</code> 则适用于需要返回结果或处理异常的复杂任务。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><ul><li>AQS全称是 <code>AbstractQueuedSynchronizer</code>(抽象队列同步器)，是一个阻塞式锁相关的同步器工具的框架，使用AQS能够简单且高效的构造出应用广泛的同步器，如ReentrantLock，Semaphore</li><li>特点：<ul><li>使用state属性来表示资源的状态（分为独占模式和共享模式），子类需要定义如何维护状态，控制如何获取锁和释放锁<ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：cas机制设置state</li><li>独占模式是只允许一个线程访问资源，共享模式是运行多个线程访问资源</li></ul></li><li>提供了FIFO的等待队列</li><li>条件变量实现等待、唤醒机制，支持多个条件变量</li></ul></li></ul><h4 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 </p><p>特点： </p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 <ul><li>getState - 获取 state 状态 </li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul></li></ul><p><strong>CLH队列</strong></p><p><img src="D:\Blog\source\img\clh队列.png"></p><ul><li>state为0的时候表示锁未被占有，state为1的时候表示锁被占有，state大于1表示是重入锁，exclusiveOwnerThread 指向占有锁的线程</li><li>其他想要占有锁的线程在队列中进行排序，并且每一个线程节点都有状态<ul><li>-1代表可以用来唤醒后一个节点</li><li>-2代表是条件节点</li></ul></li></ul><h4 id="ReentrantLock实现"><a href="#ReentrantLock实现" class="headerlink" title="ReentrantLock实现"></a>ReentrantLock实现</h4><p><strong>可重入锁实现原理</strong></p><ul><li>使用state进行计数，如果是同一个线程进行上锁，那么会state ++；</li><li>进行解锁也同样道理，解锁一次state –，直到state &#x3D;&#x3D;0 才能真的释放锁，将exclusiveOwnerThread  设为 null；</li></ul><p><strong>公平非公平实现原理</strong></p><ul><li>公平锁：<ul><li>如果state &#x3D;&#x3D; 0，并且此时有线程来抢占锁，那么不能立即抢占，还需要判断队列之中head后面还有无线程在等待，如果有，通过cas来入队；</li></ul></li><li>非公平锁：<ul><li>不会进行判断队列的判断，抢占线程直接获得锁，如果没有抢占线程，那么队列之中的线程还是按照排队进行获取锁；</li></ul></li></ul><p><strong>不可打断实现原理</strong></p><p>​线程会有interupted方法进行打断</p><ul><li>可打断：<ul><li>加锁的时候会判断打断标记是否为true，如果为true，那么证明有人发起了打断，直接抛出打断异常</li></ul></li><li>不可打断：<ul><li>只有在加锁成功后才会告知是否打断，所以在加锁过程中不可打断。</li></ul></li></ul><p><strong>条件变量实现原理</strong></p><ul><li><p>使用ConditionObject维持一个等待队列，记录线程节点</p><p><img src="D:\Blog\source\img\conditionObject-await.png"></p><p><img src="D:\Blog\source\img\conditionObject-await2.png"></p><p><img src="D:\Blog\source\img\conditionObject-signal1.png"></p><p><img src="D:\Blog\source\img\conditionObject-signal2.png"></p></li></ul><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><ul><li><p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</p></li><li><p>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p></li></ul><p><strong>读锁（Read Lock）</strong>：</p><ul><li>多个线程可以同时获取读锁，用于并发读取共享资源。</li><li>读锁是共享锁，不会阻塞其他线程获取读锁，只有在写锁没有被占用的情况下才能获取读锁。</li></ul><p><strong>写锁（Write Lock）：</strong></p><ul><li>只允许一个线程获取写锁，用于对共享资源进行写操作。</li><li>写锁是独占锁，在写锁被占用期间，其他线程无法获取读锁或写锁。</li></ul><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p><strong>线程持有读锁还能获取写锁吗？</strong></p><ul><li>在线程持有读锁的情况下，该线程不能取得写锁 (因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。<ul><li>为什么读锁不可以升级为写锁？<ul><li>读锁升级可能导致线程争夺，因为写锁是独占锁</li><li>可能发生死锁，如果两个线程的读锁都想升级为写锁，那么需要对方释放自己的读锁，而双方都不会释放，所以会产生死锁</li></ul></li></ul></li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="什么是Semaphore？"><a href="#什么是Semaphore？" class="headerlink" title="什么是Semaphore？"></a>什么是Semaphore？</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code>依次只允许一个线程访问共享资源，而<code>Semaphore</code>(信号量) 可以<strong>控制同时访问共享资源的线程数量</strong></p><p>下面代码逻辑为：当线程数大于3来访问时，只有前三个才能进行正确的访问，其他的线程需要进行阻塞，直到有信号量被释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceAccessTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 设置许可数为3</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 请求获取资源的许可</span><br>            semaphore.acquire();<br>            <span class="hljs-comment">// 访问共享资源，进行对应的逻辑操作</span><br>            accessResource();<br>            <span class="hljs-comment">// 释放资源的许可</span><br>            semaphore.release();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// 处理中断异常</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessResource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 修改共享资源</span><br>        j++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建3个任务进行资源访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">ResourceAccessTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceAccessTask</span>();<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>            thread.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有公平和非公平模式</strong> </p><h4 id="Semaphore原理"><a href="#Semaphore原理" class="headerlink" title="Semaphore原理"></a>Semaphore原理</h4><p>Semaphore（信号量）是一种并发编程中的同步工具，用于控制对共享资源的访问。它基于一个计数器和一组等待队列，用于管理许可的获取和释放。</p><ul><li>Semaphore内部维护着一个计数器，该计数器表示可用的许可数量。初始时，可以通过构造函数指定许可的数量<strong>。每次线程获取许可时，计数器会减少；每次线程释放许可时，计数器会增加。</strong></li><li>当一个线程想要获取许可时，它首先会检查计数器的值。如果计数器大于0，表示有可用的许可，线程可以继续执行，并且计数器会减少。<strong>如果计数器为0，表示没有可用的许可，线程需要等待，被放入等待队列中。</strong></li><li>当一个线程释放许可时，计数器会增加，并且会通知等待队列中的一个或多个等待线程，使它们能够竞争获取许可。</li></ul><h3 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch(倒计时器)"></a>CountDownLatch(倒计时器)</h3><h4 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是CountDownLatch？</h4><p><code>CountDownLatch</code> 是Java并发编程中的一种同步工具，它可以让一个或多个线程<strong>等待其他线程完成一组操作后再继续执行</strong>。</p><p>它基于计数的概念，线程在等待前先设置一个初始计数值，然后在需要等待的地方调用<code>await()</code>方法，直到计数值减到0时，等待的线程才会被释放，继续执行后续操作。</p><p><code>CountDownLatch</code> <strong>是一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>某个线程等待其他线程执行完毕才能执行<ul><li>如英雄联盟载入游戏机制，十位玩家都加载100%，才能执行进行游戏的线程</li><li>开始 <code>new CountDownLatch(10)</code>,每个玩家加载完毕执行<code>countDown()</code>，并且在载入游戏线程进行<code>await()</code></li></ul></li><li>实现多个线程同时开始执行<ul><li>开始<code>new CountDownLatch(1)</code>，对需要同时执行的线程进行<code>await()</code>，然后主线程开始后调用<code>countDown()</code>，多个await()线程同时唤醒</li></ul></li></ul><h3 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h3><p><code>CyclicBarrier</code>（循环屏障）是Java并发编程中的一种同步工具，它可以让一组线程相互等待，直到所有线程都达到一个共同的屏障点，然后同时继续执行后续操作。与<code>CountDownLatch</code>类似，<code>CyclicBarrier</code>也是基于计数的概念，<strong>但它的计数器可以循环使用，即当计数器的值减到0时，会自动重置为初始值。</strong></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。</p><p>如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><p>该栅栏处的屏障任务执行完成后，会重置count。</p><h4 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h4><ul><li>需要进行循环执行的时候，每一次循环需要多少线程，就设计多少个计数，不然可能会出现问题<ul><li>如循环调用 t1,t2，然后执行一次t3操作，即：t1,t2,t1,t2,t1,t2…….，t1耗时1s，t2耗时2s</li><li>此时计数为3，那么会运行 t1,t2,t1，但因为t1只需1s，先结束的是t1,t1，此时计数已经减到0，那么会执行被await()阻塞的操作t3，就没有达到 t1,t2,t3的效果。</li></ul></li></ul><h3 id="常见并发容器"><a href="#常见并发容器" class="headerlink" title="常见并发容器"></a>常见并发容器</h3><h4 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h4><ol><li>JDK1.7之前，以为是使用的头插法，所以在多线程情况下可能会导致<strong>环形链表</strong>，形成死链</li><li><strong>数据丢失问题</strong>，多个键值对分配到一个桶中，多个线程的HashMap的put会出现数据覆盖问题。<ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul></li><li>put导致size不正确，然后也可能导致数据覆盖<ul><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ul></li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code> 的源码比较庞大，这里简要概括一下其主要实现思路和关键部分，包括 JDK 1.7 和 JDK 1.8 两个版本。</p><p><strong>JDK 1.7 版本：</strong></p><p>在 JDK 1.7 中，<code>ConcurrentHashMap</code> 使用了分段锁（Segment）的机制，每个段相当于一个小的 <code>HashTable</code>，具体实现在 <code>Segment</code> 内。以下是主要的实现细节：</p><ol><li><strong>结构：</strong><ul><li><code>ConcurrentHashMap</code> 包含一个 <code>Segment</code> 数组，每个 <code>Segment</code> 内部维护一个 <code>HashEntry</code> 数组，<code>HashEntry</code> 存储键值对。</li><li><code>ConcurrentHashMap</code> 的整体结构是数组 + 链表。</li></ul></li><li><strong>分段锁：</strong><ul><li><code>Segment</code> 内部使用 <code>ReentrantLock</code> 来进行加锁，保护该段的读写操作。不同段之间的操作是并发的，提高了并发度。</li></ul></li><li><strong><code>put</code> 操作：</strong><ul><li><code>put</code> 操作首先计算键的哈希值，然后通过哈希值找到对应的 <code>Segment</code>。</li><li>在该 <code>Segment</code> 中进行插入操作，使用 <code>ReentrantLock</code> 保护该段。</li><li>如果链表过长，可能触发扩容操作。</li></ul></li><li><strong>扩容：</strong><ul><li><code>ConcurrentHashMap</code> 采用分段的扩容策略，每个 <code>Segment</code> 独立扩容，避免了整个表的扩容，减小了锁的粒度。</li></ul></li></ol><p><strong>JDK 1.8 版本：</strong></p><p>在 JDK 1.8 中，<code>ConcurrentHashMap</code> 的实现进行了较大改进，引入了更先进的数据结构，主要是数组 + 链表 + 红黑树，以及一些 CAS 操作。以下是主要的实现细节：</p><ol><li><strong>结构：</strong><ul><li><code>ConcurrentHashMap</code> 依然包含一个 <code>Node[]</code> 数组，每个节点是 <code>Node</code> 对象，存储键值对。</li><li><code>ConcurrentHashMap</code> 的整体结构是数组 + 链表 + 红黑树。</li></ul></li><li><strong>分段锁：</strong><ul><li>JDK 1.8 中不再使用 <code>Segment</code>，而是直接在数组的每个节点上使用 CAS 操作来保护节点的修改。</li><li>采用了 CAS 操作来保证并发写入的一致性，而不再需要显式的锁。</li></ul></li><li><strong>链表转红黑树：</strong><ul><li>当链表长度达到一定阈值（默认为8）时，链表会转换为红黑树，以提高查询性能。</li></ul></li><li><strong>扩容：</strong><ul><li>JDK 1.8 中对扩容进行了优化，引入了 <code>forwardingNodes</code> 机制，避免了重复计算哈希值，减少了扩容时的复制开销。</li><li>采用了 <code>tryPresize</code> 操作，提前计算新容量，然后使用 CAS 操作来尝试进行扩容。</li></ul></li></ol><p>总体来说，JDK 1.8 中的 <code>ConcurrentHashMap</code> 引入了更为先进的数据结构和并发控制机制，提高了性能和并发度。分段锁机制被替代为更轻量级的 CAS 操作，提升了在高并发场景下的性能。链表转红黑树等优化也使得 <code>ConcurrentHashMap</code> 在各种场景下表现更为优越。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/"/>
    <url>/2023/11/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<h2 id="登录注册实现"><a href="#登录注册实现" class="headerlink" title="登录注册实现"></a>登录注册实现</h2><hr><h3 id="整体思维框架"><a href="#整体思维框架" class="headerlink" title="整体思维框架"></a>整体思维框架</h3><h3 id="基于Redis优化session来进行短信登陆"><a href="#基于Redis优化session来进行短信登陆" class="headerlink" title="基于Redis优化session来进行短信登陆"></a>基于Redis优化session来进行短信登陆</h3><h4 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h4><ol><li>发送验证码<br>首先根据用户的手机号进行判断，是否合法，合法则可以进行发送验证码。通过session进行保存。</li><li>通过验证码进行登录，注册<br>通过实体LoginFormDTO，封装手机号，验证码，密码（暂时只考虑手机号和验证码），先进行手机号合法性的判断，合法再判断手机号和验证码是否与session中存储的一致。</li></ol><hr><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：当客户端访问某一个地址时，会将请求交给服务器进行处理，在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理，在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息，浏览器在接受响应后会按照cookie信息在客户端简历cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="D:\Blog\source\img\跨域访问.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。</li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回为每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="D:\Blog\source\img\session原理示意图.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li><p>cookie和session的比较：</p><ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="D:\Blog\source\img\cookie，session，令牌对比.png" alt="Alt text"></li></ul></li></ul><hr><ol><li>校验登陆状态，实现拦截<br>用户在进行请求时，会从cookie中携带JsessionId到服务端，服务端通过JsessionId从session中获取信息，没有session信息则进行拦截，有session信息则将用户信息保存到threadLocal中，并放行。<br>拦截器的实现：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2. 获取session中的用户信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//4. 不存在，则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br>        UserHolder.saveUser(user);<br>        <span class="hljs-comment">//6. 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Redis优化登录注册"><a href="#Redis优化登录注册" class="headerlink" title="Redis优化登录注册"></a>Redis优化登录注册</h4><ol><li>为什么需要优化？<br>因为session是存储在服务器之中的，所以当有多台tomcat时，会出现session共享问题，比如用户第一次访问了tomcat1，第二次访问了tomcat2，那么tomcat2中肯定没有存放用户的session信息，所以此时登录拦截会出现问题。不改变session存储的解决方案有：将完整session拷贝到每一台tomcat中，并且及时同步，这就带来了两个问题：<ol><li>每个tomcat都有完整session，会造成服务器压力过大。</li><li>拷贝session数据时，可能会出现延迟。</li><li>所以我们使用redis进行实现，因为redis本身就是可以共享的。</li></ol></li><li>redis实现</li><li>设计key</li></ol><ul><li><strong>由于redis全局共享</strong>，所以我们需要设计不重复，不暴露信息的key。可以直接让后台生成token进行业务。</li></ul><ol><li>登录后，根据手机号查询判断是否有用户信息 ，无则新建，将用户数据保存到redis，生成token作为key。有则进行校验，根据token判断数据是否存在。不存在则拦截，存在则将用户信息保存到threadLocal，并放行（token也存在请求头中）。</li><li>拦截器通过判断threadLocal是否为空进行判断拦截还是放行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-comment">//校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//校验验证码（从redis中）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<span class="hljs-comment">//获取用户输入的code</span><br>    <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>        <span class="hljs-comment">//不一致则报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建新用户并保存</span><br>        user = createUserWithPhone(phone);<span class="hljs-comment">//(user接收，便于保存)</span><br>    &#125;<br>    <span class="hljs-comment">//保存信息到redis</span><br>    <span class="hljs-comment">//随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> RedisConstants.LOGIN_USER_KEY + token;<br>    <span class="hljs-comment">//将user对象转为hash存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));<br>    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);<br>    <span class="hljs-comment">//设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//返回token</span><br>    <span class="hljs-comment">//session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>登录刷新问题<ul><li>通过拦截器查看用户是否在操作，如果没有操作超过30分钟，删除token，用户重新登录</li><li>通过查看请求，如果请求头中有token，那么我们刷新token存活时间。</li><li>拦截器优化：在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br><img src="D:\Blog\source\img\拦截器优化.png" alt="Alt text"></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//获取请求头之中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//基于token获取redis中的用户（get是根据key以及字段取值，entries是根据key取值）</span><br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash()<br>            .entries(token);<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//将查询到的hash数据转为userDTO</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap,<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(),<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//将userDTO信息保存到threadLocal</span><br>    UserHolder.saveUser(userDTO);<br>    <span class="hljs-comment">//刷新token的有效期</span><br>    stringRedisTemplate.expire(token,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);<br>    <span class="hljs-comment">//放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="商户缓存"><a href="#商户缓存" class="headerlink" title="商户缓存"></a>商户缓存</h2><hr><h3 id="缓存的基本知识"><a href="#缓存的基本知识" class="headerlink" title="缓存的基本知识"></a>缓存的基本知识</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><ol><li>缓存是数据交换的缓冲区，一般从数据库中获取，存储在本地。</li><li>redis缓存:由于其被static修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被final修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build();<br></code></pre></td></tr></table></figure><h4 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h4><ol><li>速度快</li><li>缓存数据存储在代码之中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户并发访问给服务器带来的读写压力。</li><li>实际开发之中，数据量往往很大，如果没有缓存作为“减震器”，系统很难支撑。</li><li>缓存会增加代码复杂度和运营成本。</li><li>降低后端负载，提高读写速度。</li><li>数据一致性成本，代码维护成本，运维成本。</li></ol><h4 id="商户缓存的使用"><a href="#商户缓存的使用" class="headerlink" title="商户缓存的使用"></a>商户缓存的使用</h4><ol><li>缓存作用模型：<br><img src="D:\Blog\source\img\缓存作用模型.jpg" alt="缓存作用模型"></li></ol><h3 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h3><ol><li><p>什么是缓存更新</p><ul><li>缓存更新就是为了节约内存而设计的，因为内存数据宝贵，当向redis插入太多数据时，可能会导致缓存中数据过多，所以需要对redis中的数据进行更新，或者淘汰。</li><li>内存淘汰：当redis数据大过我们设定的max_memory时，会自动触发淘汰机制，淘汰不重要的数据（可以自己设置策略）。</li><li>超时剔除：给redis数据设置ttl（time to live），redis会将超时的数据进行删除。</li><li>主动更新：手动调用方法删除缓存，通常用来解决缓存和数据库不一致的问题。</li></ul></li><li><p>业务场景</p><ul><li>低一致需求：使用内存淘汰机制，如店铺类型的查询缓存。</li><li>高一致需求：主动更新，以超时剔除兜底，如店铺详情查询。</li></ul></li><li><p>缓存不一致的解决方案：</p><ol><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li><li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li><li>目前采用的方案：方案一<ol><li>如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来</li><li>因为更新缓存读写操作麻烦，所以直接删除缓存，等有新数据再直接写入缓存，完成更新。</li></ol></li><li>保证数据库和缓存同时成功和失败：</li></ol><ul><li>单体系统：将缓存和数据库操作放在一个事务之中。</li><li>分布式系统：利用TCC等分布式事务方案</li></ul><ol start="6"><li>数据库 缓存：<ul><li><p>出现问题的原因就在于，在数据库操作和缓存更新中间的时间里，可能会有其他线程进行操作。比如当线程1进行删除操作时，在更新数据库完成前，另一个线程2进来查询，发现此时缓存未命中，于是查询未更新完的数据库，写入缓存。然后线程1的更新完成了，但是此时缓存中已经被线程2以脏数据写入，此时的缓存等于并没有更新，所以此时数据库和缓存仍然不一致。<br><img src="D:\Blog\source\img\先缓存再数据库.png" alt="先缓存再数据库"></p></li><li><p>因为数据库操作时间长，所以先删除缓存再更新数据库，在数据操作和删除缓存之间的危险时间更长。</p></li><li><p>先操作数据库，再删除缓存<br>线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题。<br><img src="D:\Blog\source\img\先数据库再缓存.png" alt="先数据库再缓存"></p></li></ul></li></ol></li></ol><h3 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透： 缓存穿透是指客户请求的数据在缓存和数据库之中都不存在，这样的请求会导致频繁的访问数据库。</p><pre><code class="hljs">1. 解决方案：缓存空对象  - 优点：实现简单，维护方便  - 缺点：额外的内存消耗，造成短期的不一致2. 布隆过滤  - 优点：内存占用少，没有多余key  - 实现复杂，可能误判</code></pre><ul><li><p>缓存空对象：当数据库和redis都没有该数据时，直接生成该数据&lt;key-“”&gt;存储到redis之中。所以有了额外的内存消耗，短期不一致是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过（因为这是插入语句，一般来说插入语句就是直接插入到数据库，然后通过key查询缓存，发现没有缓存再查询数据库，将key-value保存到redis，此时因为又存在redis，所以并不会对redis进行更新，得等到ttl过才会更新），所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了。</p></li><li><p>布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突</p></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul><li>缓存雪崩：是指在同一时间段，大量缓存的key同时失效，或者redis服务器宕机，导致大量的请求到达数据库，带来巨大的压力。</li><li>解决方案<ul><li>给不同的key添加不同的TTL，让其分批失效。</li><li>使用熔断机制，给流量设置一定阈值。</li><li>搭建redis集群（防止redis宕机）</li></ul></li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul><li>缓存击穿：与缓存雪崩类似，缓存雪崩是大规模的key失效，而缓存击穿是 一个 热点的Key（高并发访问，缓存业务重建业务复杂），有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。例如：一件抢购中的商品的key失效。</li><li>解决方案：<ul><li>互斥锁</li><li>逻辑过期</li></ul></li><li>互斥锁：利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题，线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。<br><img src="D:\Blog\source\img\互斥锁.png" alt="互斥锁"><ul><li>逻辑过期：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案<br>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据<br>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据。<br><img src="D:\Blog\source\img\逻辑过期.png" alt="逻辑过期"></li></ul></li><li>互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响</li><li>逻辑过期方案：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦。</li></ul><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><hr><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="全局id"><a href="#全局id" class="headerlink" title="全局id"></a>全局id</h4><ul><li>原因：<ul><li>抢购商品时，订单保存到订单表之中，如果将订单id设置为数据库的自增id的话，规律性太明显，并且单表数据量有限制。</li></ul></li><li>实现：<ul><li>符号位 + 时间戳 + 序列号</li></ul></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span>&#123;<br>        <span class="hljs-comment">//生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">//生成序列号</span><br>        <span class="hljs-comment">//获取当前日期，精确到天（将key以天分组，方便管理，并且解决redis自增上限问题）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">//自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">//拼接并且返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<span class="hljs-comment">//先左移32位，再或运算将count补上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现秒杀"><a href="#实现秒杀" class="headerlink" title="实现秒杀"></a>实现秒杀</h4><ul><li>秒杀券和其他普通优惠券类似，普通优惠券可以任意购买，而秒杀券需要在特定时间并且一人一单的方式进行抢购。券在一张表，包含所有的券，其中用一个字段标明其是否是秒杀券，并且还有一张秒杀券表，可采用类似于外键进行关联，其中包含的是秒杀券的一些特定信息（抢购时间，结束时间，库存等）。</li><li>抢秒杀券：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5. 扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>,voucherId)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">//6.1 设置订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">//6.2 设置用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//6.3 设置代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(id);<br>    <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>    save(voucherOrder);<br>    <span class="hljs-comment">//8. 返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><ul><li>上面代码有很明显的问题，就是在高并发场景下会出现超卖现象。原因就在于，在库存判断和库存扣除两步中并没有锁来约束。</li><li>我们可以进行加锁来解决：<ul><li>悲观锁<ul><li>悲观锁认为线程安全一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock等，都是悲观锁。</li></ul></li><li>乐观锁：<ul><li>乐观锁认为线程安全问题不一定发生，因此不加锁，只在数据更新的时候再去判断有没有其他线程对数据就进行了修改。<ul><li>如果没有修改，则认为自己是安全的，自己可以更新数据。</li><li>如果被其他线程进行了修改，则说明发生了安全问题，此时继续重试或者异常。</li></ul></li></ul></li><li>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</li><li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。</li></ul></li><li>在本项目中，并不需要指定版本号，可以使用stock进行替代，比较查询时的stock数据和修改时的数据库中的stock数据是否一致（因为stock只会减少，不会增加，因此不会出现aba问题，所以可以代替版本号）。</li></ul><h4 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h4><ul><li>操作逻辑，进行库存判断之后，根据订单表中的数据，判断用户是否已经购买过。<ul><li>购买过则不能下单</li></ul></li><li>初步逻辑：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一人一单逻辑</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果在多线程情况下，在执行一人一单的逻辑之前，在这个区间如果进来了多个线程，仍然能抢多张优惠券。即 线程1:库存充足-&gt;判断一人一单（此时该优惠券中并没有写入userid）-&gt;此时线程2：库存充足-&gt;优惠券无userid-&gt;线程2写入userid-&gt;线程1写入userid</li><li>解决办法<ul><li>添加悲观锁<ul><li>将一人一单后的逻辑写入一个方法createVouherOrder，并对该方法加锁。</li><li>但是此时的粒度太粗，当该方法有锁时，所有用户都无法进行此方法，而我们的目的是一人一单，所以这个锁，应该加在单个用户上，使用userid来标识。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 一人一单逻辑</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<span class="hljs-comment">//需要根据userid的字面量来进行加锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//5. 扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//6. 创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">//6.1 设置订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">//6.2 设置用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//6.3 设置代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setUserId(id);<br>        <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>        save(voucherOrder);<br>        <span class="hljs-comment">//8. 返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>    <span class="hljs-comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用AopContext.currentProxy()来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去IVoucherOrderService中创建createVoucherOrder方法</li><li>并且导入依赖aspectjweaver，以及在启动类加上注解@EnableAspectJAutoProxy(exposeProxy &#x3D; true)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h4><ul><li>通过加锁可以解决在单机情况下的一人一单问题，但是在集群模式下就不行了。<br><img src="D:\Blog\source\img\jvm锁.png" alt="jvm锁"></li><li>如上图所示，jvm中的锁都是按照单机为域划分的，所以在集群模式下我们需要使用分布式锁，即让锁不在jvm内部，而是让锁在jvm外，为公用的锁。</li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><ul><li>分布式锁：满足分布式系统或者集群模式下的多线程可见的并且可以互斥的锁。<br><img src="D:\Blog\source\img\分布式锁.png" alt="分布式锁"></li><li>分布式锁应该满足的条件：<ul><li>可见性：每个线程，每个服务器都能看到锁</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全</li></ul></li><li>常见的分布式锁：<ul><li>mysql</li><li>redis</li><li>zookeeper<br><img src="D:\Blog\source\img\常见分布式锁.png" alt="常见分布式锁"></li></ul></li><li>redis实现分布式锁：<ul><li>核心思路：利用redis的SETNX方法，当多个线程进入时，利用该方法获取锁，第一个线程进入时，redis则有这个key，返回1，表示他抢到了锁，那么他去执行业务，完成后，再删除锁，退出锁，没有抢到锁的线程则等待重试。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">//锁的前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//自动拆箱可能会出现null，这样写更稳妥</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//通过DEL来删除锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br><span class="hljs-comment">// 获取锁对象</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock(<span class="hljs-number">120</span>);<br><span class="hljs-comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许抢多张优惠券&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取代理对象</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    redisLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>redis分布式锁误删问题：<ul><li>逻辑说明：<ul><li>如果持有锁的线程1在内部出现了阻塞，导致锁ttl过期，自动释放。</li><li>此时线程2来获取锁，因为线程1已经释放了锁，所以线程2拿到了锁</li><li>现在线程1阻塞结束，继续执行业务，再释放锁。&#x2F;</li><li>此时会将线程2的锁释放。</li></ul></li><li>解决办法<ul><li>在线程释放锁的时候判断该锁是否是自己的。</li><li>实现：存入锁的时候放入自己的线程标识，释放的时候再对锁进行判断。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标识是否一致</span><br>    <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>分布式锁的原子性问题：</p><ul><li>更为极端的误删逻辑说明</li><li>假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制）</li><li>于是锁的TTL到期了，自动释放了</li><li>那么现在线程2趁虚而入，拿到了一把锁</li><li>但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑</li><li>但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了</li><li>那么就相当于判断标识那行代码没有起到作用</li><li>这就是删锁时的原子性问题</li><li>因为线程1的拿锁，判断标识，删锁，不是原子操作，所以我们要防止刚刚的情况</li></ul></li><li><p>使用lua脚本解决多条命令的原子性问题</p><ul><li>Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;其他参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure></li><li><p>但是此时分布式锁仍然存在问题：锁不住。</p><ul><li>因为当锁的ttl快到期的时候，我们并没有实现续期功能。</li><li>所以得依赖redisson来解决续期问题。</li></ul></li></ul><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><ul><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题<br><img src="D:\Blog\source\img\可重入锁.png" alt="可重入锁"></li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h4><ul><li>我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br><img src="D:\Blog\source\img\异步优化.png" alt="异步优化"></li><li></li></ul><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style><h2 id="探店、关注"><a href="#探店、关注" class="headerlink" title="探店、关注"></a>探店、关注</h2><hr><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能实现"><a href="#点赞功能实现" class="headerlink" title="点赞功能实现"></a>点赞功能实现</h4><ol><li>基本功能实现<ul><li>要求：<ul><li>同一个用户只能对同一篇笔记点赞一次，再点赞即取消点赞</li><li>当前用户若点赞则显示高亮（前端页面会根据是否点赞决定是否高亮），根据isLike属性判断</li></ul></li><li>实现：<ul><li>使用redis中的set集合来进行判断是否点赞过（下文会具体介绍）。</li><li>点赞判断使用blog实体中的isliked进行判断，</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注解通常用于实体类属性上，表示该属性不对应数据库表中的列。</span><br><span class="hljs-comment">//在这里，属性 isLike 被标记为 exist = false，</span><br><span class="hljs-comment">//意味着这个属性不会映射到数据库表的任何列。</span><br><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span>&#123;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//防止空指针</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;blog:liked&quot;</span>+blog.getId();<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key,userId.toString());<br>    blog.setIsLike(score != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>点赞排行榜实现<ul><li>要求：根据时间顺序展示点赞用户。</li><li>目前的问题：我们之前的点赞是放入set集合，无法进行时间的判断，所以我们此时可以使用Sortset（Zset），包含分数作为优先级。<br><img src="D:\Blog\source\img\list，set，sortedset对比.png" alt="对比"></li><li>解决方案：<ul><li>点赞使用zset保存，key是：”blog:liked”+id;（id是被点赞blogid），存储的元素是（userid（点赞人），分数（当前毫秒时间戳））</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br><br>       <span class="hljs-comment">// 获取当前登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>       <span class="hljs-type">Double</span> <span class="hljs-variable">haveScore</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>       <span class="hljs-keyword">if</span> (haveScore==<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//未点赞，可点赞</span><br>           <span class="hljs-comment">//数据库点赞数据+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//保存用户到redis的set集合</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().add(key,userId.toString(),System.currentTimeMillis());<span class="hljs-comment">//点赞榜单，使用sortedSet进行优化，以时间戳作为优先级排序</span><br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//已点赞，取消点赞</span><br>           <span class="hljs-comment">//数据库-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//将用户从redis的set集合移除</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>排行榜实现：根据博客查询redis集合（点赞人）-&gt; 按照指定顺序返回点赞人集合</li><li>关注点：如何在in的情况下按照指定顺序返回数据：见注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">//查询top5的点赞用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//解析出用户id</span><br>    <span class="hljs-keyword">if</span> (top5==<span class="hljs-literal">null</span>||top5.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">//in查询数据库是按照默认id顺序，所以需要进行指定顺序，order by field(id,5,1)#根据id按照5，1进行返回</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>    List&lt;User&gt; users = userService.query().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br>            .last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>)<br>            .list();<br>    List&lt;UserDTO&gt; userDTOS = users.stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">//返回userdto</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><h4 id="关注功能实现"><a href="#关注功能实现" class="headerlink" title="关注功能实现"></a>关注功能实现</h4><ul><li>简单实现 <ul><li>建立数据库表tb_follow，有userid，followUserid字段来实现关注功能</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">//获取当前登录的userId</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//查询当前用户是否关注了该笔记的博主</span><br>        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>        <span class="hljs-comment">//只查询一个count就行了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count(queryWrapper);<br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFellow)</span> &#123;<br>        <span class="hljs-comment">//获取当前用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//判断是否关注</span><br>        <span class="hljs-keyword">if</span> (isFellow) &#123;<br>            <span class="hljs-comment">//关注，则将信息保存到数据库</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//取关，则将数据从数据库中移除</span><br>            LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>            remove(queryWrapper);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共同关注功能实现<ul><li>利用redis的set集合存储用户的关注对象，对两个用户的关注对象集合求交集即可求出共同关注。下面为修改之后的关注功能实现，即将关注的对象加入redis中。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>     <span class="hljs-comment">//获取用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userDTO.getId();<br>     <span class="hljs-comment">//判断是否关注</span><br>     <span class="hljs-keyword">if</span> (isFollow)&#123;<br>         <span class="hljs-comment">//关注则新增数据</span><br>         <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>         follow.setUserId(userId);<br>         follow.setFollowUserId(followUserId);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注的用户的id，放进redis的set集合 ： sadd userId followerUserId</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().add(key,followUserId.toString());<br>         &#125;<br>     &#125;<span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//取关，删除数据</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                 .eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId)<br>                 .eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>,followUserId));<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注用户的id从redis移除</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().remove(key,followUserId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="推送功能实现"><a href="#推送功能实现" class="headerlink" title="推送功能实现"></a>推送功能实现</h4><ul><li>feed流<ul><li>当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂。</li><li>feed流有两种模式：<ul><li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等)</li><li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</li></ul></li></ul></li><li>Timeline三种模式：<ul><li>推</li><li>拉</li><li>推拉结合</li></ul></li><li>我们使用推模式进行实战<ul><li>需求：<ul><li>修改新增博客的业务，在博客保存到数据库的时候，也推送到粉丝的收件箱。</li><li>收件箱按时间戳排序</li><li>收件箱实现分页查询</li></ul></li><li>难点：<ul><li>传统情况下分页查询是根据角标进行，但是因为我们的feed数据会更新，同时脚标也会更新，所以不能使用脚标。<ul><li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页<br><img src="D:\Blog\source\img\角标变化.png" alt="角标变化"></li></ul></li><li>使用score来进行分页可以解决问题<ul><li>score使用时间戳来进行记录</li><li>根据集合名（当前登录id的关注集合），最小分数，最大分数，开始偏移量，查询个数 reverseRangeByScoreWithScores(key, 0, max, offset, 2);</li><li>每次查询完毕后需要返回最小时间戳，作为下次查询条件</li><li>偏移量的作用是防止出现相同时间戳的情况，为上次查询返回的相同最小时间戳的个数，关键，1最小时间戳（即最后一个），2相同</li><li>封装返回</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">//获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//查询用户收件箱（set(key（feed:userid),粉丝的id）)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;feed:&quot;</span>+userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>            <span class="hljs-comment">//查询的集合，最小分数值，最大分数值，起始偏移，查询数量</span><br>            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples==<span class="hljs-literal">null</span>||typedTuples.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//解析数据</span><br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple:typedTuples)&#123;<br>        <span class="hljs-comment">//获取id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> typedTuple.getValue();<br>        ids.add(Long.valueOf(id));<br>        <span class="hljs-comment">//获取score（时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (time==minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//解决sql in无法排序问题，手动指定顺序为传入的ids</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);              <span class="hljs-comment">//&quot;order by field(id,&quot; + &quot;3,4,5&quot; + &quot;)&quot;</span><br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>,ids).last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog:blogs)&#123;<br>        <span class="hljs-comment">//查询发布blog的用户信息</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">//查询当前用户是否给该blog点过赞</span><br>        isBlogLiked(blog);<br>    &#125;<br>    <span class="hljs-comment">//封装结果并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">scrollResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    scrollResult.setList(blogs);<br>    scrollResult.setOffset(os);<br>    scrollResult.setMinTime(minTime);<br>    <span class="hljs-keyword">return</span> Result.ok(scrollResult);<br>&#125;<br></code></pre></td></tr></table></figure> <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style><h2 id="附近商户、签到、UV统计"><a href="#附近商户、签到、UV统计" class="headerlink" title="附近商户、签到、UV统计"></a>附近商户、签到、UV统计</h2><hr><h3 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h3><ul><li>实现根据当前位置搜索附近商户，并排序。</li></ul><h4 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h4><ul><li>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。</li><li>根据商铺类型为key，写入类型相同的商铺的经度纬度信息，保存在一个ZSet中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取所有shop，并且根据shop类型进行分组，保存在Map中（shopid，shops）</span><br>    List&lt;Shop&gt; shopList = shopService.list();<br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">//map.entrySet()：获取所有的键值对集合</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        List&lt;Shop&gt; shops = entry.getValue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(shops.size());<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            <span class="hljs-comment">//将当前type的商铺都添加到locations集合中</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())));<br>        &#125;<br>        <span class="hljs-comment">//批量写入</span><br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>具体实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">//1. 判断是否需要根据距离查询</span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br>    <span class="hljs-comment">//2. 计算分页查询参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>    <span class="hljs-comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span><br>    <span class="hljs-comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span><br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(key,<br>            GeoReference.fromCoordinate(x, y),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));<br>    <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//4. 解析出id</span><br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    <span class="hljs-keyword">if</span> (list.size() &lt; from) &#123;<br>        <span class="hljs-comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    HashMap&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        ids.add(Long.valueOf(shopIdStr));<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>        distanceMap.put(shopIdStr, distance);<br>    &#125;);<br>    <span class="hljs-comment">//5. 根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        <span class="hljs-comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span><br>        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>    &#125;<br>    <span class="hljs-comment">//6. 返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>如何高效少内存的进行签到统计：<ul><li>使用31位bitMap来统计一个用户的一个月的签到情况，1为签到，0为未签到。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 写入Redis  BITSET key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如何获取本月连续签到的数据<ul><li>获取签到数据（从当前日期直到月初）</li><li>从末尾往前计算看有多少个连续的1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()<br>            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            count++;<br>        <span class="hljs-comment">//数字右移，抛弃最后一位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="uv统计"><a href="#uv统计" class="headerlink" title="uv统计"></a>uv统计</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><hr><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul><li>物理层关注的是如何在连接各种计算机的传输媒体上传输数据。</li><li>物理层的任务是尽可能的<strong>屏蔽掉不同的传输媒体和通信手段之间的差异，使链路层感受不到这种差异</strong><ul><li>为什么要进行屏蔽呢？<ul><li>不同的传输媒体和设备可能会是不同类型的硬件设备和接口，并且可能会有不同的传输速率，不同的信号类型等。</li><li>所以物理层可以通过对底层差异的屏蔽，使得上层协议独立于物理层的底层细节进行工作。</li><li>简单来说就是：物理层使不同设备不同条件 的情况下让上层感受不到差异，因此使得不需要“因地制宜”。</li></ul></li></ul></li></ul><h3 id="物理层之下的传输媒体"><a href="#物理层之下的传输媒体" class="headerlink" title="物理层之下的传输媒体"></a>物理层之下的传输媒体</h3><ul><li><p>传输媒体是计算机网络设备之间的<strong>物理通路</strong>，也称为传输介质或传输媒介。</p><ul><li>传输媒体在物理层之下，并且不包含在计算机网络体系结构之中。<br><img src="D:\Blog\source\img\包含传输媒体的结构.png" alt="包含传输媒体结构"></li></ul></li><li><p>分类：</p><ul><li>导向型传输媒体：<ul><li>导向型传输媒体是一种物理传输媒体，它提供了一个明确的路径，以引导信号或数据传输。<ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li></ul></li></ul></li><li>非导向型传输媒体：<ul><li>也称为无线传输媒体，不提供明确的物理路径来引导信号传输。相反，它们使用无线信号（通常是电磁波或无线电波）来传输数据。<ul><li>无线电波</li><li>红外线</li><li>激光</li></ul></li></ul></li></ul></li><li><p>传输方式</p><ul><li>串行传输和并行传输：<ul><li>串行传输：<ul><li>串行传输是一种将数据位按照顺序一个接一个地传输的方式</li><li>在串行传输中，每个数据位都依次发送或接收，而且它们之间通常使用一个单独的信号线来传输。</li><li>通常用于长距离通信，因为它能够更好地保持数据的完整性，减少干扰和数据丢失的可能性。</li></ul></li><li>并行传输<ul><li>并行传输是一种同时传输多个数据位的方式。</li><li>在并行传输中，每个数据位都有自己的信号线，它们可以同时传输，因此在同一时间段内可以传输多个数据位。</li><li>并行传输同时传输多个数据位，适用于高速数据传输，但通常在短距离内使用。<br><img src="D:\Blog\source\img\串行传输和并行传输.png" alt="串行传输和并行传输"></li></ul></li></ul></li><li>同步传输和异步传输：<ul><li>同步传输<ul><li>同步传输是一种以固定的时间间隔或时钟信号来传输数据的方式。</li><li>在同步传输中，数据被划分为块（帧）并以固定的速率传输，通常使用一个时钟信号来同步发送和接收端的数据传输。这样，接收端知道何时开始接收和解析数据，因为它可以根据时钟信号的节奏来同步数据位。</li></ul></li><li>异步传输<ul><li>异步传输是一种在数据帧之间没有固定的时间间隔或时钟信号的传输方式。</li><li>在异步传输中，数据帧的开始和结束由特殊的控制字符（称为起始位和停止位）标识，而不是通过定期的时钟信号。</li></ul></li></ul></li><li>单向通信、双向交替通信和双向同时通信<ul><li>单向通信：</li><li>双向交替通信：</li><li>双向同时通信：<br><img src="D:\Blog\source\img\单向通行等.png" alt="单向通信等"></li></ul></li></ul></li></ul><h3 id="调制与编码"><a href="#调制与编码" class="headerlink" title="调制与编码"></a>调制与编码</h3><ul><li>调制与编码的作用<ul><li>编码：编码是将数字数据（0和1）转换为适合于传输媒体的信号的过程。</li><li>调制：调制是将数字信号转换为模拟信号（通常是电磁波）的过程。这是为了在无线通信或光纤通信等介质中传输数据。<br><img src="D:\Blog\source\img\调值与编码基本概念.png" alt="调制与编码的作用"></li></ul></li><li>码元：在使用时间域的波形表示信号时，代表不同离散数值的<strong>基本波形</strong>称为码元。</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li>信道复用技术：<ul><li>是一种用于在通信系统中有效地共享和利用通信信道的方法。它允许多个通信设备或数据流共享同一个物理信道，从而提高了通信系统的效率和资源利用率。</li><li>就是在一条传输媒体上同时传输多路用户的信号。</li></ul></li><li>常用技术：<ul><li>频分复用：<ul><li>频分复用将频率范围划分为多个不重叠的子信道，每个子信道用于一个通信设备或数据流。每个设备在其分配的频率带宽内进行通信。</li></ul></li><li>时分复用：<ul><li>时分复用将时间划分为若干个时隙（time slots），每个时隙用于一个通信设备或数据流。多个设备按时间顺序轮流使用信道，以便在不同的时间间隙内进行通信。</li></ul></li><li>波分复用：<ul><li>WDM是光纤通信中的一种频分复用技术，它利用不同波长（颜色）的光信号来传输多个数据流。每个波长对应一个不同的通信通道。</li></ul></li><li>码分复用：<ul><li>类似于一句话可以有不同的解释，每个设备都有自己的解释理论，因此实现一句话传输多种信息（每种设备根据自己的解密方式获取一种信息）</li></ul></li></ul></li></ul><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><hr><h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><ul><li>链路层<ul><li>它的主要功能是在物理介质上<strong>可靠地传输数据帧</strong>，并提供一些基本的<strong>错误检测</strong>和<strong>纠正机制</strong>。</li><li>它负责在物理层提供的传输介质上实现可靠的数据传输，同时进行<strong>地址解析</strong>、<strong>错误检测</strong>和<strong>流量控制</strong>等操作，以确保数据正确、高效地传输。</li></ul></li><li>与物理层的联动<ul><li>物理层和链路层共同协同工作，以实现端到端的数据传输。</li><li>物理层提供了将比特从一台计算机传输到另一台计算机的物理手段，而链路层在这些物理媒体上创建了数据帧，并确保这些数据帧能够准确无误地从一个节点传输到另一个节点。</li></ul></li><li>链路，数据链路，帧<ul><li>链路<ul><li>链路（Link）是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</li></ul></li><li>数据链路<ul><li>数据链路（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li></ul></li><li>帧<ul><li>帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。<br><img src="D:\Blog\source\img\链路层帧示意.png"></li></ul></li></ul></li></ul><h3 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h3><ul><li><p>封装成帧和透明传输</p><ul><li>封装成帧<ul><li>封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加一个首部和一个尾部，使之成为帧。</li><li>帧是数据单元，那么传输的时候是以一连串的比特流进行传输，一次可能传输若干个帧，所以我们如何确定帧呢？<ul><li>我们可以在帧的首部和尾部添加标识进行定界<br><img src="D:\Blog\source\img\封装成帧.png"></li></ul></li><li>此时会面临一些问题<ul><li>当我们传输的数据里面有和定界标识符一样的数据怎么办呢？接收方如何确定该帧的界限呢？</li></ul></li><li>透明传输<ul><li>透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在一样。<ul><li>如何理解呢？<ul><li>首先，我们为什么要使用帧呢？<ul><li>前面已经说了，将数据封装成帧后，可以在链路层实现错误的检测，纠正以及地址的解析。</li></ul></li><li>但是有了帧就会出现一些负面问题，如我们上面所说的，对帧的界限识别出现差错。<ul><li>所以为了得到帧的好处消除帧的坏处，我们就要实现透明传输：实现链路层的功能，但是好像数据链路层不存在一样（消除副作用）。</li></ul></li></ul></li><li>解决帧的界限问题<ul><li>面向字节的物理链路使用字节填充的方法实现透明传输<ul><li>我们发送时对数据进行扫描，在界限符前面，以及转义符前面添加转义符。</li></ul></li><li>面向比特的物理链路使用比特填充的方法实现透明传输<ul><li>即挑选比较特别的码作为帧的界限符（如0111110），我们发送时对数据进行扫描，每5个1就在其中插入一个0，由此实现了数据区不会出现帧的界限符的情况，在接收时，我们再按照指定的方法将数据区的0删除即可还原为原数据。<br><img src="/source/img/%E8%A7%A3%E5%86%B3%E5%B8%A7%E7%95%8C%E9%99%90%E9%97%AE%E9%A2%98.png"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>差错检测</p><ul><li>误码的相关概念<ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为比特差错）。<ul><li>比特0 -&gt; 比特1，比特1 -&gt; 比特0</li></ul></li><li>使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul></li><li>如何检验呢？<ul><li>奇偶校验<ul><li>奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。</li><li>偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。</li><li>但是此方法容易出现漏检。</li></ul></li><li>循环冗余校验<ul><li>数据链路层广泛使用漏检率极低的循环冗余校验（Cyclic Redundancy Check，CRC）检错技术。<ul><li>收发双方约定好一个生成多项式G(X)。</li><li>发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码（冗余码），将冗余码添加到待发送数据的后面一起传输。</li><li>接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。</li></ul></li></ul></li></ul></li></ul></li><li><p>可靠传输</p><ul><li>可靠传输的相关概念<ul><li>使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特差错）。</li><li>出现差错之后该怎么办呢？<ul><li>数据链路层为上层提供服务有两种情况<ul><li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li><li>可靠传输服务：通过某种机制实现：发送方发送什么，接收方就接收什么。</li></ul></li></ul></li><li>传输差错<ul><li>误码</li><li>分组丢失</li><li>分组失序</li><li>分组重复</li></ul></li><li>可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。</li><li>可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求。</li></ul></li><li>可靠传输的实现<ul><li>停止-等待协议<ul><li>发送方发送数据给接收方 -&gt; 接收方进行差错检测，无差错，则接收，并且返回确认接收了该分组。如果有误码，接收方则丢弃，并且返回否认接收了该分组。</li><li>此时存在问题<ul><li>接收方若未接到数据，会进行无限制的等待<ul><li>所以在发送方添加超时计时器，每当发送一组数据后就启动计时器，长时间未返回结果，则重新发送</li></ul></li><li>传输可能出现重复，接收返回请求也可能出现错乱<ul><li>对发送方的数据分组进行编号</li><li>对接收方返回的接收或者否认进行编号<br><img src="D:\Blog\source\img\超时等待协议.png"></li></ul></li></ul></li></ul></li><li>回退N帧协议<ul><li>是对停止等待协议的优化：回退N帧协议采用流水线传输方式，并且利用发送窗口来限制发送方连续发送数据分组的数量<br><img src="D:\Blog\source\img\回退n帧优化.png">  </li><li>简单来说就是： 允许发送方连续发送多个数据包，而不需要等待每个数据包的确认。接收方使用一个窗口大小来指示可以接收的下一个期望的数据包序号。这种方法可以提高传输效率。</li><li>具体见高军老师ppt<br><img src="D:\Blog\source\img\回退n帧示意.png"> </li><li>回退N帧协议的接收方采用累积确认方式。<ul><li>接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。</li><li>接收方何时发送累积确认分组，由具体实现决定。</li><li>确认分组ACKn表明序号为n及之前的所有数据分组都已正确接收。</li><li>优点：<ul><li>减少向网络中注入确认分组的数量。</li><li>即使确认分组丢失，也可能不必重传数据分组。</li></ul></li><li>缺点：<ul><li>不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。</li></ul></li></ul></li><li>发送窗口𝑾_𝑻的取值范围是𝟏&lt;𝑾_𝑻≤ 2的n次方 - 1 ，如果超出范围，可能会出现分清楚此时传输的比特是新传输的还是重新传输的</li></ul></li><li>选择重传协议<ul><li>是对回退N帧协议的优化</li><li>为了使发送方仅重传出现差错的数据分组，接收方不再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。<br><img src="D:\Blog\source\img\选择性重传示意.png">  </li><li>发送窗口和接收窗口的最大值为：2的（n-1）次方，若故意取𝑾_𝑻&#x3D;𝟓，使得𝑾_𝑻+𝑾_𝑹≥𝟐^𝟑，接收方将无法分辨新旧数据分组</li></ul></li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>以太网（Ethernet）是一种计算机网络技术，用于在局域网（LAN）中传输数据。它是最常见和广泛应用的局域网技术之一。</li><li>以太网使用一种称为CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection，具有载波侦听和冲突检测的多路访问）的协议来控制多台计算机同时访问网络时的数据冲突问题。</li><li>它采用了一种总线拓扑或星型拓扑的物理结构，允许多台计算机通过共享相同的传输媒介（通常是电缆或光纤）来进行通信。</li></ul><h4 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h4><ul><li>网络适配器和MAC地址<ul><li>网络适配器<ul><li>要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），网络适配器一般简称为“网卡”。</li><li>网络适配器是计算机与网络之间的桥梁，它负责管理数据在计算机和网络之间的传输，确保网络通信的顺畅和可靠性。</li><li>作用：<ul><li>连接计算机到网络</li><li>数据封装和解封</li><li>MAC地址管理：MAC地址用于在局域网中识别计算机和其他设备。网络适配器负责管理和维护这个地址。</li><li>网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换。<ul><li>在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I&#x2F;O总线以并行传输方式进行。</li><li>网卡与外部以太网（局域网）之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以串行方式进行的。<br><img src="D:\Blog\source\img\网卡的传输方式.png"></li></ul></li></ul></li></ul></li><li>MAC地址(物理地址，硬件地址)<ul><li>作用：使信息可以被准确的发送和接收</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li><li>在每个主机发送的帧的首部中，都携带有发送主机（源主机）和接收主机（目的主机）的数据链路层地址。由于这类地址是用于媒体接入控制（Medium Access Control，MAC）的，因此被称为MAC地址<br><img src="D:\Blog\source\img\mac地址作用.png"> </li><li>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。（如一个交换机有多个接口，所以可能会有多个MAC地址）</li><li>网卡从网络上每收到一个帧，就检查帧首部的目的MAC地址，进行如下的操作：<ol><li>如果目的MAC地址是广播地址（FF-FF-FF-FF-FF-FF），则接受该帧。</li><li>如果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。</li><li>如果目的MAC地址是网卡支持的多播地址，则接受该帧。</li><li>其他情况丢弃该帧</li></ol></li></ul></li></ul></li><li>CSMA&#x2F;CD协议<ul><li>引出<ul><li>由于共享型以太网有着天然广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点。</li><li>当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。<br><img src="D:\Blog\source\img\信号碰撞.png"></li></ul></li><li>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA&#x2F;CD，它是载波监听多址接入&#x2F;碰撞检测（Carrier Sense Multiple Access Collision Detection）的英文缩写词。<ul><li>多址接入MA<ul><li>多个站点连接在一条总线上，竞争使用总线。</li></ul></li><li>载波监听CS<ul><li>每个站点在发送帧之前，先要检测一下总线上是否有其他站点在发送帧（“先听后说”）<ul><li>若检测到总线空闲96比特时间（发送96比特所耗费的时间，也称为帧间最小间隔），则发送这个帧；</li><li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。</li></ul></li></ul></li><li>碰撞检测CD<ul><li>每个正在发送帧的站点边发送边检测碰撞（“边说边听”）：<ul><li>一旦发现总线上出现碰撞，立即停止发送，退避一段随机时间后再次从载波监听开始进行发送（“一旦冲突，立即停说，等待时机，重新再说”）。</li></ul></li></ul></li></ul></li><li>共享式以太网的争用期<ul><li>站点从发送帧开始，最多经过时长𝟐𝝉 （即𝜹→𝟎）就可检测出所发送的帧是否遭遇了碰撞。</li><li>共享总线以太网的端到端往返时间𝟐𝝉被称为争用期（Contention Period）或碰撞窗口（Collision Window）</li></ul></li><li>最小帧长和最大帧长<ul><li>最小帧长<ul><li>最小帧长是指以太网数据帧（Ethernet Frame）在物理层上必须具备的最小长度。以太网的最小帧长是64字节（包括64字节的数据和4字节的帧校验序列）。</li><li>这个最小帧长度是为了确保在网络中的数据帧在传输过程中具有足够的时间，以便其他设备能够检测到帧的存在，避免碰撞和丢失数据。</li></ul></li><li>最大帧长<ul><li>最大帧长是指以太网数据帧在物理层上允许的最大长度。以太网的最大帧长是1518字节（包括数据、帧头、帧校验序列和帧间隙）。</li><li>这个最大帧长度限制是为了确保在网络中传输的数据帧不会过大，从而防止网络拥塞和数据丢失。</li></ul></li></ul></li><li>共享式以太网的退避算法<ul><li>在使用CSMA&#x2F;CD协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。</li><li>共享总线以太网中的各站点采用截断二进制指数退避（Truncated Binary Exponential Backoff）算法来选择退避的随机时间。</li></ul></li></ul></li><li>使用集线器的共享式以太网<ul><li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器（Hub）。<br><img src="D:\Blog\source\img\集线器以太网.png"></li></ul></li><li>物理层扩展以太网<ul><li>扩展传输距离：<ul><li>在10BASE-T星型以太网中，可使用光纤和一对光纤调制解调器来扩展站点与集线器之间的距离。<br><img src="D:\Blog\source\img\光纤扩展距离.png"></li></ul></li><li>扩展覆盖范围和数量<ul><li>以太网集线器一般具有8~32个接口，如果要连接的站点数量超过了单个集线器能够提供的接口数量，就需要使用多个集线器，这样就可以连接成覆盖更大范围、连接更多站点的多级星型以太网。<br><img src="D:\Blog\source\img\集线器扩展范围和数量.png"> </li><li>碰撞域<ul><li>指的是共享同一物理网络媒介的设备集合，它们在发送数据时可能会发生碰撞<br><img src="D:\Blog\source\img\扩展范围的碰撞域.png"> </li><li>在物理层扩展的共享式以太网仍然是一个碰撞域，不能连接太多的站点，否则可能会出现大量的碰撞，导致平均吞吐量太低。</li></ul></li></ul></li></ul></li><li>数据链路层扩展以太网</li><li>网桥<ul><li>网桥是计算机网络中的网络设备，通常用于连接两个或多个局域网（LAN）或网络段，以便在它们之间传输数据</li><li>作用：<ul><li>网桥可以识别帧的结构。</li><li>网桥可以根据帧首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃所收到的帧。<br><img src="D:\Blog\source\img\网桥工作基本原理.png"></li></ul></li><li>网桥的自学习和转发帧<ul><li>转发表是如何建立的呢？<ul><li>透明网桥（Transparent Bridge）通过自学习算法建立转发表。</li><li>透明网桥中的“透明”，是指以太网中的各站点并不知道自己所发送的帧将会经过哪些网桥的转发，最终到达目的站点。也就是说，<strong>以太网中的各网桥对于各站点而言是看不见的</strong>。</li></ul></li><li>自学习和转发流程 ：<ol><li>网桥收到帧后进行登记（即自学习），登记的内容为帧的源MAC地址和进入网桥的接口号。</li><li>网桥根据帧的目的MAC地址和网桥的转发表对帧进行转发，包含以下三种情况：<ol><li><strong>明确转发：</strong>网桥知道应当从哪个接口转发帧。</li><li><strong>盲目转发：</strong>网桥不知道应当从哪个接口转发帧，只能将其通过除进入网桥的接口外的其他所有接口转发。</li><li><strong>丢弃：</strong>网桥知道不应该转发该帧，将其丢弃。</li></ol></li></ol></li></ul></li></ul></li></ul><h4 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h4><ul><li>以太网交换机（以下简称交换机）本质上就是一个多接口的网桥：<ul><li>交换机自学习和转发帧的流程与网桥是相同的</li><li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机。</li><li>当交换机的接口与计算机或交换机连接时，可以工作在全双工方式，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞地传输数据，这样就不需要使用CSMA&#x2F;CD协议了。<br><img src="D:\Blog\source\img\交换机工作.png"></li></ul></li></ul><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><ul><li>诞生背景：<ul><li>将多个站点通过一个或多个以太网交换机连接起来就构建出了交换式以太网。</li><li>交换式以太网中的所有站点都属于同一个广播域。</li><li>随着交换式以太网规模的扩大，广播域也相应扩大，<strong>巨大的广播域会带来一系列问题</strong><ul><li>广播风暴：广播风暴会浪费网络资源和各主机的CPU资源</li><li>难以管理和维护，带来潜在安全问题</li></ul></li></ul></li><li>分割广播域可以解决广播域太大导致的问题<ul><li>使用路由器可以隔离广播域（成本高）</li><li>虚拟局域网技术</li></ul></li><li>虚拟局域网（Virtual Local Area Network，VLAN）是一种将<strong>局域网内的站点划分成与物理位置无关的逻辑组的技术</strong>，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求。<ul><li>属于同一VLAN的站点之间可以直接进行通信，而不同VLAN中的站点之间不能直接通信。</li><li>连接在同一交换机上的多个站点可以属于不同的VLAN，而属于同一VLAN的多个站点可以连接在不同的交换机上。</li></ul></li><li>实现机制<ul><li>Access端口（默认）<ul><li>给“未打标签”的MAC帧打标签（根据端口自己的PVID），将PVID存入帧的VID中</li><li>若帧中的VID和接口的PVID值相同，则给帧去除标签，再进行转发，否则不转发</li></ul></li><li>Trunk端口<ul><li>既可以接收“未打标签”的MAC帧，也可以接收“已打标签”的802.1Q帧。若接收到普通以太网MAC帧时，根据接收帧的接口的PVID给帧“打标签”，这与Access接口的处理相同。</li><li>对于帧的VID值等于接口的PVID值的802.1Q帧，将其“去标签”转发；对于<strong>帧的VID值不等于接口的PVID值802.1Q帧</strong>，将其<strong>直接转发</strong>。因此，从Trunk接口转发出的帧，可能是普通以太网MAC帧，也可能是802.1Q帧。</li></ul></li></ul></li></ul><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><ul><li>802.11无线局域网使用CSMA&#x2F;CA协议的原因<ul><li>对于802.11无线局域网，其使用无线信道传输数据，这与共享总线以太网使用有线传输介质不同。因此，802.11无线局域网<strong>不能简单照搬共享总线以太网使用的CSMA&#x2F;CD协议</strong>。<ul><li>由于无线信道的<strong>传输环境复杂且信号强度的动态范围非常大</strong>，在802.11无线网卡上接收到的信号强度一般都<strong>远远小于发送信号的强度</strong>，信号强度甚至相差百万倍。因此，如果要在802.11无线网卡上实现碰撞检测，对硬件的要求非常高。</li><li>即使能够在硬件上实现碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），还会<strong>出现无法检测到碰撞</strong>的情况，因此实现碰撞检测并没有意义。</li></ul></li></ul></li><li>无线局域网不能简单照搬共享总线以太网（有线局域网）使用的CSMA&#x2F;CD协议，而是不再实现碰撞检测CD功能，但在<strong>CSMA的基础上增加碰撞避免CA功能</strong>，即使用CSMA&#x2F;CA协议。<ul><li>CSMA&#x2F;CA协议<ul><li>若站点最初有数据要发送(而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA&#x2F;CA协议的退避算法。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器时间减少到零时(这时信道只可能是空闲的)，站点就发送整个的帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的步骤(2)开始，执行CSMA&#x2F;CA协议的退避算法，随机选定一段退避时间。</li><li>若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间)，就必须重传此帧(再次使用CSMA&#x2F;CA协议争用接入信道)，直到收到确认为止，或者经过若干次的重传失败后放弃发送。<br><img src="D:\Blog\source\img\CSMACA退避算法.png"></li></ul></li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><hr><h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><ul><li>网络层的作用：<ul><li>网络层的主要任务就是<strong>将分组从源主机经过多个网络和多段链路传输到目的主机</strong>，可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。<ul><li>分组转发：根据转发表来确定向自己的哪个接口进行转发（转发表来自路由表）</li><li>路由选择：路由表来自<strong>路由选择协议</strong></li></ul></li></ul></li><li>网络层向上提供的两种服务：<ul><li><p>面向连接的虚电路服务<br><img src="D:\Blog\source\img\面向连接的虚电路服务.png"> </p><ul><li>核心思想：<strong>可靠通信应由网络自身来保证</strong></li><li>必须首<strong>先建立网络层连接</strong>，保证通信双方所需的一切资源</li><li>通信双方沿着<strong>已经建立的虚电路</strong>发送分组</li><li>通信结束后，需要<strong>释放</strong>之前建立的虚电路</li><li>类似于在双方的网络层之间添加了一条“电话线”，不过是通过链路，路由器来模拟的。</li><li>表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li></ul></li><li><p>无连接的数据报服务<br><img src="D:\Blog\source\img\无连接的数据报服务.png"> </p><ul><li>核心思想：<strong>可靠通信应由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li>每个分组可以走<strong>不同的路径</strong>，因此，每个分组的首部<strong>必须携带目的主机的完整地址</strong></li><li>通信结束后，<strong>没有需要释放的连接</strong></li></ul></li></ul></li></ul><h3 id="网际协议（IP）"><a href="#网际协议（IP）" class="headerlink" title="网际协议（IP）"></a>网际协议（IP）</h3><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>为什么要有IP以及其作用是什么？<ul><li>为什么?<ul><li>网络互联时<strong>结构各不相同</strong>，要将众多的异构型网络都互联，并且要让其可以进行<strong>互相通信</strong>，则会面临许多需要解决的问题：如网络接入机制，差错恢复方法，寻址方案等</li></ul></li><li>作用：<br><img src="D:\Blog\source\img\ip协议作用.png"><ul><li>IP协议使得网络层可以<strong>屏蔽底层细节</strong>而专注网络层的数据转发  </li><li>当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们<strong>看不见互连的各网络的具体异构细节</strong>。</li></ul></li></ul></li></ul><h4 id="IPv4地址及其编制方法"><a href="#IPv4地址及其编制方法" class="headerlink" title="IPv4地址及其编制方法"></a>IPv4地址及其编制方法</h4><ul><li><p>IPv4地址概述</p><ul><li>IP是以网卡进行分配</li><li>IPv4地址是给因特网（Internet）上的<strong>每一个主机（或路由器）的每一个接口分配的</strong>一个在<strong>全世界范围内唯一</strong>的32比特的标识符。</li></ul></li><li><p>IPv4表示方法</p><ul><li>由于IPv4地址由32比特构成，不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</li></ul></li><li><p>IPv4地址的分类编址方法</p><ul><li><p>为什么要进行分类呢？</p><ul><li>由于不同分类下的IPV4地址可以更好的进行管理和分配</li><li>早期设计不灵活，由于需求的增加而新增一些分类，不同分类可以根据网络的主机规模来考虑</li></ul></li><li><p>32比特的IPv4地址分为：<strong>网络号</strong> + <strong>主机号</strong></p></li><li><p>网络号</p><ul><li>标志主机（或路由器）的接口所<strong>连接到的网络</strong></li><li>同一个网络中，<strong>不同主机（或路由器）的接口</strong>的IPv4地址的<strong>网络号必须相同</strong>，表示它们属于同一个网络。</li></ul></li><li><p>主机号</p><ul><li>标识主机（或路由器）的接口号</li><li><strong>同一个网络</strong>中，<strong>不同</strong>主机（或路由器）的接口的IPv4地址的主机号必须各不相同，以便<strong>区分各主机（或路由器）的接口</strong>。</li></ul></li><li><p>分类：<br><img src="D:\Blog\source\img\IPv4地址分类.png"></p><ul><li>分为A,B,C,D,E，差异见图</li><li>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</li><li>主机号为 <strong>“全0”</strong> 的地址是<strong>自身的网络地址</strong>（标识本网络），不能分配给主机（或路由器）的各接口。</li><li>主机号为 <strong>“全1”</strong>的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</li><li><img src="D:\Blog\source\img\A类地址.png"></li><li><img src="D:\Blog\source\img\B类地址.png"></li><li><img src="D:\Blog\source\img\C类网络.png"></li></ul></li><li><p><img src="D:\Blog\source\img\各网络分类对比.png"></p></li></ul></li></ul><p>多播地址是用于多播通信的特殊IP地址，多播允许将<strong>数据同时发送给一个组中的多个目标设备</strong>。即将数据发送给<strong>多播组</strong></p><h4 id="Ipv4地址划分子网编址方法"><a href="#Ipv4地址划分子网编址方法" class="headerlink" title="Ipv4地址划分子网编址方法"></a>Ipv4地址划分子网编址方法</h4><ul><li>为什么？<ul><li>随着更多的中小网络加入因特网，<strong>IPv4分类编址方法</strong>不够灵活、容易造成<strong>大量IPv4地址资源浪费</strong>的缺点就暴露出来了。</li><li>例如一个只有几个接口的网络申请一个A类地址，一个A类地址可以包含数千万接口，但只使用了几个，造成大量浪费。<br><img src="D:\Blog\source\img\分类编址浪费.png"></li></ul></li><li>子网<ul><li>子网就是前几位都相同，然后中间使用几位来划分子网，然后后几位再分配给设备接口。</li><li>如145.13.<strong>0</strong>.20和145.13.<strong>1</strong>.20，两者都是网络 145.13 以及用户接口 20，但是是不同子网 0,1，<strong>网络号+子网号+用户号</strong></li><li>子网地址其实属于网络地址</li></ul></li><li>子网掩码<ul><li>产生原因<ul><li>我们如何从网络地址中区分出子网地址在哪里？又是多少位呢？</li></ul></li><li>作用<ul><li><strong>子网掩码</strong>可以表明分类IPv4地址的<strong>主机号部分被借用了几个比特</strong>作为子网号。</li></ul></li><li>与IPv4地址类似，子网掩码也是由32比特构成的。<ul><li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li><li>之后的多个连续的比特0对应IPv4地址中的主机号。</li></ul></li><li>子网计算：<ul><li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，就可得到该IPv4地址所在子网的网络地址。<br><img src="D:\Blog\source\img\子网掩码获取子网网络地址.png"><br><img src="D:\Blog\source\img\子网掩码例题.png"></li></ul></li></ul></li></ul><h4 id="Ipv4无分类编址方法"><a href="#Ipv4无分类编址方法" class="headerlink" title="Ipv4无分类编址方法"></a>Ipv4无分类编址方法</h4><ul><li>起因：<ul><li>IPv4地址的划分子网编址方法在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网(𝟐^(𝟐𝟒−𝟑)&#x3D;𝟐𝟎𝟗𝟕𝟏𝟓𝟐)由于其每个网络所包含的地址数量太小(𝟐^𝟖&#x3D;𝟐𝟓𝟔)，因此并没有得到充分使用，而因特网的IPv4地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li><li>为此，因特网工程任务组IETF又提出了<strong>采用无分类编址</strong>的方法，来解决IPv4地址资源紧张的问题，同时还专门成立IPv6工作组负责研究新版本的IP，以彻底解决IPv4地址耗尽问题。</li><li>1993年，因特网工程任务组IETF发布了<strong>无分类域间路由选择（Classless Inter-Domain Routing，CIDR ）</strong>的RFC文档[RFC1517~1519，RFC1520]。<ul><li>CIDR消除了传统A类、B类和C类地址以及划分子网的概念。</li><li>CIDR可以更加有效地分配IPv4地址资源，并且可以在IPv6使用之前允许因特网的规模继续增长。</li></ul></li></ul></li><li>构成<ul><li>无分类编址方法使用的<strong>地址掩码</strong>与划分子网使用的<strong>子网掩码</strong>类似，由32比特构成。<ul><li>左起连续比特1为对应的网络前缀</li><li>之后的连续比特0为对应的主机号<br><img src="D:\Blog\source\img\无分类掩码示例.png"></li></ul></li><li>为了简便起见，<strong>可以不明确给出配套的地址掩码的点分十进制形式</strong>，而是在无分类编址的IPv4地址后面<strong>加上斜线“&#x2F;”</strong>，在斜线之后写上网络前缀所占的比特数量（也就是地址掩码中左起连续比特1的数量），这种记法称为<strong>斜线记法</strong>。如：<strong>128.14.35.7 &#x2F; 20</strong>，则标识网络前缀是前20比特，主机号是32-20 &#x3D; 12比特</li></ul></li><li>好处<ul><li>使用无分类编址方法，可以根据客户的<strong>需要分配适当大小的CIDR地址块</strong>，因此可以更加有效地分配IPv4的地址空间。（因为主机号确定了用户数量，根据自定义的地址掩码，也可以操作主机号大小）</li><li>使用无分类编址方法的另一个好处是<strong>路由聚合</strong>（也称为构造超网）。 <ul><li>路由聚合就是：找到最大前缀<br><img src="D:\Blog\source\img\路由聚合.png"></li></ul></li></ul></li></ul><h4 id="IPv4地址与MAC地址"><a href="#IPv4地址与MAC地址" class="headerlink" title="IPv4地址与MAC地址"></a>IPv4地址与MAC地址</h4><ul><li><p>IPv4地址与MAC地址的封装位置<br><img src="D:\Blog\source\img\Ip地址与mac地址的封装.png"></p></li><li><p>数据报传送过程中IPv4地址与MAC地址的变化情况<br><img src="D:\Blog\source\img\数据报传送ipmac变化情况.png"></p><ul><li>在数据报的传送过程中，数据报的<strong>源IP地址和目的IP地址保持不变</strong>。</li><li>在数据报的传送过程中，数据报的<strong>源MAC地址和目的MAC地址逐链路（或逐网络）改变</strong>。</li></ul></li><li><p>IPv4地址与MAC地址的关系</p><ul><li>如果仅使用MAC地址进行通信，则会出现以下主要问题：<ul><li>每台<strong>路由器的路由表</strong>中就必须记录因特网上<strong>所有</strong>主机和路由器各接口的MAC地址。</li><li>手工配置表几乎不可能完成，路由表中<strong>海量的MAC地址信息会严重占用通信资源</strong>。</li><li>查找转发表也会带来极大的时延。</li></ul></li><li>因特网的网际层使用<strong>IP地址进行寻址</strong>，就可使因特网中各路由器的路由表中的路由记录的数量大大减少，因为<strong>只需记录部分网络的网络地址</strong>，而不是记录每个网络中各通信设备的各接口的MAC地址。<ul><li>路由器收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的<strong>路由表进行查表转发</strong>。</li><li>查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但<strong>无法指明该IP地址所对应的MAC地址</strong>。</li><li>根据地址解析协议ARP来解决</li></ul></li></ul></li></ul><h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><ul><li>地址解析协议<strong>ARP</strong>（Address Resolution Protocol）<ul><li>根据IP地址获取目标MAC地址</li></ul></li><li>过程<br><img src="D:\Blog\source\img\arp协议过程.png"><ul><li>如果a要发送数据报给b<ul><li>a会知道b的ip地址，但是不知道b的mac地址（在自身的arp高速缓存表中查找不到），在数据链路层封装mac帧时会无法填写目的mac地址</li><li>a会向网络发起广播（我是a，我的ip地址是ip-a，我的mac地址是mac-a，我想知道ip-b的mac地址）</li><li>其他设备收到广播后会进行解析，如果与广播中请求的ip地址符合则会接收并且返回，否则不予理会。</li><li>b会接收报文，将a的ip地址以及mac地址存到自己的arp告诉缓存表，并且给a发送arp相应，告知其自己的mac地址</li></ul></li><li>arp包含字段：IP地址、MAC地址以及类型（动态，静态）<ul><li>静态一般是手工配置</li><li>动态一般有生命周期（2分钟）<ul><li>因为ip地址和mac地址不总是一成不变，更换网卡，mac地址就改变了</li></ul></li></ul></li></ul></li></ul><h4 id="IP数据报的发送与转发"><a href="#IP数据报的发送与转发" class="headerlink" title="IP数据报的发送与转发"></a>IP数据报的发送与转发</h4><ul><li>流程<ul><li>主机发送IP数据报<ul><li>在同一个网络中就直接交付，不同网络中间接交付</li><li>源主机如何判断出目的主机是否与自己在同一个网络中？<ul><li>c 转发给不同网络的 f，c 知道 f 的ip地址，根据分类掩码，将自己的网络前缀和f的对比，查看是否相同（是否属于同一个网络）</li></ul></li><li>交给哪个路由器转发呢？<ul><li>实际上，用户为了让本网络中的主机，能和其它网络中的主机进行通信，就必须给其<strong>指定本网络中的一个路由器</strong>，由该路由器帮忙进行转发，所指定的路由器，也被称为默认网关（就是一个保安）</li><li>这样，当本网络中的主机要和其它主机进行通信时，会将IP数据报传输给默认网关。由默认网关帮主机将IP数据报转发出去。</li></ul></li></ul></li><li>路由器转发IP数据报<ul><li>那么路由器收到IP数据报之后又是如何转发的呢？<ul><li>检查IP数据报首部是否出错：若出错，丢弃并告诉源主机，<strong>没错就转发</strong>。</li><li>根据IP数据报的目的地址在<strong>路由表中找匹配的记录</strong>，找到就转发给下一个该转发的，找不到就丢弃该IP数据报并告诉主机你这个我转发不了。</li><li>路由器不会转发广播</li></ul></li></ul></li></ul></li></ul><h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h4><p><img src="D:\Blog\source\img\IPv4数据报的首部格式.png"></p><ol><li>**版本(4bit)**：指明了IP协议的版本，IPv4还是IPv6；通信双方的版本要一致</li><li>**首部长度(4bit)**：指明了IP数据报头部的长度，以4字节为单位（和TCP数据报中的数据偏移字段类似）</li><li>**可选字段(1~40字节)**：可增加一些拓展功能，但很少使用，该字段的拓展直接影响了首部长度字段</li><li><strong>填充字段</strong>：IP数据报头部的长度要求是4的整数倍，因此需要该字段填充补0，使头部满足要求</li><li>**区分服务(1字节)**：一般不使用，用于提供不同等级的服务质量</li><li>**总长度(2字节)**：指明了整个IP数据报的长度,以字节为单位，首部长度换算成字节后，总长度 - 首部长度 &#x3D; 数据载荷的长度</li><li><strong>标识、标志、片偏移</strong>：这三个字段共同说明了IP的分片情况<ul><li>标识：16bit，就是一个数字；属于同一个IP数据报的子分片有相同的标识；IP协议栈维持一个计数器，每产生一个数据报，就将标识值加1，然后赋值给标识字段</li><li>标志：3bit，分别是DF、MF、保留位<ul><li>DF：DF&#x3D;1表示不允许分片，DF&#x3D;0表示允许分片</li><li>MF：MF&#x3D;1表示后边还有分片，MF&#x3D;0表示后边没有分片，这就是最后一个分片</li><li>保留位：暂不使用，为0</li><li>片偏移：13bit，以8字节为单位，这也就要求：如果要分片，只要不是最后一个IP片，其数据载荷长度都必须是8的倍数；该字段指明了分片数据报载荷部分首字节相对于其原始数据报偏移了多少字节，如第一个IP分片的数据报为原始数据载荷的0~800，那该IP分片的片偏移为0&#x2F;8&#x3D;0；第二个分片的片偏移就是800&#x2F;8&#x3D;100；</li></ul></li></ul></li><li>**生存时间TTL(Time To Live)(8bit)**：指明了IP数据报的生存时间还有多少<ul><li>当前是以跳数为单位，路由器转发IP数据报时，先将该字段减1，若不为0则转发；若为0，则表示其生存时间无了，也就是该数据包失效了，就不转发</li><li>主要是为了避免发生路由环路时，IP数据报在环路内永久兜圈</li></ul></li><li>**协议字段(8bit)**：指明了IP数据包的数据载荷部分包装的是何种协议数据单元PDU，该字段是网络层与运输层之间的接口，通过该字段的标识，可以将IP数据报正确的交给运输层的某个协议模块处理</li><li>**首部检验和(16bit)**：用于在IP报的转发、发送过程中校验IP头部。因为IP头部是动态变化的，所以该校验和也是动态变化的。这一点与TCP的校验和不同（TCP校验的是头部和数据载荷也即整个TCP报文段，且转发途中不会动态变化）</li><li>**源IP地址和目的IP地址(各占32bit，4字节)**：用于标识发送方的IP地址和接收方的IP地址，可以说是最重要的字段存在了</li></ol><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><ul><li>静态路由<ul><li>静态路由配置是指用户或者网络运维人员使用路由器的相关命令给路由器<strong>人工配置路由表</strong></li><li>人工配置方式<strong>简单、开销小</strong>、但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>，一般只在小规模网络中采用。</li></ul></li><li>默认路由<ul><li>当路由器在路由表中找不到目的地址的具体路由时，会才有用默认路由</li></ul></li><li>静态路由配置可能存在的问题<ul><li>路由条目<strong>配置错误</strong>，可能导致出现<strong>路由环路</strong></li><li>聚合路由条目时可能引入不存在的网络</li></ul></li></ul><h3 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h3><h4 id="路由选择分类"><a href="#路由选择分类" class="headerlink" title="路由选择分类"></a>路由选择分类</h4><ul><li>静态路由选择<ul><li>简单，开销小，但不能及时适应网络状态的变化</li><li>一般只能在小规模网络中使用</li></ul></li><li>动态路由选择<ul><li>动态路由：路由器通过路由选择协议<strong>自动获取</strong>路由信息</li><li>比较复杂，开销大，但是能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ul></li><li>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：<ul><li>自适应：因特网采用动态路由选择，能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li><li>分层次：<ul><li>将整个因特网划分为许多较小的<strong>自治系统（Autonomous System，AS）</strong>。</li><li>在自治系统内部和外部采用<strong>不同类别</strong>的路由选择协议，分别进行路由选择。<br><img src="D:\Blog\source\img\分层次路由选择协议.png"></li></ul></li></ul></li></ul><h4 id="路由信息协议"><a href="#路由信息协议" class="headerlink" title="路由信息协议"></a>路由信息协议</h4><ul><li>相关概念<ul><li>路由信息协议（Routing Information Protocol)是内部网关协议最先得到广泛使用的协议</li><li>RIP要求自治系统AS内的每一个路由器，都要维护从它<strong>自己到AS内其他每一个网络的距离记录</strong>。这是一组距离，称为距离向量（Distance-Vector，D-V）。</li><li>RIP使用跳数（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。<ul><li>RIP将路由器到直连网络的距离定义为1。</li><li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>RIP允许一条路径最多只能包含15个路由器，距离等于16时相当于不可达。因此RIP只适用于小型互联网。</li></ul></li></ul></li><li>工作流程<ol><li>路由器刚开始工作时，只知道自己到直连网络的RIP距离为1。</li><li>每个路由器仅和相邻路由器周期性的交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本自治系统AS内各网络的最短距离和下一跳路由器，称为收敛。</li></ol></li><li>问题<ul><li>坏消息传播得慢</li><li>当线路故障的消息没有及时更新的时候，一些路由器会被另一些可达的未更新的路由器所误导，导致故障信息传播的十分缓慢。</li><li>优化<ul><li>限制距离</li><li>即时更新，而不是周期性更新</li></ul></li></ul></li></ul><h4 id="开放最短路径优先协议"><a href="#开放最短路径优先协议" class="headerlink" title="开放最短路径优先协议"></a>开放最短路径优先协议</h4><ul><li>概念<ul><li>开放最短路径优先（Open Shortest Path First，OSPF）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的。</li><li>使用了迪杰斯特拉的最短路径算法</li><li>通过相邻路由器之间的互相问候分组，来建立和维护邻居关系</li></ul></li><li>工作过程<ol><li>使用问候发现和维护邻居路由器的可达性</li><li>展示自己的数据给邻居</li><li>互相请求需要的数据</li><li>更新数据（洪泛法）类似广播</li></ol></li><li>优化<ul><li>为了使OSPF协议能够用于规模很大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围，称为区域（area）。</li><li>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统AS，这样就减少了整个网络上的通信量。<br><img src="D:\Blog\source\img\ospf划分区域.png"></li></ul></li></ul><h4 id="边界网关协议"><a href="#边界网关协议" class="headerlink" title="边界网关协议"></a>边界网关协议</h4><ul><li>概念<ul><li>边界网关协议（Border Gateway Protocol，BGP）属于外部网关协议EGP这个类别，用于<strong>自治系统AS之间</strong>的路由选择协议。</li></ul></li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由。</li></ul><h4 id="路由器的基本工作原理"><a href="#路由器的基本工作原理" class="headerlink" title="路由器的基本工作原理"></a>路由器的基本工作原理</h4><ul><li>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是<strong>转发分组</strong>。<br><img src="D:\Blog\source\img\路由器基本原理.png"></li></ul><h3 id="网际控制报文协议（ICMP）"><a href="#网际控制报文协议（ICMP）" class="headerlink" title="网际控制报文协议（ICMP）"></a>网际控制报文协议（ICMP）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>为了<strong>更有效地转发IP数据报</strong>以及提高IP数据报交付成功的机会，TCP&#x2F;IP体系结构的网际层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）[RFC 792]。</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li><li>ICMP报文被封装在IP数据报中发送。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>差错报告报文</strong>：用来向主机或路由器报告差错情况</p><ul><li>终点不可达<ul><li>当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文。</li></ul></li><li>源点抑制<ul><li>当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li></ul></li><li>超时<ul><li>收到数据报后，若TTL结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文。</li><li>在预先规定的时间内未能收到一个数据报的全部数据报分片时，也会发送超时报文</li></ul></li><li>参数问题<ul><li>路由器检测到数据报首部误码丢弃该数据报，并且发送参数问题报文</li></ul></li><li>改变路由（重定向）<ul><li>路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样<strong>可以通过更好的路由</strong>到达目的主机。</li></ul></li></ul></li><li><p><strong>询问报文</strong>：用来向主机或路由器询问情况</p><ul><li>回送请求和回答<ul><li>用来测试目的站是否可达以及了解其有关状态。</li></ul></li><li>时间戳请求和回答<ul><li>用来进行时钟同步和测量时间。</li></ul></li></ul></li></ul><h3 id="虚拟专用网和网络地址转换"><a href="#虚拟专用网和网络地址转换" class="headerlink" title="虚拟专用网和网络地址转换"></a>虚拟专用网和网络地址转换</h3><h4 id="虚拟专用网"><a href="#虚拟专用网" class="headerlink" title="虚拟专用网"></a>虚拟专用网</h4><ul><li>虚拟专用网（Vitual Private Network）：<ul><li>我们如何让两个专用网络进行通信呢？<ul><li>直接花钱连线</li><li>使用因特网作为载体</li></ul></li><li>利用公用的因特网作文本机构和专用网之间的通信载体。</li></ul></li><li>公用网和专用网的区别是什么呢？<ul><li>公用网的ip全是公开的，专用网为了安全考虑，ip都是不公开的</li></ul></li><li>如何实现<ul><li>我们需要在两个专用网中分别使用一个路由器，路由器可以连接公网</li><li>将专网的内部ip加密封装到数据报之中，通过路由器转发到公网</li><li>转发的地址是目的专网的路由器的公网地址</li><li>目的专网收到之后，进行解析即可</li></ul></li></ul><h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><ul><li><p>为什么需要？</p><ul><li>主要解决IPv4地址紧缺的问题，通过将<strong>一个公网IP地址和多个私网IP</strong>相对应，从而解决IP地址不够用的情况</li></ul></li><li><p>如何实现</p><ul><li>使用NAT软件，并且至少有一个有效的全球地址ip</li><li>当私网通过NAT时，会将其转换为公网在因特网传输<br><img src="D:\Blog\source\img\NAT过程.png"></li></ul></li><li><p>优化:网络地址与端口号转换方法</p><ul><li>由于目前绝大多数基于TCP&#x2F;IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，为了更加有效地利用NAT路由器中的全球IP地址，现在常将NAT转换和运输层端口号结合使用。<ul><li>这样就可以使内部专用网中使用专用地址的大量主机，共用NAT路由器上的1个全球IP地址，因而可以同时与因特网中的不同主机进行通信。<br><img src="D:\Blog\source\img\网络地址与端口号转换.png"></li></ul></li></ul></li></ul><p>内网的地址和端口号都可能不同，但是通过NAPT发送时，就直接使用：公用地址 ： NAPT自己分配的端口，并且存到转换表之中，便于之后的操作。</p><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>多播（Multicast，也称为组播）是一种实现“一对多”通信的技术，与传统单播“一对一”通信相比，多播可以极大地节省网络资源。</li><li>在因特网上进行的多播，称为IP多播。<br><img src="D:\Blog\source\img\ip多播.png"></li><li>可以减少网络中资源的消耗</li></ul><h4 id="IP多播地址和多播组"><a href="#IP多播地址和多播组" class="headerlink" title="IP多播地址和多播组"></a>IP多播地址和多播组</h4><ul><li>在IPv4中，<strong>D类地址</strong>被作为多播地址。</li><li><strong>多播地址只能用作目的地址</strong>，而不能用作源地址。</li><li>一个多播地址确定一个多播组</li></ul><h4 id="局域网上进行硬件多播"><a href="#局域网上进行硬件多播" class="headerlink" title="局域网上进行硬件多播"></a>局域网上进行硬件多播</h4><ul><li>硬件多播其实就是多播MAC地址，只需要把IPv4的多播地址转换为MAC地址即可</li><li>由于IP多播地址可变化的28比特的前5个比特无法映射到MAC多播地址，<strong>这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的</strong>。<ul><li>所以在链路层判断MAC地址正确后，还会将数据上传至网络层，进行IP地址的判断，从而确定正确的传输</li></ul></li></ul><h4 id="因特网上进行IP多播需要的两种协议"><a href="#因特网上进行IP多播需要的两种协议" class="headerlink" title="因特网上进行IP多播需要的两种协议"></a>因特网上进行IP多播需要的两种协议</h4><ul><li>引出<ul><li>要在因特网上进行IP多播，<strong>要考虑IP多播数据报经过多个多播路由器进行转发的问题</strong>。<ul><li>多播路由器必须根据IP多播数据报首部中的IP多播地址，将其转发到有该多播组成员的局域网。</li></ul></li><li>那么路由器如何知道自己的接口所在局域网有哪些多播成员呢？<ul><li>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。</li><li>需要使用多播路由选择协议来解决</li></ul></li></ul></li><li>多播路由选择协议<ul><li>过程<ul><li>主要任务是：在多播路由器之间为每个多播组建立一个多播转发树</li><li>多播转发树连接多播源和所有拥有该多播组成员的路由器。</li><li>IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器。</li><li>之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员。</li></ul></li></ul></li><li><strong>网际组管理协议（IGMP）：维护多播组与其成员关系</strong><ul><li>报文类型<ul><li>成员报告报文</li><li>成员查询报文</li><li>离开组报文</li></ul></li><li>加入多播组<ul><li>发送成员报告报文申请加入</li></ul></li><li>监听多播组成员变化<ul><li>多播路由器定时发送成员查询报文（广播）</li><li>成功接收到报文的组员会延时随机时间后发送请求（成员报告报文），</li><li>如果该组有一个成员（延时最短的）已经发送报告报文了，那么该组其他的成员就取消发送，这样可以减少资源浪费</li><li>长时间未收到响应，会将该组从多播组中删除</li></ul></li><li>退出多播组<ul><li>当主机要退出某个多播组时，可<strong>主动发送</strong>一个离开组报文而不必等待多播路由器的查询。</li><li>这样可使多播路由器能够更快地发现某个组有成员离开。</li></ul></li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>背景<ul><li>IPv4不够用</li></ul></li><li>变化<ul><li>IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。</li><li>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</li><li>更大的地址空间</li><li>扩展的地址层次结构，灵活的首部等</li><li>IPv6 的地址主要有以下类型地址：<ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul></li></ul></li></ul><h4 id="IPv6数据报的首部"><a href="#IPv6数据报的首部" class="headerlink" title="IPv6数据报的首部"></a>IPv6数据报的首部</h4><p><img src="D:\Blog\source\img\ipv4对比ipv6.png"></p><ul><li>取消了首部校验和字段。</li><li>取消了分片&#x2F;重新组装相关字段。</li><li>取消选项字段。</li></ul><h4 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h4><ul><li>使用双协议栈<ul><li>使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li><li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li><li>根据需要进行转换</li><li>会漏一些信息</li></ul></li><li>使用隧道技术<ul><li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li><li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li></ul></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><hr><h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><ul><li>进程间基于网络通信（<strong>运输层作用</strong>）<ul><li>物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了<strong>主机到主机的通信</strong>。</li><li>然而在计算机网络中<strong>实际进行通信的真正实体，是位于通信两端主机中的进程</strong>。</li><li>如何为<strong>运行在不同主机上的应用进程</strong>提供直接的逻辑通信服务，就是运输层的主要任务。运输层协议又称为端到端协议。</li><li>运输层向应用层实体<strong>屏蔽了下面网络核心的细节</strong>（例如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条<strong>端到端的逻辑通信信道</strong>。<br><img src="D:\Blog\source\img\进程间基于网络通信.png"></li></ul></li><li>运输层端口号<ul><li>运行在计算机上的进程是使用进程标识符（Process Identification，PID）来标识的（每个PCB（进程控制块）由其唯一的PID标识）<ul><li>因特网也有其类似的实现，使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识</li></ul></li><li>TCP&#x2F;IP体系结构的运输层使用<strong>端口号</strong>来标识和区分应用层的不同应用进程。端口号的长度为16比特，取值范围是0~65535。<br><img src="D:\Blog\source\img\端口号的分配.png"></li><li>端口号应用举例<ul><li>用户端根据域名向DNS服务器发起请求（通过标识自己的端口号，以及目标端口号），申请获取该域名的IP地址<ul><li>DNS服务器：存储了域名和对应IP，类似于一个电话簿</li></ul></li><li>DNS返回IP地址</li><li>用户端根据IP地址发起请求访问Web服务器</li><li>Web服务器根据请求，返回内容</li><li>**上述交流信息的TCP首部均包含了”源端口”以及”目的端口”的信息</li></ul></li></ul></li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP基本概览"><a href="#TCP基本概览" class="headerlink" title="TCP基本概览"></a>TCP基本概览</h4><ul><li>什么是 TCP ？<ul><li>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。<ul><li><p><strong>面向连接：</strong>一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的：</strong>无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流传输：</strong>用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文</p><ul><li><p>如何解决粘包问题？</p><ul><li><p>设置终止符</p></li><li><p>定义一个消息结构体</p><p>固定大小包头告诉消息大小，随后跟着消息</p></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式  "></a>TCP报文段的首部格式  <img src="D:\Blog\source\img\tcp报文首部格式.png"></h4><h4 id="控制位"><a href="#控制位" class="headerlink" title="控制位"></a>控制位</h4><p><strong>控制位</strong></p><ol><li>URG（Urgent）：表示紧急指针（Urgent Pointer）字段有效。当该位被置为1时，表示当前报文段中的数据具有紧急性，需要优先处理。紧急指针用于指示报文段中的紧急数据的结束位置。</li><li><strong>ACK（Acknowledgment）：表示确认序号（Acknowledgment Number）字段有效。当该位被置为1时，表示确认字段中的值是有效的，即确认接收到的数据。在建立连接后，TCP通信中的大多数报文都会将ACK置为1。</strong></li><li>PSH（Push）：表示推送数据。当该位被置为1时，表示接收方应该尽快将接收到的数据交给上层应用，而不是等待缓冲区填满或等待延时定时器到期。</li><li>RST（Reset）：表示连接复位。当该位被置为1时，表示发生了错误或异常情况，需要立即中断当前连接。接收到RST标志的一方会立即关闭连接。</li><li><strong>SYN（Synchronize）：表示建立连接请求。当该位被置为1时，表示发送方希望建立一个新的连接，并指明初始序列号。</strong></li><li><strong>FIN（Finish）：表示结束连接。当该位被置为1时，表示发送方已经完成了数据的发送，并要求关闭连接。接收到FIN标志的一方会发送ACK作为回应，并逐渐关闭连接。</strong></li></ol><p>这些控制位的组合和交互使用，使得TCP协议能够进行可靠的连接建立、数据传输和连接关闭。通过这些控制位，TCP可以实现流量控制、拥塞控制、数据完整性和可靠性等功能。</p><h4 id="确认号和序列号"><a href="#确认号和序列号" class="headerlink" title="确认号和序列号"></a>确认号和序列号</h4><ul><li><p>作用：</p><ul><li>序列号：初次建立是随机数，之后每发送一次数据就累加一次该数据字数的大小，用来<strong>解决包乱序问题</strong></li><li>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li></ul></li><li><p><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></p></li><li><p><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></p><p><img src="D:\Blog\source\img\TCP中的确认号和序列号.png"></p></li></ul><h4 id="三报文握手-建立TCP连接"><a href="#三报文握手-建立TCP连接" class="headerlink" title="三报文握手 建立TCP连接"></a>三报文握手 建立TCP连接</h4><ul><li><p>“三报文握手”建立TCP连接的目的</p><ul><li>使TCP双方能够确知对方的存在。</li><li>使TCP双方能够协商一些参数（例如最大报文段长度、最大窗口大小、时间戳选项等）。</li><li>使TCP双方能够对运输实体资源进行分配和初始化。运输实体资源包括缓存大小、各状态变量、连接表中的项目等。</li></ul></li><li><p>流程<br><img src="D:\Blog\source\img\三次握手.png"></p></li><li><p>为何不能省去第三次</p><ul><li><p>避免资源的浪费</p><ul><li>当客户端的一个请求阻塞时，会重新发送请求，然后和服务端建立连接。</li><li>再传输数据后，会关闭连接</li><li>此时之前阻塞的请求又发送到了服务端，因为服务端是被动打开的，所以服务端根据请求会发送确认报文。</li><li>但是此时的客户端已经关闭，而且无法被服务端给唤醒，所以不会理财服务端的请求</li><li>此时服务端会一直开启并且等待客户端响应，浪费了资源</li></ul><p><img src="D:\Blog\source\img\两次握手.png"> </p></li><li><p>如果有了第三次</p><ul><li>当滞留的请求到达服务器，服务器会向客户端发送连接确认报文，然后会等待第三次握手（因此可以检测到客户端有没有关闭）</li><li>如果如上面的情况，客户端关闭了，那么客户端不会返回请求给服务端，服务端会超时重传，并且不会一直死等，一定时间就关闭，不像上面那样进入连接已建立状态，然后一直白白等。</li></ul></li><li><p>历史连接问题：</p><p><img src="D:\Blog\source\img\三次握手避免历史连接.png"></p><ul><li>如果没有第三次握手，那么第二次握手返回ACKNum的时候，客户端可能没有机会进行检验并且告诉服务端：这是历史连接！，因为当第二次握手结束连接就可能建立了</li></ul></li></ul></li><li><p>第一次握手丢失：</p><ul><li>第一次握手（告诉服务端，我想和你进行连接）</li><li>如果丢失，客户端发送后未得到服务端的确认请求，那么会进行超时重传，达到一定次数后，会等待一定时间，如果还是没有收到确认（第二次握手）那么会断开连接（主动方：客户端）</li></ul></li><li><p>第二次握手丢失：</p><ul><li>第二次握手（服务端发送确认通知）</li><li>此时客户端等待服务端的确认（第二次握手），服务端等待客户端的确认（第三次握手）</li><li>客户端没有得到第二次握手，会进行超时重传（上限一次），然后等待一段时间，如果没有收到，客户端断开连接</li><li>服务端没有收到第三次握手也会进行超时重传（上限两次），然后再等待一段时间，如果还是没有收到，那么服务端会断开连接</li></ul></li><li><p>第三次握手丢失：</p><ul><li>第三次握手（客户端接收到服务端的确认通知之后，会向其返回第三次握手，此时，客户端进入ESTABLISHED状态）</li><li>服务端发起确认（第二次握手）后会进行重传（上限两次），达到上限会进行一段时间等待，如果还是没有收到第三次握手，服务端断开连接。</li></ul></li><li><p>第三次握手可以携带数据，前两次握手不可携带数据</p></li></ul><h5 id="半连接全连接队列"><a href="#半连接全连接队列" class="headerlink" title="半连接全连接队列"></a>半连接全连接队列</h5><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列（已经建立好连接的连接）等待使用</strong></p><p><strong>作用：</strong></p><ul><li><strong>实现超时处理</strong>：如果某个连接在一定时间内没有完成第二次握手，那么可以将其从半连接队列中移除，释放相关资源</li><li><strong>控制未完成连接的数量</strong>：半连接队列可以限制半连接的个数，防止过多的半连接导致服务器资源不足</li><li><strong>实现连接的临时存储</strong>：由于服务器可能在某些情况下无法立即处理完整个三次握手，例如服务器繁忙或负载较大，因此需要一种机制来保存已经接收到第一次握手的连接，但尚未完成第二次握手的状态。这就是半连接队列的作用。半连接队列用于存储这些未完成的连接，确保服务器在处理这些连接时不被过多占用，而不至于丢失这些连接请求。</li></ul><h4 id="四报文挥手-释放TCP连接"><a href="#四报文挥手-释放TCP连接" class="headerlink" title="四报文挥手 释放TCP连接"></a>四报文挥手 释放TCP连接</h4><p><img src="D:\Blog\source\img\四次挥手.png"></p><ul><li>小问题<ul><li>不进行时间等待会怎么样？<ul><li>如果不进行时间等待，在客户端发送确认报文并加入关闭阶段时，服务端无法收到，因此无法关闭，而此时客户端已经关闭，无法进行超时重传<br><img src="D:\Blog\source\img\四次挥手时间等待作用.png"></li></ul></li></ul></li><li>第一次挥手丢失：<ul><li>第一次挥手（客户端让自己与服务端断开，并且自己不再传输数据给服务端）</li><li>如果丢失的话，客户端无法收到服务端发来的确认报文，这会触发客户端的重传机制</li><li>如果重传到了一定次数，那么会直接关闭连接</li></ul></li><li>第二次挥手丢失：<ul><li>第二次挥手（就是服务端对客户端的关闭请求的确认）</li><li>如果丢失，客户端无法收到确认报文，那么会触发客户端的超时重传机制</li><li>如果客户端重传到了一定次数还没有收到第二次挥手（确认），则会直接关闭连接</li></ul></li><li>第三次挥手丢失：<ul><li>第二次挥手之后，服务端可能还会有数据需要传输，所以会进入关闭等待状态。当服务端的数据传输完毕，就会进行第三次挥手，对服务端进行关闭。</li><li>服务端发起第三次挥手，但是没有收到确认之后，会进行超时重传</li><li>当重传达到一定的次数之后，再进行最后的一段时间的等待，还未收到确认，那么就会直接关闭。</li></ul></li><li>第四次挥手丢失：<ul><li>第四次挥手（确认收到服务端的关闭请求，并返回确认）</li><li>如果第四次挥手丢失，那么服务端会进行第三次挥手的超时重传，达到一定次数后，再等待一定时间后，如果还是没有收到确认，那么会直接关闭</li></ul></li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li>流量控制的基本概念<br><img src="D:\Blog\source\img\流量控制的基本概念.png"><ul><li>因为服务端应用程序可能正忙于其他任务，并不一定能够立刻取走数据。如果不根据此时服务接收方的接收缓存情况来进行流量控制的话，会造成数据的溢出丢失</li></ul></li><li>流量控制的过程<br><img src="D:\Blog\source\img\流量控制例子.png"><ul><li>首先在建立 TCP 连接时，接收方会告诉发送方：我的接收窗口大小为400，此时，发送方会将自己的发送窗口大小也设为400</li><li>发送方会一个个的传输数据报，并且发送序列号</li><li>接收方会进行接受的确认以及流量的控制：如上图：确认报文，确认前200号的数据，调整滑动窗口为300</li><li>发送方根据返回的确认信息，知道自己到底有效的传输了多少的数据，然后进行滑动窗口的移动，以及删除发送缓存中已被接收的数据</li><li>发送方只发送自己发送窗口内的数据</li><li>发送窗口向前滑动的前提是发送窗口的数据确认被正确接收</li></ul></li><li>问题<ul><li>如果接收窗口为0，那么此时发送窗口也会相应变为0，此时该如何破解这个局面呢？<ul><li>当发送方的发送窗口变为0后，会启动一个持续计时器， 当计时结束，发送方会主动发送一个零窗口探测报文，接收方必须接收该报文</li></ul></li><li>如果零窗口探测报文丢失呢？<ul><li>零窗口探测报文段也有设置的有重传计时器，如果丢失，等待该计时器超时，然后重传零窗口探测报文段</li></ul></li><li>为什么接收方接收窗口为0时还能接收零窗口探测报文<ul><li>TCP规定，就算接收窗口为0，也必须接受零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段</li></ul></li></ul></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li><p>拥塞控制的基本概念</p><ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞（congestion）。</li></ul></li><li><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。<br><img src="D:\Blog\source\img\拥塞吞吐量.png"></p></li><li><p>流量控制与拥塞控制的区别</p><ul><li>流量控制是服务器可能正忙于其他任务，当接收缓存满了之后并一定能及时的取走数据，导致新来的数据会被丢弃</li><li>拥塞控制是指防止过多的数据注入到网络之中，使网络能够承受现有的网络负荷</li></ul></li><li><p>方法概念</p><ul><li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</li><li>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)</li><li>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意。</li></ul></li><li>如何确定网络拥塞？<ul><li>其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</li></ul></li></ul></li><li><p>拥塞控制的四种方法</p><ul><li><p>慢开始</p><ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加倍</li></ul></li><li><p>拥塞避免</p><ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</li></ul></li><li><p>快重传</p><ul><li><p>在没有快重传的时候，如果报文丢失那么会进行超时重传，需要等待一定时间，并且重传完毕后，会将ssthreash减半，并且将初始窗口转变为1，然后使用慢开始算法</p></li><li><p>快重传就是要求接收方在收到一个失序的报文段后就<strong>立即发出重复确认</strong>，而不是等到主机发送数据时捎带确认。</p></li><li><p>快重传规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><img src="D:\Blog\source\img\快重传举例.png"></p></li></ul></li><li><p>快恢复</p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="D:\Blog\source\img\拥塞控制.png"></li></ul></li></ul></li></ul><h4 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h4><ul><li>以字节为单位的滑动窗口</li><li>超时重传（超时时间主要为加权平均往返时间）</li><li>选择确认</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ul><li>连接<ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul></li><li>服务对象<ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul></li><li>可靠性<ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul></li><li>拥塞控制，流量控制<ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li><li>首部开销<ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li><li>传输方式<ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul></li><li>应用场景<ul><li>TCP<ul><li>FTP 文件传输</li><li>HTTP &#x2F; HTTPS</li></ul></li><li>UDP<ul><li>包总量较少的通信</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul></li></ul></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><hr><h3 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h3><ul><li>应用层的作用：<ul><li>解决通过应用进程的交互来实现特定网络应用的问题</li><li>我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是运输层。</li><li>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</li></ul></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h4><ul><li>HTTP是什么<ul><li>HTTP是超文本传输协议：Hyper Text Transfer Protocol</li><li>协议：<ul><li>建立了交流通信的规范</li></ul></li><li>传输：<ul><li>HTTP协议是一个双向协议</li><li>允许有中转或接力（在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。）</li></ul></li><li>超文本：<ul><li>内容超文本</li><li>是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li></ul></li><li><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong><ul><li>可以是服务器到浏览器，也可以是服务器到服务器等。</li></ul></li></ul></li><li>HTTP常见状态码<ul><li><code>1xx</code>：提示信息</li><li><code>2xx</code>：服务器成功处理请求</li><li><code>3xx</code>：表示客户端请求的<strong>资源发生了变动</strong>，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong></li><li><code>4xx</code>：表示客户端发送的报文，服务器无法处理。<ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li><code>5xx</code>：表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于<strong>服务端的错误</strong>。</li></ul></li><li>HTTP常见字段<ul><li>Host 字段<ul><li>客户端发送请求时，用来指定服务器的域名。</li></ul></li><li>Content-Length 字段<ul><li>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</li></ul></li><li>Connection 字段<ul><li>指定是什么类型的连接方式，如长连接等</li></ul></li><li>Content-Type 字段<ul><li>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ul></li><li>Content-Encoding 字段<ul><li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li></ul></li></ul></li></ul><h4 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h4><ul><li>GET和POST的区别<ul><li>GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。</li><li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。</li></ul></li><li>GET和POST方法都是安全和幂等的吗？</li></ul><blockquote><p>安全：在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>幂等：所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></blockquote><ul><li>GET方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</li><li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</li></ul><h4 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h4><ul><li><p>作用</p><ul><li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，提升服务的性能。</li></ul></li><li><p>强制缓存</p><ul><li>浏览器发现本地资源A后，根据与服务器的检验规则，<strong>浏览器给本地资源A进行检验</strong><ul><li>如果符合要求，浏览器直接返回该本地资源</li><li>如果不符合要求，浏览器会向服务器发送资源请求</li></ul></li><li>强缓存指的是只要<strong>浏览器判断缓存没有过期</strong>，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器这边。</strong></li><li>实现：<ul><li>利用HTTP响应头部(Response Header)字段实现<ul><li><code>Cache-Control</code>：相对时间，优先级更高</li><li><code>Expires</code>：绝对时间</li></ul></li></ul></li><li>流程：<ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部添加Cache-Control，Cache-Control中设置了过期时间</li><li>当浏览器再次访问该资源时，会根据Cache-Control来计算该资源是否过期，如果没过期则直接使用，否则重新发起请求，服务器收到请求后，会更新Response头部的Cache-Control</li></ul></li><li><strong>当服务器的资源已经更新，但是缓存的时间还未到期，那么此时缓存保存的仍然是旧的数据。</strong></li></ul></li><li><p>协商缓存</p><ul><li>浏览器发现本地资源A后，浏览器给服务器发送一个请求，将资源A的相关信息告诉服务器，<strong>服务器对其进行检验</strong><ul><li>如果符合要求，浏览器直接返回该本地资源</li><li>如果不符合要求，服务器会直接返回一份新的资源A</li></ul></li><li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</li><li>实现：<ul><li>请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul><li>客户端会在请求头中使用<code>If-Modified-Since</code>，将之前获取资源时服务器返回的<code>Last-Modified</code>值发给服务器</li><li>服务器收到请求后，会将客户端返回的<code>If-Modified-Since</code>里的值（即本地缓存的最新修改时间），与服务器的最新修改时间对比</li><li>如果本地缓存仍然是最新的，那么返回304 Not Modified，客户端收到后则知道仍然可以使用缓存中的副本</li><li>如果缓存不是最新，服务器会返回新的资源，并且响应头中包含新的<code>Last-Modified</code>值</li></ul></li><li>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul></li><li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li><li>所以Etag的优先级更高</li></ul></li><li>Etag实现过程：<ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的</li><li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<ul><li>如果没有过期，则直接使用本地缓存</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段（存的Etag值），该字段的值就是 ETag 唯一标识</li></ul></li><li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<ul><li>如果值相等，则返回 304 Not Modified，不会返回资源</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul></li></ul></li><li><p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p><ul><li>再次发起相同请求</li><li>本地检验缓存（强制缓存），成功直接使用，未成功则进行协商缓存</li><li>协商缓存进行检验，成功直接使用，未成功则重新返回并更新相关检验的字段</li></ul></li></ul><h4 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP&#x2F;1.1 特性"></a>HTTP&#x2F;1.1 特性</h4><ul><li>优点<ul><li>简单：报文形式：header + body，头部信息：key + value</li><li>灵活易扩展：各类请求方法并未固定死，可以自定义和扩展</li><li>应用广泛和跨平台</li></ul></li><li>缺点<ul><li>无状态：<ul><li>好处：服务器无需存储HTTP状态，节省资源</li><li>坏处：服务器没有记忆能力，完成有关联性的操作很麻烦，例如在网上购物时，每一步操作都需要知道用户身份，服务器不存储状态，因此每一步操作都需要验证身份信息（cookie技术和session技术解决）。</li></ul></li><li>明文传输：<ul><li>好处：方便阅读，方便调试</li><li>坏处：信息不安全</li></ul></li></ul></li><li>性能分析<ul><li>长连接<ul><li>在早期的HTTP&#x2F;1.0中，每次发起一个请求都需要新建一次TCP连接，并且串行请求（一个请求的响应完全返回后，才能发起下一个请求）。</li><li>为了解决上述连接问题，HTTP&#x2F;1.1提出了<strong>长连接</strong>（持久连接）的通信方式，只要任意一端没有明确提出断开连接，则保持TCP连接状态。（如果超过一定时间没有数据交互，服务器也会主动断开该连接）<br><img src="D:\Blog\source\img\长短连接的区别.png"></li></ul></li><li>管道网络运输（并不默认开启该功能）<ul><li>HTTP&#x2F;1.1采用了长连接的方式，使得管道网络传输成为了可能，即可在同一个TCP连接里，客户端发起多个请求，只要第一个请求发出去，不必等待其回来，就可以发送第二个请求，由此减少整体响应时间。<br><img src="D:\Blog\source\img\管道网络运输.png"> </li><li>请求必须有序。</li><li>如果服务端在处理某个请求队列头部的请求时，耗时较长，那么后续的请求处理都会被阻塞，这被成为队头堵塞。</li></ul></li><li>队头阻塞<br><img src="D:\Blog\source\img\队头堵塞.png"></li></ul></li></ul><h4 id="HTTP-1-1-如何优化"><a href="#HTTP-1-1-如何优化" class="headerlink" title="HTTP&#x2F;1.1 如何优化"></a>HTTP&#x2F;1.1 如何优化</h4><ol><li><p>避免发送HTTP请求</p><ol><li>使用缓存技术</li></ol></li><li><p>减少HTTP请求发送次数</p><ol><li><p>减少重定型请求</p><ul><li><p>重定向就是一个服务器资源从url1迁移到url2后，但是客户端并不知情，仍然请求url1，此时服务器会通过302响应码和Location头部告诉客户端资源已经迁移至url2。 </p></li><li><p>解决方案：</p><ul><li><p>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</p></li><li><p>因为客户端也不止有一个，有了代理服务器，第一台设备的第一次重定向后，代理服务器就会知晓其规则，那么之后的该请求的重定向就无需到达源服务器，而是直接由代理服务器进行返回</p><p><img src="D:\Blog\source\img\客户端服务器请求方案.png"><br><img src="D:\Blog\source\img\代理服务器帮忙处理重定向.png"></p></li></ul></li></ul></li><li><p>合并求情</p><ul><li>把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。 </li><li>这样也带来了问题，当大资源中的某个小资源发生了变化，客户端必须重新下载整个大资源，带来了额外的网络消耗</li></ul></li><li><p>延迟发送请求</p><ul><li>按需获取，例如请求网页的时候，没必要获取全部资源，而是仅仅获取当前用户所需要的资源即可</li></ul></li></ol></li><li><p>减少HTTP响应数据的大小</p><ul><li>对响应的资源进行压缩</li></ul></li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，<strong>在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</strong></li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h4 id="HTTPS-解决了HTTP的哪些问题？"><a href="#HTTPS-解决了HTTP的哪些问题？" class="headerlink" title="HTTPS 解决了HTTP的哪些问题？"></a>HTTPS 解决了HTTP的哪些问题？</h4><ul><li>实现了<ul><li>信息加密：交互信息无法被窃取。</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示。</li><li>身份证书：证明淘宝是真的淘宝网。</li></ul></li><li>实现方案：<ul><li>混合加密的方式实现信息的机密性，解决了窃听的风险。</li><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到数字证书中，解决了冒充的风险。</li></ul></li></ul><h4 id="HTTPS的实现方式"><a href="#HTTPS的实现方式" class="headerlink" title="HTTPS的实现方式"></a>HTTPS的实现方式</h4><ul><li><p><strong>混合加密</strong></p><blockquote><ul><li>公钥：公开给所有人；私钥：必须本人保管，不可泄漏</li><li>二者可以双向进行解密和加密<br><strong>公钥加密，私钥解密。这个目的是为了保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br><strong>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul></blockquote><blockquote><ul><li>对称加密：使用相同的密钥（称为对称密钥）同时用于加密和解密数据。对称加密算法存在一个密钥分发的问题。发送方和接收方必须事先共享密钥，这在分布式环境中可能会变得复杂和不安全。</li><li>非对称加密：使用一对密钥，分别是公钥和私钥。发送方使用接收方的公钥对数据进行加密，而接收方使用自己的私钥对数据进行解密。</li></ul></blockquote><ul><li><p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li><li>简单来说就是，数据使用对称加密，然后因为对称加密的密钥传输有可能有安全问题，于是使用非对称加密来传输对称加密的密钥<br><img src="D:\Blog\source\img\https混合加密.png"></li></ul></li><li><p>原因：</p><ul><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></li><li><p><strong>第二次梳理理解：</strong></p><ul><li><strong>客户端自己有私钥a，然后将对应的公钥a发送给服务端，服务端根据公钥a进行加密（此加密信息只能通过私钥a才能获取，即只能由客户端获取），加密的内容就是也是一个私钥b（后面用来实现通信的私钥b）</strong></li><li><strong>客户端获取到公钥a加密后的信息，根据自己的密钥a进行解密，得到了服务器的私钥b</strong></li><li><strong>然后双方进行传输：服务端发送信息，此信息使用公钥b加密，此时只能由有私钥b的才能解密</strong></li></ul></li></ul></li><li><p><strong>摘要算法 和 数字签名</strong><br>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p></li></ul><p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</p><ul><li>所以使用摘要算法：计算出内容指纹一并传输给接收方，让接收方来校验</li><li>并且为了防止被攻击者将内容和指纹一同修改，所以使用数字签名：私钥加密，公钥解密，确定是来自于指定对象。<br><img src="D:\Blog\source\img\摘要算法数字签名.png"></li><li><strong>数字证书</strong><br>如果造假者进行公钥的伪造（伪造一个假官方，发布假公钥），那么数字签名也就失效了，因为它传私钥给你也传公钥给你。</li></ul><p>所以为了防止这种漏洞，发送方可以将自己的公钥上传给权威机构CA（数字证书认证机构），接收方就不会出现使用伪造公钥的情况了<br><img src="D:\Blog\source\img\数字证书.png"></p><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><h4 id="SSL-TLS-协议基本流程"><a href="#SSL-TLS-协议基本流程" class="headerlink" title="SSL&#x2F;TLS 协议基本流程"></a>SSL&#x2F;TLS 协议基本流程</h4><ul><li>客户端向服务器索要并且验证服务器的公钥</li><li>双方协商产生会话密钥</li><li>双方采用会话密钥进行加密通信</li></ul><h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><ul><li>改善：<ul><li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul></li><li>不足：<ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li></ul><h4 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h4><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。‘</p><ul><li><p>改善：</p><ul><li>头部压缩：HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。（使用一个表来维护所有字段，根据需要生成索引来确定需要哪些字段）</li><li>二进制格式：HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame），对计算机而言增加了传输效率</li><li>并发传输：针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。<br><img src="D:\Blog\source\img\http2并发传输.png"></li><li>服务器推送：HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息</li></ul></li><li><p>缺陷：</p><ul><li>没有解决TCP层面的队头阻塞<ul><li>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</li></ul></li></ul></li></ul><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>并且使用基于UDP的QUIC协议来实现类似TCP的可靠性传输<br>QUIC有三个特点:无队头阻塞、更快的连接建立连接迁移</p><ul><li>无队头阻塞：<br>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</li></ul><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当<strong>某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</strong>，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><ul><li>更快的连接建立：<br>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，建立连接时需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”<br><img src="D:\Blog\source\img\http3更快的连接建立.png"></li><li>连接迁移：<ul><li>对于TCP传输来说：当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。</li><li>对于QUIC协议，通过连接ID来标记通信双方，所以就算IP变了，只要仍有上下文信息，那么就可以实现无缝连接</li></ul></li></ul><h4 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h4><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：<ul><li>当客户端访问某一个地址时，会将请求交给服务器进行处理</li><li>在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理</li><li>在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息</li><li>浏览器在接受响应后会按照cookie信息在客户端建立cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li></ul></li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="D:/Blog/source/img/跨域访问.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。</li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="D:/Blog/source/img/session原理示意图.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li><p>cookie和session的比较：</p><ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="D:/Blog/source/img/cookie，session，令牌对比.png" alt="Alt text"></li></ul></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="从键入网址到显示网页的全过程："><a href="#从键入网址到显示网页的全过程：" class="headerlink" title="从键入网址到显示网页的全过程："></a>从键入网址到显示网页的全过程：</h4><ol><li><p>浏览器解析URL</p></li><li><ol><li>URL的组成？</li></ol></li></ol><p>例如：http: &#x2F;&#x2F; www. server. com &#x2F; dir1 &#x2F; file1.html</p><p>http 代表访问数据的协议</p><p><a href="http://www.server/">www.server</a> 代表服务器名称</p><p>dir1&#x2F;file1.html 代表访问的文件的路径</p><ol><li><p>根据URL在DNS中找到 IP地址</p></li><li><ol><li>DNS是什么？</li></ol></li></ol><p>dns就是域名系统，用来存储域名和对应的ip地址</p><ol><li><ol><li>为什么需要DNS？</li></ol></li></ol><p>域名比起ip地址更容易记忆</p><p>ip地址可能经常更换，使用域名可以使用户体验更好，无需记忆多变的ip地址</p><p>域名可以映射到多个ip地址，便于实现负载均衡等</p><ol><li><ol><li>域名层级关系</li></ol></li></ol><p>越靠右层级越高，<a href="http://www.server.com/">www.server.com</a>   </p><p>最高级的是最右侧隐藏的 . ，这个 . 代表的是根域名， .com是顶级域名，server.com是权威域名</p><ol><li><ol><li>域名解析流程</li></ol></li><li><ol><li><ol><li>客户端发出dns请求，<a href="http://www.server.com的IP是多少？">www.server.com的IP是多少？</a></li><li>本地dns服务器会现在缓存中寻找，找到则直接返回</li><li>如果没找到那么会依次从最高层的域名服务器进行查找</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>问根域名，根域名不知道，但是可以指明方向（如指示去,.com找）</li><li>问.com，.com不知道，也可以指明方向（如指示去<a href="http://www.server.com找)/">www.server.com找）</a></li><li>然后找到，权威DNS服务器将对应的IP地址告诉本地DNS</li><li>本地进行缓存</li></ol></li></ol></li></ol></li><li><p>协议栈对传输进行下一步指示（告诉你使用什么协议）</p></li><li><ol><li>获取到IP后指示进行什么协议来传输</li></ol></li><li><p>进行TCP传输</p></li><li><ol><li>TCP报文头部格式</li></ol></li><li><ol><li><ol><li>源端口号，目的端口号：确定数据的来源和去处</li><li>序列号：因为TCP是分包传输的，序列号可以解决乱序的问题</li><li>确认序号：确认包是否收到，解决丢包问题</li><li>状态位：SYN发起连接，ACK回复，RST重新连接，FIN结束连接</li><li>窗口大小：实现流量控制</li></ol></li></ol></li><li><ol><li>三次握手</li></ol></li><li><ol><li><ol><li>流程</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>服务端进行监听</li><li>客户端发送建立请求，然后客户端等待服务端发送确认连接报文</li><li>服务端发送确认连接报文后，负端进入同步已接收状态，等待客户端进行最后的连接确认</li><li>客户端接收到确认连接报文，然后返回连接已确认报文，此时正式建立连接</li></ol></li></ol></li></ol></li><li><ol><li><ol><li>分析：</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>第一次握手的丢失</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>第一次握手是为了告诉服务端，我想和你进行连接</li><li>如果丢失了，此时证明客户端已经发送请求，客户端会等待服务端返回确认请求，服务端没接收到，那么不会返回，客户端会进行超时重传，达到一定次数后，并且等待一定时间后还是没有收到确认报文，那么客户端主动断开连接</li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li>第二次握手的丢失</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>第二次握手是服务端告诉客户端，我知道了你要和我连接，我告诉你一声</li><li>客户端发送建立请求后，客户端等待服务端的确认，服务端因为已经发送了确认，服务端正在等待第三次握手，如果客户端没有得到第二次握手，会超时重传，然后等待，无效再断开连接</li><li>服务端没有接收到客户端的确认（第三次握手），也会进行超时重传，然后等待一段时间没有后，那么服务端会主动断开连接</li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li>第三次握手的丢失</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>第三次握手是客户端建立连接请求被服务端接收到，并且服务端返回 确认报文也被客户端接收到，然后此时进行服务端再等待客户端做最后的连接确认</li><li>客户端进行第三次握手后，会进入连接已建立状态，因为第三次握手丢失了，服务端会一直等待，然后超时重传，达到上限后还没有收到第三次握手，那么会主动断开连接</li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li>第三次握手为何不能省？</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>避免资源浪费</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>tcp传输协议之中，服务端是被动打开的，客户端是主动打开的</li><li>客户端数据传输结束后会关闭连接</li><li>如果客户端发送数据，然后其中某一个数据阻塞了，但是客户端以为自己传输结束了，于是客户端将自己关闭</li><li>然后此时该数据到达了服务端，服务端会被被动打开，服务端会发送确认报文</li><li>此时客户端已经关闭，并且无法被服务端唤醒，所以不会理睬</li><li>那么服务端一直会开启并且等待客户端响应</li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li>如果有了第三次</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>当滞留的请求到达服务器，服务器会向客户端发送连接确认报文，然后会等待第三次握手（因此可以检测到客户端有没有关闭）</li><li>如果如上面的情况，客户端关闭了，那么客户端不会返回请求给服务端，服务端会超时重传，并且不会一直死等，一定时间就关闭，不像上面那样进入连接已建立状态，然后一直白白等。</li></ol></li></ol></li></ol></li><li><ol><li>四次挥手</li></ol></li><li><ol><li><ol><li>流程</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>客户端主动发起TCP连接释放报文，并且进入终止等待状态1</li><li>服务端接收到连接释放报文后，告诉客户端，我还有未发完的数据，然后服务端进入关闭等待，客户端进入终止等待状态2</li><li>服务端将剩余数据传输完毕后再次告诉客户端，此时服务端进入最后确认状态</li><li>客户端收到后，知道数据已经传输完毕，并且发送确认报文，进入最后的时间等待状态</li><li>服务端接收到确认报文后，进行关闭</li><li>客户端经过一定的时间等待后进入关闭</li></ol></li></ol></li></ol></li><li><ol><li><ol><li>为何要进行时间等待？</li></ol></li></ol></li><li><ol><li><ol><li><ol><li>为的就是防止第四次挥手丢失后，服务端总是等待确认而不关闭，服务端会在一定时间告诉客户端：你咋还不发送确认报文啊？客户端收到后，就会知道自己之前的确认报文丢失了，于是会进行报文的重传</li><li>如果没有时间等待，那么服务端无法告诉客户端自己没有收到确认报文，也就无法进行重传，那么服务端也就无法关闭了</li></ol></li></ol></li></ol></li><li><p>IP确定往哪里传输（TCP也是根据IP来发）</p></li><li><ol><li>IP报文头部格式</li><li>IP传输过程</li></ol></li><li><p>MAC地址确定两点之间的传输</p></li><li><ol><li>MAC头部</li><li>发送方MAC地址，接收方MAC地址的获取</li></ol></li><li><ol><li><ol><li>发送方的MAC地址就在网卡里面</li><li>接收方的MAC地址需要根据ARP协议获取</li></ol></li></ol></li><li><ol><li>ARP协议</li></ol></li><li><ol><li><ol><li>使用广播的形式：这个IP地址是谁的啊！？</li><li>网络中的目的地址会进行反应</li><li>将其写入缓存，便于下次直接发送</li></ol></li></ol></li><li><p>网卡，交换机，路由器</p></li><li><ol><li>网卡作用</li><li>交换机作用</li><li>路由器作用</li></ol></li><li><p>接收端层层拆解获取HTTP数据</p></li></ol><p><img src="D:\Blog\source\img\数据传输过程.png"></p><h4 id="如何优化TCP？"><a href="#如何优化TCP？" class="headerlink" title="如何优化TCP？"></a>如何优化TCP？</h4><h5 id="优化三次握手"><a href="#优化三次握手" class="headerlink" title="优化三次握手"></a>优化三次握手</h5><ul><li><p>客户端优化</p><p>客户端发起第一次建立连接请求时，如果长时间没有收到第二次的确认连接，那么会进行超时重传，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次。并且每次<strong>超时重传时间是上一次的2倍</strong>，1-&gt;2-&gt;4-&gt;8-&gt;16</p><p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手，总共耗时63秒，我们可以对其进行优化。</p><ul><li>通过 <code>tcp_syn_retries</code> 控制其重传的次数。</li><li>比如在内网通讯的时候，减少重传次数，尽快获取错误。</li></ul></li><li><p>服务端优化</p><ul><li>通过netstat -s 观察半连接队列溢出情况，通过tcp_max_syn_backlog、somaxconn、backlog，调整半连接队列的大小</li></ul></li><li><p>绕过三次握手</p><ul><li><p>使用TCP Fast Open 功能绕过三次握手</p><p><img src="D:\Blog\source\img\绕过三次连接.png"></p></li></ul></li></ul><p>在客户端首次建立连接时的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li><li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li><li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li></ol><p>所以，第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。</p><p>之后，如果客户端再次向服务器建立连接时的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含「数据」（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 Cookie；</li><li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li><li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li><li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li><li>此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。</li></ol><p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。</p><p>如何解决三次握手中的缺少第三次握手的问题呢？</p><h5 id="优化四次挥手"><a href="#优化四次挥手" class="headerlink" title="优化四次挥手"></a>优化四次挥手</h5><p>看不懂啊</p><ul><li>调整重传次数</li></ul><h5 id="TCP传输数据的性能提升"><a href="#TCP传输数据的性能提升" class="headerlink" title="TCP传输数据的性能提升"></a>TCP传输数据的性能提升</h5><ul><li>提升滑动窗口的大小</li></ul><h4 id="为什么每次TCP建立连接的初始序列号都不一样？"><a href="#为什么每次TCP建立连接的初始序列号都不一样？" class="headerlink" title="为什么每次TCP建立连接的初始序列号都不一样？"></a>为什么每次TCP建立连接的初始序列号都不一样？</h4><ul><li>极大的降低历史连接的概率</li></ul><h4 id="SYN报文什么情况下会被丢弃？"><a href="#SYN报文什么情况下会被丢弃？" class="headerlink" title="SYN报文什么情况下会被丢弃？"></a>SYN报文什么情况下会被丢弃？</h4><ul><li>半连接队列已满</li><li>全连接队列已满</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/04/JVM/"/>
    <url>/2023/11/04/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM-概述"><a href="#JVM-概述" class="headerlink" title="JVM 概述"></a>JVM 概述</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作<br>特点：</p><ul><li>Java 虚拟机基于二进制字节码执行，由一套字节码指令集、 一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong><ul><li>因为字节码是只针对JVM而言的虚拟机指令集</li><li>不同的平台实现的JVM不同（jvm和平台底层的逻辑处理关系），但是都遵循JVM规范，可以正确读取字节码</li></ul></li></ul><p>Java代码执行流程：Java 程序 –（编译）–&gt; 字节码文件 –（解释执行）–&gt; 操作系统（Win，Linux）</p><p>JVM、JRE、JDK对比：</p><ul><li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li><li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件<br><img src="D:\Blog\source\img\jdk，jre，jvm对比.png"></li></ul><h4 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h4><p>Java 编译器输入的指令流是一种<strong>基于栈的指令集架构</strong>。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以<strong>不能设计为基于寄存器架构</strong></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>JVM 的生命周期分为三个阶段，分别为：<strong>启动、运行、死亡</strong></p><ul><li><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</li><li><strong>运行</strong>：<ul><li>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</li><li>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，JVM 使用的是守护线程，main() 和其他线程使用的是用户线程，守护线程会随着用户线程的结束而结束<ul><li>用户线程是由应用程序代码创建和管理的线程，它们通常用于执行应用程序的业务逻辑和任务。</li><li>守护线程是一种特殊类型的线程，它的存在不会阻止JVM退出。它们通常用于<strong>执行后台任务和服务</strong>，如垃圾回收、定时任务等。</li><li>守护线程在用户线程结束后，如果没有其他用户线程继续运行，它们会自动退出，以确保JVM正常关闭。</li></ul></li><li>执行一个 Java 程序时，真真正正在执行的是一个 Java 虚拟机的进程</li><li>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</li><li>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</li></ul></li><li><strong>死亡</strong>：<ul><li>当程序中的用户线程<strong>都中止</strong>，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h4 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h4><ul><li>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</li><li>JVM 内存结构<strong>规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行</strong><br><img src="D:\Blog\source\img\java1.8内存结构.png"></li></ul><h4 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h4><ol><li><p>程序计数器</p><ul><li>作用，记住下一条jvm指令的执行地址，在上下文切换后就可以知道之前运行到哪里了</li><li>特点<ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul></li><li>原理<ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul></li></ul></li><li><p>虚拟机栈</p><ul><li>每个线程运行所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存（存储局部变量表，操作数栈，动态链接，方法出口等信息）<ul><li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的地址（即程序执行下一条指令）</li><li>操作数栈：存储方法执行过程中的临时数据和中间结果</li><li>表达式栈和其他一些附加信息</li></ul></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li><li>虚拟机栈特点：<ul><li>栈内存不需要进行GC，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</li><li>方法内的局部变量是否线程安全：<ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul></li></ul></li><li><p>本地方法栈</p><ul><li>本地方法栈是为虚拟机执行本地方法时提供服务的</li></ul></li><li><p>堆<br>Heap 堆：是 JVM 内存中最大的一块，<strong>由所有线程共享</strong>，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题<br>存放：</p><ul><li>对象实例：类初始化生成的对象，基本数据类型的数组也是对象实例，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放在方法区，JDK7开始存放于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li><li>堆内存诊断工具：</li></ul><ol><li>jps：查看当前系统中有哪些 Java 进程</li><li>jmap：查看堆内存占用情况 jhsdb jmap –heap –pid 进程id</li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测、</li></ol></li><li><p>方法区</p><blockquote><p>在Java 8及之前的版本，<strong>方法区是堆的一部分</strong>，而在Java 8及以后的版本，方法区的实现发生了变化。在Java 8及以后，永久代（Permanent Generation）被移除，而方法区的内容被放置在一个称<strong>为元空间（Metaspace）的本地内存区域中</strong>。</p><p>元空间不再有固定的内存大小，而是根据应用程序的需要动态地调整大小。元空间的数据结构和存储方式可能与传统的永久代有所不同，它更灵活地利用本地内存，并且在一定程度上缓解了永久代的一些限制。</p></blockquote><ol><li>方法区：</li></ol><ul><li>是<strong>各个线程共享</strong>的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</li><li>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</li></ul><ol start="2"><li>为了避免方法区出现 OOM(Out Of MemoryError)，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，静态变量和字符串常量池等放入堆中</li><li>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了类在编译期间生成的字面量、符号引用，JVM 为每个已加载的类维护一个常量池</li></ol><ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul><ol start="5"><li>运行时常量池是方法区的一部分</li></ol><ul><li>常量池：<ul><li>常量池是位于Java类文件（.class文件）中的一部分，用于存储各种常量信息，包括字符串常量、类名、方法名、字段名、常量值等。</li><li>常量池中的常量信息在编译期间被收集和生成，并在运行时被加载到内存中供JVM使用。</li><li>常量池中的常量是不可修改的，一旦定义，就不能被更改。</li><li>常量池中的字符串常量通常是被共享的，即多个字符串变量可以引用相同的字符串对象，以减少内存占用。</li></ul></li><li>StringTable<ul><li>StringTable是JVM内部的数据结构，用于管理和存储字符串对象。</li><li>具体请看：<a href="https://blog.csdn.net/cd546566850/article/details/105353791">JVM内存结构之浅析常量池、运行时常量池、StringTable</a><br><img src="D:\Blog\source\img\创建Java对象.png"></li></ul></li></ul></li><li><p>直接内存</p><ol><li>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul></li></ol></li></ol><h4 id="JVM与线程的关系"><a href="#JVM与线程的关系" class="headerlink" title="JVM与线程的关系"></a>JVM与线程的关系</h4><ul><li>线程由JVM创建和管理</li><li>JVM负责线程的生命周期</li><li>JVM为每个线程分配独立资源：<ul><li>每个线程都有自己的  程序计数器、栈、堆</li></ul></li></ul><h2 id="JVM-垃圾回收和内存分配"><a href="#JVM-垃圾回收和内存分配" class="headerlink" title="JVM 垃圾回收和内存分配"></a>JVM 垃圾回收和内存分配</h2><h4 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h4><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用<strong>分代垃圾收集算法</strong>，所以 Java 堆被划分为了几个不同的区域，这样我们就可以<strong>根据各个区域的特点选择合适的垃圾收集算法</strong>。</p><p>堆内存主要被划分为两个部分：</p><ul><li>新生代<ul><li>包括Eden空间，SurvivorFrom，SurvivorTo</li></ul></li><li>老年代</li><li>永久代（1.8后被移除）：<ul><li>存储类的元数据和静态变量</li><li>元数据包括：类的结构信息，方法的字节码，常量池，字段，方法描述符等</li><li>1.8后将上述的数据存储在了方法区的元空间里，不占用堆内存，使用的是本地内存，所以内存十分充足。</li></ul></li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul><li>分配流程<ul><li>对象一般在堆上分配</li><li>对象优先在Eden分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul></li></ul><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><ul><li>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</li><li>垃圾收集主要针对<strong>堆和方法区</strong>进行，程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，只存在于线程的生命周期内，线程结束后就会消失，因此不需要进行垃圾回收</li></ul><h4 id="如何判断可以进行垃圾回收"><a href="#如何判断可以进行垃圾回收" class="headerlink" title="如何判断可以进行垃圾回收"></a>如何判断可以进行垃圾回收</h4><ul><li><p>引用计数算法 </p><ul><li>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。<ul><li>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；</li><li>当引用失效时，引用计数器就减 1；</li><li>当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</li></ul></li><li>优点：<ul><li>回收没有延迟性，无需等到内存不够时才开始回收</li></ul></li><li>缺点：<ul><li>每次对象被引用时，都需要更新计数器，有时间开销</li><li>浪费cpu资源，内存够用时，计数器统计仍在进行</li><li><strong>无法解决循环引用问题，会引发内存泄漏</strong>（即互相引用的对象永远也无法被回收）</li></ul></li></ul></li><li><p>可达性分析算法</p><ul><li>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</li><li>GC Roots 对象：<ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li><li>GC Roots <strong>是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</li></ul></li><li>工作原理：<ul><li>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象<ul><li>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li></ul></li></ul></li></ul></li><li><p>finalization</p><ul><li>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong></li><li>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</li><li><strong>finalize()只能被调用一次</strong></li></ul></li><li><p>引用分析</p><ul><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致内存泄漏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//使用 new 一个新对象的方式来创建强引用</span><br></code></pre></td></tr></table></figure></li><li><p>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>配合引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li></ul></li><li><p>弱引用：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li></ul></li><li><p>虚引用：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的<strong>唯一目的是在于跟踪垃圾回收过程，监测对象是否存活</strong></li></ul></li><li><p>终结器引用（finalization）</p></li><li><p>引用队列作用：</p><ul><li>引用队列（ReferenceQueue）是一种特殊的队列，用于<strong>保存被垃圾回收器回收的对象的引用</strong>。它的主要作用是提供一种<strong>通知机制</strong>，让开发者能够在对象被回收时得到通知。</li><li>当一个对象被虚引用、软引用或者弱引用所引用时，如果该对象被垃圾回收器回收，那么对应的引用会被添加到引用队列中。开发者可以通过检查引用队列，获取这些引用，从而得知对象何时被回收。</li><li><strong>也就是说，将要回收的对象会被引用，然后放到引用队列之中，如果被回收成功，那么队列之中相应引用也就消失，然后根据这个来检查队列之中哪些对象被成功回收</strong></li></ul></li></ul></li></ul><h4 id="软引用、弱引用、虚引用的对比"><a href="#软引用、弱引用、虚引用的对比" class="headerlink" title="软引用、弱引用、虚引用的对比"></a>软引用、弱引用、虚引用的对比</h4><ul><li>软引用：在内存不足时可以被回收，但相对较慢，主要用于实现缓存机制。</li><li>弱引用：无论内存是否充足，只要没有强引用引用该对象，就会被回收，主要用于非必需引用的场景。</li><li>虚引用：无法通过虚引用获取对象的实例，主要用于跟踪对象的回收状态。</li></ul><h4 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h4><p>当常量池中的该常量没有被任何对象所引用时，该常量是废弃常量</p><h4 id="如何判断一个类是无用的类？"><a href="#如何判断一个类是无用的类？" class="headerlink" title="如何判断一个类是无用的类？"></a>如何判断一个类是无用的类？</h4><ul><li>该类的所有实例都已经被回收，即Java堆中不存在任何该类的实例</li><li>加载该类的<code>ClassLoader</code>已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，<strong>而并不是和对象一样不使用了就会必然被回收</strong>。</p><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ol><li>标记-清除法<ul><li>先标记，再清除 </li><li><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></li><li><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li><li>缺点：<ul><li>因为没有整理，所以会产生不连续的内存碎片</li></ul></li></ul></li><li>标记-整理法<ul><li>与标记-清除法一样，不过清除之后将存活对象都移动到了内存的一端，解决了内存碎片问题</li><li>缺点：<ul><li>需要遍历移动对象，处理效率低</li></ul></li></ul></li><li>标记-复制法<ul><li>前提：每次新生代都会回收大量的垃圾（90%？） </li><li>将内存空间划分成两个部分，一个from，一个to</li><li>当回收垃圾时，会将非垃圾的对象复制到另一块区域（将from区非垃圾复制到to区），并在复制的时候保证了内存的连续性。</li><li>清空from区，将from指针和to指针互换（即from又指向了非垃圾对象区，to又指向了空区）<br><img src="D:\Blog\source\img\标记复制算法.png"> </li><li>缺点：<ul><li>需要占用双倍内存</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul></li></ul></li></ol><h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><p>在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本（因为死了的不需要复制，只需要复制少量存活的即可）就可以完成每次垃圾收集。</p><p>而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><ul><li><strong>新生代</strong><ul><li>是用来<strong>存放新生的对象</strong>。一般占据堆的1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾 回收。新生代又分为Eden 区、ServivorFrom、 ServivorTo 3个区。</li></ul></li><li><strong>老年代</strong><ul><li>主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以MajorGC（fullGC）不会频繁执行。在进行MajorGC 前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。<br><img src="D:\Blog\source\img\新生代老生代.png"></li></ul></li><li><strong>分代回收过程</strong>：<ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc</li></ul></li><li><strong>永久代</strong><ul><li>指内存的永久保存区域，主要存放Class 和Meta (元数据)的信息,Class在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class 的增多而胀满，最终抛出OOM异常。</li><li>在Java8 中，永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代。</li><li>元空间的本质和永久代类似，元空间与永久代之间最大的区别在于:<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，<strong>元空间的大小仅受本地内存限制</strong>。</li><li>类的元数据放入native memory,字符串池和类的静态变量放入java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</li></ul></li><li><strong>回收策略</strong><ul><li>部分收集：不是进行整个java堆的垃圾收集<ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集（很多时候不区分Full GC和Major GC）</li></ul></li><li>整堆收集：<ul><li>Full GC</li></ul></li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器<br><img src="D:\Blog\source\img\serial收集器.jpg"> </p><ul><li>又叫串行收集器，以串行方式执行</li><li>是单线程收集器，只会使用一个线程进行垃圾收集</li><li>简单高效</li></ul></li><li><p>ParNew收集器<br><img src="D:\Blog\source\img\parnew收集器.jpg"> </p><ul><li>是Serial收集器的多线程版本</li><li>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</li><li>默认开启线程数量与cpu数量相同</li><li>单核下性能绝不会比serial收集器好</li></ul></li><li><p>Parallel Scavenge收集器</p><ul><li>与ParNew一样是多线程收集器，目标是尽可能缩短垃圾收集时用户线程停顿的时间，达到一个可控制的吞吐量，也被称为：吞吐量优先 收集器</li><li>这里的吞吐量指：cpu运行用户代码时间 &#x2F; 总时间</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。（当新生代空间变少，自然用于停顿标识垃圾的时间也就减少了）</li></ul></li><li><p>Serial Old收集器<br><img src="D:\Blog\source\img\serialold收集器.jpg"></p><ul><li>与Serial收集器对比，回收区域不同，回收方式也不同</li><li>serial收集器的老年代版本</li></ul></li><li><p>Parallel Old收集器<br><img src="D:\Blog\source\img\parallelold收集器.jpg">  </p><ul><li>是 Parallel Scavenge 收集器的老年代版本。</li></ul></li><li><p>CMS收集器<br><img src="D:\Blog\source\img\cms收集器.jpg"> </p><ul><li>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</li><li>流程：<ul><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。（不影响用户线程的运行）</li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除: 不需要停顿。</li></ul></li><li>缺点；<ul><li>吞吐量低，低停顿时间是以牺牲吞吐量为代价，导致cpu利用率不高<ul><li>（为什么呢？因为其并发标记时占用了线程，使用户线程执行的时间变少了）</li></ul></li><li>无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程仍在继续而产生的垃圾，这部分垃圾只能在下一次GC才能进行回收。<ul><li>意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li></ul></li><li>使用的标记-清除算法会导致空间碎片</li></ul></li></ul></li><li><p>Garbage First收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html">G1详解</a><br><img src="D:\Blog\source\img\g1收集器.jpg"> </p><ul><li>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</li><li>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</li><li>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li><li>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</li><li>步骤<ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</li></ul></li><li>使用标记-整理算法，不会产生内存碎片</li><li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul></li><li><p>ZGC收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-zgc.html">ZGC详解</a><br><img src="D:\Blog\source\img\zgc垃圾回收.png">  </p><ul><li>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：<ul><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；</li><li>支持8MB~4TB级别的堆（未来支持16TB）。</li></ul></li><li>使用关键技术<ul><li>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。<ul><li>染色指针是一种将信息存储在指针中的技术</li></ul></li><li>在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。<ul><li>读屏障类似于aop的环绕方法，在事件发生的前后进行指定的操作</li></ul></li></ul></li></ul></li></ul><h2 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h2><h3 id="类字节码"><a href="#类字节码" class="headerlink" title="类字节码"></a>类字节码</h3><h4 id="多语言编译为字节码在JVM运行"><a href="#多语言编译为字节码在JVM运行" class="headerlink" title="多语言编译为字节码在JVM运行"></a>多语言编译为字节码在JVM运行</h4><ul><li>为什么需要字节码：<ul><li>计算机是不能直接运行java代码的，java代码必须先编译成字节码文件，然后由jvm识别转换成对应操作系统的指令。</li></ul></li><li>为什么jvm不能直接运行java代码：<ul><li>这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的</li><li>所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。这样也就实现了一次编写到处运行的目的。</li><li><img src="D:\Blog\source\img\java在jvm的加载过程.png"></li></ul></li></ul><h4 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h4><ul><li>编译后形成的class到底是个啥<ul><li>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。</li><li>jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</li></ul></li><li>Class文件结构属性<br><img src="D:\Blog\source\img\class文件结构属性.png"></li></ul><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><h4 id="类加载到底是干什么的？"><a href="#类加载到底是干什么的？" class="headerlink" title="类加载到底是干什么的？"></a>类加载到底是干什么的？</h4><p>类加载是Java虚拟机（JVM）在运行时将类的字节码文件加载到内存中的过程。</p><p>这个过程的目的是为了使得运行中的Java程序能够访问、执行和操作类的定义，以支持程序的正常运行和动态性。</p><p>可以说是：</p><ul><li>我要使用到这个类，那么我就需要知道这个类的 “规范”，去哪里查看规范呢？</li><li>就是去内存中的<strong>方法区</strong>查看类。</li><li>每当加载一个类（类是存储在方法区）就会在堆中创造一个Class实例，Class实例可以支持Java的反射特性</li></ul><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><blockquote><p>类的生命周期包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段<br><img src="D:\Blog\source\img\类的生命周期.png"></p></blockquote><ul><li><p><strong>加载: 查找并加载类的二进制数据</strong></p><ul><li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li><li><p><strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p></li><li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><blockquote><p>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></blockquote></li><li><p>加载方式</p><ul><li>本地系统直接加载</li><li>网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul></li><li><p><strong>验证: 确保被加载的类的正确性</strong></p><ul><li>验证是连接阶段的第一步，这一阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。验证阶段大致会完成4个阶段的检验动作:<ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，如是否以<code>0xCAFEBABE</code>开头<ul><li>字节码文件魔数0xCAFEBABE，每一个java字节码文件(.class)都是以相同的4字节内容开始的——十六进制的CAFEBABE，用来判断是否是java字节码文件（文件名后缀+魔数等）</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求，例如: 这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行</li></ul></li></ul></li><li><p><strong>准备: 为类的静态变量分配内存，并将其初始化为默认值</strong></p><ul><li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong><ul><li>这时候进行内存分配的仅包括**类变量(static)**，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。</li></ul></li></ul></li><li><p><strong>解析: 把类中的符号引用转换为直接引用</strong></p><ul><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程<ul><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</li></ul></li><li>符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li><strong>性能更高，直接存地址和引用，就不需要解析符号，然后再去找值</strong></li></ul></li><li><p><strong>初始化：为类的静态变量赋予正确的初始值</strong></p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li><li><strong>初始化步骤</strong><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li><strong>类初始化时间</strong><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul></li></ul></li><li><p><strong>使用</strong></p><ul><li>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</li></ul></li><li><p><strong>卸载</strong></p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul></li></ul><h4 id="类加载器、JVM类加载机制"><a href="#类加载器、JVM类加载机制" class="headerlink" title="类加载器、JVM类加载机制"></a>类加载器、JVM类加载机制</h4><ul><li><p>类加载器的层次<br><img src="D:\Blog\source\img\类加载器的层次.png"> </p></li><li><p>启动类加载器（Bootstrap ClassLoader）：</p><ul><li>负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><p>扩展类加载器（Extension ClassLoader）：</p><ul><li>该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li></ul></li><li><p>应用程序类加载器（Application ClassLoader）：</p><ul><li>该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><blockquote><p>启动类加载器加载核心库，扩展类加载器加载扩展库，应用程序类加载器加载用户类路径上的类。</p></blockquote></li><li><p>类的加载</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>JVM类加载机制</p><ul><li><code>全盘负责</code><ul><li>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul></li><li><code>父类委托</code><ul><li>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li></ul></li><li><code>缓存机制</code><ul><li>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</li><li><strong>这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</strong></li></ul></li><li><code>双亲委派机制</code><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上</li><li>因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul></li></ul></li><li><p><strong>双亲委派机制过程？</strong></p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol></li><li><p><strong>双亲委派优势</strong></p><ul><li><p>系统类防止内存中出现多份同样的字节码，即<strong>避免重复加载</strong></p><ul><li><p>理解”类的唯一性”可以通过一个反例更清晰：</p><ul><li><p>假设没有双亲委派机制，而是每个类加载器都可以独立加载类。考虑以下情况：</p><ul><li><strong>类A被应用程序类加载器加载。</strong></li><li><strong>同一个类A也存在于一个自定义类加载器加载的jar包中。</strong></li></ul></li></ul></li></ul></li><li><p>保证Java程序安全稳定运行，即<strong>避免篡改核心类</strong></p></li><li><p>例如，有一个你写了一个Object类，放在ClassPath下去给应用程序加载器加载，此时应用程序加载器会让一层一层往上传递信息，如果父类有Object类，则会加载父类的Object，而不会加载子类的。</p></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2023/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<hr><ul><li><p>并查集理论基础：</p><ul><li>并查集专门用来解决两类问题：<ul><li>将两个元素添加到一个集合之中</li><li>判断两个元素是否在同一个集合中</li></ul></li></ul></li><li><p>模板如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span>[] father)</span>&#123;<br>        <span class="hljs-comment">//father[i]代表的是结点 i 的父结点</span><br>        <span class="hljs-keyword">if</span> (father[u] == u)&#123;<br>            <span class="hljs-keyword">return</span> u;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//一直往上找，直到找到最根的结点，并且递归的依次设置好，实现路径压缩</span><br>            father[u] = find(father[u],father);<span class="hljs-comment">//路径压缩</span><br>            <span class="hljs-keyword">return</span> father[u];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span>[] father)</span>&#123;<br>        <span class="hljs-comment">//找到u的根</span><br>        u = find(u,father);<br>        <span class="hljs-comment">//找到v的根</span><br>        v = find(v,father);<br>        <span class="hljs-keyword">if</span> (u == v)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//根不同，则不在一个子集</span><br>            father[v] = u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameRoot</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span>[] father)</span>&#123;<br>        u = find(u,father);<br>        v = find(v,father);<br>        <span class="hljs-keyword">if</span> (u == v)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span>[] father)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; father.length; i++)&#123;<br>            father[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> destination)</span> &#123;<br>        <span class="hljs-comment">//使用并查集，加入后再进行find即可</span><br>        <span class="hljs-type">int</span>[] father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        init(father);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++)&#123;<br>            join(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>], father);<br>        &#125;<br>        <span class="hljs-keyword">return</span> isSameRoot(source,destination,father);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构基础</title>
    <link href="/2023/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>是二叉树</li><li>对于其每一棵树：<strong>左孩子 &lt; 根节点 &lt; 右孩子</strong></li><li>没有value相等的节点<br><img src="/../img/bst.png"></li></ul><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>是二叉树</li><li>高度平衡：<strong>AVL树中任何节点的两个子树的高度最大差别为1。</strong><br><img src="/../img/avl.png"></li></ul><h3 id="红黑树（R-B-Tree）"><a href="#红黑树（R-B-Tree）" class="headerlink" title="红黑树（R-B Tree）"></a>红黑树（R-B Tree）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul><li>红黑树（Red Black Tree） 是一种自平衡二叉查找树</li><li>为什么需要红黑树？<ul><li>平衡二叉树的优点就在于其查找，插入，删除的平均以及最坏情况都是O(logn)，这是因为平衡二叉树的高度之差的最大值始终都是1，但是如果对平衡二叉树进行删除和插入，平衡二叉树的平衡状态可能被破坏，为了维持平衡，会对其进行旋转处理。此时引入了红黑树。</li><li>红黑树时间复杂度差于平衡二叉树，但是红黑树的插入和删除操作更加便于控制，并且红黑树整体性能略优于平衡二叉树（因为其旋转情况少于平衡二叉树）</li></ul></li></ul><blockquote><p>: 红黑树是一棵二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。</p></blockquote><ul><li>性质<ul><li>每个节点颜色不是黑色，就是红色</li><li>根节点是黑色的</li><li>如果一个节点是红色，那么它的两个子节点就是黑色的(没有连续的红节点)</li><li>对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点</li></ul></li></ul><h3 id="哈夫曼树（Huffman-Tree）"><a href="#哈夫曼树（Huffman-Tree）" class="headerlink" title="哈夫曼树（Huffman Tree）"></a>哈夫曼树（Huffman Tree）</h3><h3 id="前缀树（Trie-Tree）"><a href="#前缀树（Trie-Tree）" class="headerlink" title="前缀树（Trie Tree）"></a>前缀树（Trie Tree）</h3><h3 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+树"></a>B-树和B+树</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><ul><li>多路搜索树，每个节点可以拥有多个子节点</li><li>非叶子节点可以存储数据<br><img src="/../img/b-%E6%A0%91.png"></li></ul><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><ul><li>对B-树的优化</li><li>非叶子节点不存储数据<br><img src="/../img/b+%E6%A0%91.png"></li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基础知识"><a href="#图的基础知识" class="headerlink" title="图的基础知识"></a>图的基础知识</h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-应用层</title>
    <link href="/2023/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2023/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h3><ul><li>应用层的作用：<ul><li>解决通过应用进程的交互来实现特定网络应用的问题</li><li>我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是运输层。</li><li>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</li></ul></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h4><ul><li>HTTP是什么<ul><li>HTTP是超文本传输协议：Hyper Text Transfer Protocol</li><li>协议：<ul><li>建立了交流通信的规范</li></ul></li><li>传输：<ul><li>HTTP协议是一个双向协议</li><li>允许有中转或接力（在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。）</li></ul></li><li>超文本：<ul><li>内容超文本</li><li>是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li></ul></li><li><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong><ul><li>可以是服务器到浏览器，也可以是服务器到服务器等。</li></ul></li></ul></li><li>HTTP常见状态码<ul><li><code>1xx</code>：提示信息</li><li><code>2xx</code>：服务器成功处理请求</li><li><code>3xx</code>：表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong></li><li><code>4xx</code>：表示客户端发送的报文有误，服务器无法处理。<ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li><code>5xx</code>：表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务端的错误。</li></ul></li><li>HTTP常见字段<ul><li>Host 字段<ul><li>客户端发送请求时，用来指定服务器的域名。</li></ul></li><li>Content-Length 字段<ul><li>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</li></ul></li><li>Connection 字段</li><li>Content-Type 字段<ul><li>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ul></li><li>Content-Encoding 字段<ul><li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li></ul></li></ul></li></ul><h4 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h4><ul><li>GET和POST的区别<ul><li>GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。</li><li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。</li></ul></li><li>GET和POST方法都是安全和幂等的吗？<blockquote><p>安全：在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>幂等：所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></blockquote><ul><li><p>GET方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</p></li><li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</p></li></ul></li></ul><h4 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h4><ul><li><p>作用</p><ul><li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，提升服务的性能。</li></ul></li><li><p>强制缓存</p><ul><li>浏览器发现本地资源A后，根据与服务器的检验规则，<strong>浏览器给本地资源A进行检验</strong><ul><li>如果符合要求，浏览器直接返回该本地资源</li><li>如果不符合要求，浏览器会向服务器发送资源请求</li></ul></li><li>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</li><li>实现：<ul><li>利用HTTP响应头部(Response Header)字段实现<ul><li><code>Cache-Control</code>：相对时间，优先级更高</li><li><code>Expires</code>：绝对时间</li></ul></li></ul></li><li>流程：<ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部添加Cache-Control，Cache-Control中设置了过期时间</li><li>当浏览器再次访问该资源时，会根据Cache-Control来计算该资源是否过期，如果没过期则直接使用，否则重新发起请求，服务器收到请求后，会更新Response头部的Cache-Control</li></ul></li></ul></li><li><p>协商缓存</p><ul><li>浏览器发现本地资源A后，浏览器给服务器发送一个请求，将资源A的相关信息告诉服务器，<strong>服务器对其进行检验</strong><ul><li>如果符合要求，浏览器直接返回该本地资源</li><li>如果不符合要求，服务器会直接返回一份新的资源A</li></ul></li><li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</li><li>实现：<ul><li>请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul><li>客户端会在请求头中使用<code>If-Modified-Since</code>，将之前获取资源时服务器返回的<code>Last-Modified</code>值发给服务器</li><li>服务器收到请求后，会将客户端返回的<code>If-Modified-Since</code>里的值（即本地缓存的最新修改时间），与服务器的最新修改时间对比</li><li>如果本地缓存仍然是最新的，那么返回304 Not Modified，客户端收到后则知道仍然可以使用缓存中的副本</li><li>如果缓存不是最新，服务器会返回新的资源，并且响应头中包含新的<code>Last-Modified</code>值</li></ul></li><li>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul></li><li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li><li>所以Etag的优先级更高</li></ul></li><li>Etag实现过程：<ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的</li><li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<ul><li>如果没有过期，则直接使用本地缓存</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段（存的Etag值），该字段的值就是 ETag 唯一标识</li></ul></li><li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<ul><li>如果值相等，则返回 304 Not Modified，不会返回资源</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul></li></ul></li><li><p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p><ul><li>再次发起相同请求</li><li>本地检验缓存（强制缓存），成功直接使用，未成功则进行协商缓存</li><li>协商缓存进行检验，成功直接使用，未成功则重新返回并更新相关检验的字段</li></ul></li></ul><h4 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP&#x2F;1.1 特性"></a>HTTP&#x2F;1.1 特性</h4><ul><li>优点<ul><li>简单：报文形式：header + body，头部信息：key + value</li><li>灵活易扩展：各类请求方法并未固定死，可以自定义和扩展</li><li>应用广泛和跨平台</li></ul></li><li>缺点<ul><li>无状态：<ul><li>好处：服务器无需存储HTTP状态，节省资源</li><li>坏处：服务器没有记忆能力，完成有关联性的操作很麻烦，例如在网上购物时，每一步操作都需要知道用户身份，服务器不存储状态，因此每一步操作都需要验证身份信息（cookie技术和session技术解决）。</li></ul></li><li>明文传输：<ul><li>好处：方便阅读，方便调试</li><li>坏处：信息不安全</li></ul></li></ul></li><li>性能分析<ul><li>长连接<ul><li>在早期的HTTP&#x2F;1.0中，每次发起一个请求都需要新建一次TCP连接，并且串行请求（一个请求的响应完全返回后，才能发起下一个请求）。</li><li>为了解决上述连接问题，HTTP&#x2F;1.1提出了<strong>长连接</strong>（持久连接）的通信方式，只要任意一端没有明确提出断开连接，则保持TCP连接状态。（如果超过一定时间没有数据交互，服务器也会主动断开该连接）<br><img src="/../img/%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB.png"></li></ul></li><li>管道网络运输（并不默认开启该功能）<ul><li>HTTP&#x2F;1.1采用了长连接的方式，使得管道网络传输成为了可能，即可在同一个TCP连接里，客户端发起多个请求，只要第一个请求发出去，不必等待其回来，就可以发送第二个请求，由此减少整体响应时间。<br><img src="/../img/%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93.png"> </li><li>请求必须有序。</li><li>如果服务端在处理某个请求队列头部的请求时，耗时较长，那么后续的请求处理都会被阻塞，这被成为队头堵塞。</li></ul></li><li>队头阻塞<br><img src="/../img/%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E.png"></li></ul></li></ul><h4 id="HTTP-1-1-如何优化"><a href="#HTTP-1-1-如何优化" class="headerlink" title="HTTP&#x2F;1.1 如何优化"></a>HTTP&#x2F;1.1 如何优化</h4><ol><li>避免发送HTTP请求<ol><li>使用缓存技术</li></ol></li><li>减少HTTP请求发送次数<ol><li>减少重定型请求<ul><li>重定向就是一个服务器资源从url1迁移到url2后，但是客户端并不知情，仍然请求url1，此时服务器会通过302响应码和Location头部告诉客户端资源已经迁移至url2。 </li><li>解决方案：<ul><li>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了<br><strong>旧</strong><br><img src="/../img/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88.png"><br><strong>新</strong><br><img src="/../img/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%AE%E5%BF%99%E5%A4%84%E7%90%86%E9%87%8D%E5%AE%9A%E5%90%91.png"></li></ul></li></ul></li><li>合并求情<ul><li>把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。 </li><li>这样也带来了问题，当大资源中的某个小资源发生了变化，客户端必须重新下载整个大资源，带来了额外的网络消耗</li></ul></li><li>延迟发送请求<ul><li>按需获取，例如请求网页的时候，没必要获取全部资源，而是仅仅获取当前用户所需要的资源即可</li></ul></li></ol></li><li>减少HTTP响应数据的大小<ul><li>对响应的资源进行压缩</li></ul></li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h4 id="HTTPS-解决了HTTP的哪些问题？"><a href="#HTTPS-解决了HTTP的哪些问题？" class="headerlink" title="HTTPS 解决了HTTP的哪些问题？"></a>HTTPS 解决了HTTP的哪些问题？</h4><ul><li>实现了<ul><li>信息加密：交互信息无法被窃取。</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示。</li><li>身份证书：证明淘宝是真的淘宝网。</li></ul></li><li>实现方案：<ul><li>混合加密的方式实现信息的机密性，解决了窃听的风险。</li><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到数字证书中，解决了冒充的风险。</li></ul></li></ul><h4 id="HTTPS的实现方式"><a href="#HTTPS的实现方式" class="headerlink" title="HTTPS的实现方式"></a>HTTPS的实现方式</h4><ul><li><strong>混合加密</strong><blockquote><ul><li>公钥：公开给所有人；私钥：必须本人保管，不可泄漏</li><li>二者可以双向进行解密和加密<br><strong>公钥加密，私钥解密。这个目的是为了保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br><strong>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul></blockquote><blockquote><ul><li>对称加密：使用相同的密钥（称为对称密钥）同时用于加密和解密数据。对称加密算法存在一个密钥分发的问题。发送方和接收方必须事先共享密钥，这在分布式环境中可能会变得复杂和不安全。</li><li>非对称加密：使用一对密钥，分别是公钥和私钥。发送方使用接收方的公钥对数据进行加密，而接收方使用自己的私钥对数据进行解密。</li></ul></blockquote><ul><li>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：<ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li><li>简单来说就是，数据使用对称加密，然后因为对称加密的密钥传输有可能有安全问题，于是使用非对称加密来传输对称加密的密钥<br><img src="/../img/https%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png"></li></ul></li><li>原因：<ul><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></li></ul></li><li><strong>摘要算法 和 数字签名</strong><br>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</li></ul><p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</p><ul><li>所以使用摘要算法：计算出内容指纹一并传输给接收方，让接收方来校验，并且为了防止被攻击者将内容和指纹一同修改，所以使用数字签名：私钥加密，公钥解密，确定是来自于指定对象。<br><img src="/../img/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></li><li><strong>数字证书</strong><br>如果造假者进行公钥的伪造，那么数字签名也就失效了，因为它传私钥给你也传公钥给你。</li></ul><p>所以为了防止这种漏洞，发送方可以将自己的公钥上传给权威机构CA（数字证书认证机构），接收方就不会出现使用伪造公钥的情况了<br><img src="/../img/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png"></p><h4 id="HTTPS如何进行连接和交互"><a href="#HTTPS如何进行连接和交互" class="headerlink" title="HTTPS如何进行连接和交互"></a>HTTPS如何进行连接和交互</h4><ul><li>SSL&#x2F;TLS协议基本流程<ul><li>客户端向服务器索要并且验证服务器的公钥</li><li>双方协商产生会话密钥</li><li>双方采用会话密钥进行加密通信</li></ul></li></ul><h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><ul><li>改善：<ul><li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul></li><li>不足：<ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li></ul><h4 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h4><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。‘</p><ul><li><p>改善：</p><ul><li>头部压缩：HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。（使用一个表来维护所有字段，根据需要生成索引来确定需要哪些字段）</li><li>二进制格式：HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame），对计算机而言增加了传输效率</li><li>并发传输：针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。<br><img src="/../img/http2%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93.png"></li><li>服务器推送：HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息</li></ul></li><li><p>缺陷：</p><ul><li>没有解决TCP层面的队头阻塞<ul><li>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</li></ul></li></ul></li></ul><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>并且使用基于UDP的QUIC协议来实现类似TCP的可靠性传输<br>QUIC有三个特点:无队头阻塞、更快的连接建立连接迁移</p><ul><li>无队头阻塞：<br>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</li></ul><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当<strong>某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</strong>，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><ul><li><p>更快的连接建立：<br>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，建立连接时需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”<br><img src="/../img/http3%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B.png"></p></li><li><p>连接迁移：</p><ul><li>对于TCP传输来说：当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。</li><li>对于QUIC协议，通过连接ID来标记通信双方，所以就算IP变了，只要仍有上下文信息，那么就可以实现无缝连接</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完全背包问题</title>
    <link href="/2023/10/15/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/15/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>什么是完全背包问题呢？<br>就是每个物品能使用n次</p></blockquote><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>与之前的01背包类似，就是在一维dp数组的倒序遍历改为了正序遍历</li><li>并且<ul><li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong></li><li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong></li><li>为什么呢？<ul><li>例如，当你对背包容量为3进行遍历，然后再内层遍历物品，此时遍历的是所有的满足条件的物品（weight[i]&lt;&#x3D;3），此时可能出现(1,2)，也可能出现(2,1)，所以是排列</li><li>如果先遍历物品，那么只可能出现(1,2)不会出现(2,1)，因为总是先遍历1，然后逐个放1，再遍历2，再逐个放2</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/10/14/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/14/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h4 id="java语言的特点有哪些？"><a href="#java语言的特点有哪些？" class="headerlink" title="java语言的特点有哪些？"></a>java语言的特点有哪些？</h4><ul><li><p>简单易学，不像C++，有那么多复杂和难以理解的特性</p></li><li><p>跨平台性，一次编译，到处运行</p><ul><li>依靠JVM，java代码编译成字节码后，可以在任何支持jvm的平台上运行</li><li>jvm起了一个翻译的作用</li></ul></li><li><p>高性能，采用了即使编译技术（just-in-Time Compilation）将字节码转换为本地机器码，提高了程序的执行效率。</p></li><li><p>安全性，提供了内存管理机制以及异常处理机制</p></li><li><p>支持多线程</p></li><li><p>有着丰富的类库，有着庞大的开源生态系统，有大量的优秀的开源框架和工具，可以提高开发效率</p></li><li><p>是一种面向对象的语言</p><ul><li>面向对象的三个重要特点：<ul><li>封装：将数据和方法封装在一个对象之中，在对象外只提供有限的接口来访问对象中的数据，隐藏了实现细节，提高了代码的安全性和可维护性</li><li>继承：通过定义一个新的类来继承已有的类的属性和方法，继承可以实现代码的重用和扩展</li><li>多态：一个对象可以看作是多个实例对象，即父引用可以指向子类的实例，然后调用父类的方法会执行具体子类的方法（如果重写了或者重载了）</li></ul></li></ul></li></ul><h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul><li><p>JVM是java虚拟机，jvm根据不同的系统有其特定的实现，所以在java代码翻译为字节码后，将字节码交给jvm，jvm再根据自己的特定实现来翻译字节码，即翻译成当前系统可以运行的版本，因此实现了跨平台，一次编译，到处运行，<strong>JVM并不止一种，只要满足JVM规范，每个人都可以开发自己的专属JVM</strong></p></li><li><p>JDK是Java develope kit，包含了JRE，以及一些开发相关工具等</p></li><li><p>JRE是Java runtime enviroment，即java运行时环境，是<strong>运行以编译的java程序的所有内容集合</strong>，主要有java虚拟机，java基础类库</p><p><img src="D:\Blog\source\img\JDK,JRE,JVM.png"></p></li></ul><h4 id="什么是字节码，采用字节码的好处是什么？"><a href="#什么是字节码，采用字节码的好处是什么？" class="headerlink" title="什么是字节码，采用字节码的好处是什么？"></a>什么是字节码，采用字节码的好处是什么？</h4><p>在java中，JVM可以理解的 代码 就叫做字节码，.class结尾</p><p>通过字节码，实现了跨平台，安全性（字节码执行前会由jvm进行验证）</p><p>性能优化：<strong>JVM在解释执行字节码的同时，还会使用即时编译器（JIT）将热点代码（被频繁执行的代码）编译成本地机器码并进行保存（类似于缓存），下次直接使用，以提高执行效率（本地机器码运行效率高于java解释器）</strong>。即时编译器能够根据平台特性进行优化，从而获得更好的性能。</p><p>所以又说<strong>java是编译和解释共存的语言</strong></p><p><img src="D:\Blog\source\img\java程序运行过程.png"></p><h4 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h4><ul><li>java不提供指针直接访问内存，更安全</li><li>java的类只能单继承</li><li>java有自动内存管理垃圾回收机制</li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>Java中有8种基本数据类型<ul><li>6种数字类型<ul><li>4种整数类型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1种字符类型<ul><li>char</li><li>妈的，原来了<code>string</code>不是基本数据类型，java中根本没有<code>string</code>这个关键词</li></ul></li><li>一种布尔类型<ul><li><code>boolean</code></li></ul></li></ul></li><li>一个字节(byte)对应八个二进制位(bit)</li><li>基本类型和包装类型的区别<ul><li><strong>用途</strong>：包装类可以定义泛型，基本数据类型则不可以</li><li><strong>存储方式</strong>：<code>基本数据类型的局部变量存放在java虚拟机栈中的局部变量表之中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java虚拟机的堆中</code>。而<strong>包装类型属于对象类型</strong>，几乎所有的实例对象都是存放在堆中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> myInt; <span class="hljs-comment">// 基本数据类型的成员变量</span><br>    String myString; <span class="hljs-comment">// 引用数据类型的成员变量</span><br>    <span class="hljs-comment">// 其他代码和方法...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>占用空间</strong>：相比于包装类型，基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：包装类型不赋值就是null，基本类型有默认值。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code>比较的是值，对于包装数据类型来说，<code>==</code>比较的是对象的内存地址，所以对于包装对象之间的<strong>值的比较</strong>，全部使用<code>equals()</code>方法。</li></ul></li></ul><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><ul><li>作用：<ul><li>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</li><li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。</li><li><strong>简单来说就是：当你生成一个包装对象时，在缓存数值范围内的，系统已经给你创建好了，你直接用就行，并不会内部重新new对象，不在缓存内的就是在内部给你new出来，此时每个的地址都不同</strong><ul><li>new 每次都是产生新的对象，不会复用缓存池对象</li><li>Integer i &#x3D; 80 等同于 Integer i &#x3D; Integer.valueOf(80)，如果数字在缓存范围内，都会复用缓存池中对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">packCache</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1，2 比较在缓存内，一个正常生成（直接使用缓存），</span><br>    <span class="hljs-comment">//一个手动new，返回false，因为一个使用的预先生产的缓存，</span><br>    <span class="hljs-comment">//一个是new</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>; <span class="hljs-comment">// 就等同于 Integer.valueOf(80)，是使用的缓存池中的对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">80</span>); <span class="hljs-comment">// new 是产生新的对象</span><br>    <span class="hljs-comment">//1，3，在缓存范围内，都正常生成，结果地址相同，</span><br>    <span class="hljs-comment">//说明都是使用的预先生成好的缓存对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-comment">//比较超出缓存范围，返回false，因为超出范围，</span><br>    <span class="hljs-comment">//都是在内部new的</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100f</span>;<br>    System.out.println(f1 == f2);<span class="hljs-comment">//false，因为Float，Double没有实现缓存机制</span><br>    System.out.println(i1 == i2);<span class="hljs-comment">//false</span><br>    System.out.println(i1 == i3);<span class="hljs-comment">//true</span><br>    System.out.println(i4 == i5);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>valueOf()源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用他们对应的引用类型包装起来；<ul><li>调用了包装类的<code>valueof()</code></li></ul></li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；<ul><li>调用了<code>xxxValue()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 </span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<span class="hljs-comment">//上下等价</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<span class="hljs-comment">//上下等价</span><br></code></pre></td></tr></table></figure></li></ul></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li><li><strong>装箱拆箱的作用</strong>：<ul><li>方便基本数据类型和对象之间的转换，如List，Map等只能存储对象，通过装箱，就能方便的将基本数据类型进行存储。</li><li>如果全用包装类型，会浪费空间</li></ul></li></ul><h4 id="浮点数精度丢失问题"><a href="#浮点数精度丢失问题" class="headerlink" title="浮点数精度丢失问题"></a>浮点数精度丢失问题</h4><ul><li>为什么会产生？<ul><li>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</li></ul></li><li>如何解决？<ul><li><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</li></ul></li></ul><h4 id="超过long类型的整形数据如何表示？"><a href="#超过long类型的整形数据如何表示？" class="headerlink" title="超过long类型的整形数据如何表示？"></a>超过long类型的整形数据如何表示？</h4><ul><li><code>BigInteger</code> 内部使用 int[] 数组来存储任意大小的整形数据。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h4><ul><li><strong>语法形式</strong>：<ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li></ul></li><li><strong>存储方式</strong>：<ul><li>如果成员变量使用<code>static</code>修饰，那么成员变量属于类，和实例一起存在堆之中</li></ul></li><li>生存时间：<ul><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li></ul></li><li>默认值：<ul><li>从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul></li></ul><h4 id="静态变量的作用？"><a href="#静态变量的作用？" class="headerlink" title="静态变量的作用？"></a>静态变量的作用？</h4><ul><li>静态变量就是被<code>static</code>修饰的变量，它可以被类的所有实例共享，无论类创建了多少个对象，它们都共享同一份静态变量。</li><li><strong>也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</strong></li></ul><h4 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h4><ul><li><strong>形式</strong>：字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong>：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。<strong>java中char占两个字节</strong></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="什么是方法的返回值-方法有哪几种类型？"><a href="#什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="什么是方法的返回值?方法有哪几种类型？"></a>什么是方法的返回值?方法有哪几种类型？</h4><ul><li>方法的返回值：<ul><li>方法的返回值 是指我们获取到的某个方法体中的代码<strong>执行后产生的结果</strong>！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</li></ul></li><li>类型：<ul><li>有参有返</li><li>无参无返</li><li>有参无返</li><li>无参有返</li></ul></li></ul><h4 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h4><ul><li>与jvm相关<ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul></li></ul><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><ul><li><strong>调用方式</strong><ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名 </code>的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 </li><li>不过不建议调用静态方法时，使用<code>对象.方法名</code>,因为静态方法是属于类，而不是实例对象，使用<code>对象.方法名</code>容易混淆</li></ul></li><li><strong>访问类成员存在限制</strong><ul><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ul></li></ul><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p></blockquote><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><ul><li><strong>重载</strong>：<ul><li>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果多个方法(比如 StringBuilder 的构造方法)有相同的名字、不同的参数， 便产生了重载。</span><br>  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><strong>重载就是同一个类之中多个同名方法根据传参的不同执行不同的处理逻辑</strong></li><li><strong>只有返回值不同的不算重载！</strong></li></ul></li><li><strong>重写</strong><ul><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</li><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li><li><strong>重写就是子类对父类的重新改造，外部样子不能变，内部逻辑可以变</strong></li></ul></li></ul><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h4 id="创建一个对象以及对象实体和对象引用有何不同"><a href="#创建一个对象以及对象实体和对象引用有何不同" class="headerlink" title="创建一个对象以及对象实体和对象引用有何不同"></a>创建一个对象以及对象实体和对象引用有何不同</h4><ul><li>创建对象<ul><li>使用<code>new</code>创建对象实例（存放在堆内存之中），对象引用指向对象实例（对象引用存放在栈内存之中）</li><li>即栈内存中的对象引用存储的是对象实例地址或者引用，并不直接存储实例对象的数据</li><li>一个对象引用可以指向0-1个对象</li><li>一个对象可以被n个对象引用所指向</li></ul></li><li>对象的相等和引用的相等<ul><li>对象的相等一般比较他们在内存中存放的内容是否相等</li><li>引用相等一般比较的是他们指向的内存地址是否相等</li></ul></li><li>对象和引用的比较<ul><li>对象是指内存中分配的一块区域，用于存储数据和方法。</li><li>引用是指用于标识或指向对象的变量或值。它类似于一个指针或标签，提供了对对象的间接访问方式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个Person对象并通过引用进行操作</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="如果一个类没有声明构造方法，还能正常执行吗？"><a href="#如果一个类没有声明构造方法，还能正常执行吗？" class="headerlink" title="如果一个类没有声明构造方法，还能正常执行吗？"></a>如果一个类没有声明构造方法，还能正常执行吗？</h4><ul><li>构造方法<ul><li>构造方法是一种特殊的方法，主要工作是完成对象的初始化工作。</li></ul></li><li>没有声明构造方法，也可以正确执行<ul><li>因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li><li>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</li><li>创建对象时的<code>()</code>就是在调用无参的构造方法</li></ul></li><li>特点：<ul><li>名字与类名一致</li><li>无返回值，也不能用void声明</li><li>生成类的对象时自动执行，无需调用（或者可以说new对象时的()就是在调用）</li><li>无法被override 重写，但是可以被overload 重载</li></ul></li></ul><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><ul><li><p>封装</p><ul><li>将数据和方法封装在一个对象之中，在对象外只提供有限的接口来访问对象中的数据，隐藏了实现细节，提高了代码的安全性和可维护性<ul><li>减少耦合</li><li>减轻维护负担，更容易理解</li></ul></li></ul></li><li><p>继承（extends）</p><ul><li>使用已存在的类的定义作为基础建立新类的技术</li><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>提高了代码的复用性和扩展性</li></ul></li><li><p>多态</p><ul><li>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例，即父类可以是子类</li><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但在父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 定义一个父类 Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The animal makes a sound.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义两个子类 Dog 和 Cat 继承自 Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建 Animal 类型的引用指向不同的子类对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>        <span class="hljs-comment">// 调用 makeSound 方法，根据实际对象类型，会执行相应的子类方法</span><br>        animal1.makeSound();  <span class="hljs-comment">// 输出: The dog barks.</span><br>        animal2.makeSound();  <span class="hljs-comment">// 输出: The cat meows.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h4><ul><li>相同点<ul><li>都不能被实例化</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ul></li><li>区别<ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public</code> <code>static</code> <code>final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类 Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String name;<br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; is sleeping.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 接口 Swimmable</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体类 Dog 继承自 Animal，并实现 Swimmable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog is swimming.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.name = <span class="hljs-string">&quot;Bobby&quot;</span>;<br>        dog.makeSound();  <span class="hljs-comment">// 输出: The dog barks.</span><br>        dog.sleep();      <span class="hljs-comment">// 输出: Bobby is sleeping.</span><br>        dog.swim();       <span class="hljs-comment">// 输出: The dog is swimming.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="浅拷贝和深拷贝区别？什么是引用拷贝？"><a href="#浅拷贝和深拷贝区别？什么是引用拷贝？" class="headerlink" title="浅拷贝和深拷贝区别？什么是引用拷贝？"></a>浅拷贝和深拷贝区别？什么是引用拷贝？</h4><ul><li>深浅拷贝的区别<ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。<br><img src="/../img/%E6%B7%B1%E6%B5%85%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB.png"></li></ul></li></ul><h4 id="值传递问题"><a href="#值传递问题" class="headerlink" title="值传递问题"></a>值传递问题</h4><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。即传入方法的是一个地址。</p><p>如在方法中传入一个dog对象</p><p>在方法中将dog对象指向新的不同dog对象，原dog对象不会变</p><ul><li>因为是传入函数内了，此时是一个局部变量，在函数里面确实指向变了，但是出了函数就复原了</li></ul><p>将方法中将dog对象进行属性修改，那么原dog对象的属性会变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">s    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(Dog dog)</span>&#123;<br>        dog.age = <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(Dog dog)</span>&#123;<br>        dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">100</span>);<br>        System.out.println(dog1);<span class="hljs-comment">// $Dog@1e643faf</span><br>        System.out.println(dog1.age);<span class="hljs-comment">// 100</span><br>        func2(dog1);<br>        System.out.println(dog1); <span class="hljs-comment">// $Dog@1e643faf</span><br>        System.out.println(dog1.age); <span class="hljs-comment">// 100</span><br>        func1(dog1);<br>        System.out.println(dog1);<span class="hljs-comment">// $Dog@1e643faf</span><br>        System.out.println(dog1.age); <span class="hljs-comment">// 10</span><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul><li><strong>public</strong>：类成员和构造函数在任何地方都可以被访问。即公共访问级别，没有访问限制。</li><li><strong>protected</strong>：<ul><li>使用protected修饰的类成员和构造函数可以在<strong>同一个包内的其他类中访问。</strong></li><li><strong>以及在不同包的子类中访问。</strong></li><li>对于不同包中的非子类，访问受限制。</li></ul></li><li><strong>private</strong>：使用private修饰的类成员和构造函数只能在同一个类中访问，对于其他类（包括同一个包中的类和子类）都是不可见的。</li><li><strong>默认</strong>：<ul><li>如果没有使用任何访问修饰符，默认访问修饰符将被应用。</li><li>使用默认修饰符修饰的类、类成员和构造函数可以在同一个包内被访问，但对于不同包中的类是不可见的。</li><li>不应该叫default<ul><li>因为default是一种在接口中提供默认方法实现的修饰符</li></ul></li></ul></li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h4 id="Object类的常见方法"><a href="#Object类的常见方法" class="headerlink" title="Object类的常见方法"></a>Object类的常见方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h4><ul><li>对于基本数据类型：<ul><li><code>==</code>比较的是值</li><li>无法使用<code>equals()</code>,<code>equals()</code>方法存在于<code>Object</code>类中</li></ul></li><li>对于引用类型：<ul><li><code>==</code>比较的是对象的内存地址</li></ul></li><li><code>equals()</code><ul><li><strong>类没有重写 equals()方法：</strong>通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object类equals()方法。</li><li><strong>类重写了 equals()方法：</strong>一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li><li>例如String中的<code>equals()</code>就被重写，使equals()从比较地址，变为比较对象的值</li></ul></li></ul><h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h4><ul><li>hashCode() 是 Java 中的一个方法，它用于计算对象的哈希（hash code）。哈希码是一个整数值，通常用于快速确定对象在哈希表等数据结构中的存储位置</li><li>所以hashCode()也能进行比较，但是为什么还需要equals()呢？<ul><li>因为可能有哈希碰撞</li><li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li></ul></li><li>为什么重写 equals() 时必须重写 hashCode() 方法？<ul><li>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</li></ul></li><li>因为hashCode()在查找定位有特殊的作用，所以需要，而hashCode()又不能完全代替equals()所以，也需要equals()</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h4 id="使用new-和-字符串常量创建String类的区别"><a href="#使用new-和-字符串常量创建String类的区别" class="headerlink" title="使用new 和 字符串常量创建String类的区别"></a>使用new 和 字符串常量创建String类的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>在内存中的存储：<ul><li><code>String str1 = new String(&quot;abc&quot;);</code>：<ul><li>使用 <code>new</code> 关键字创建了一个新的字符串对象，即使字符串常量池中已经存在 “abc”，也会在堆内存中创建一个新的字符串对象，因为使用 <code>new</code> 强制要求创建新对象。</li></ul></li><li><code>String str2 = &quot;abc&quot;;</code>：<ul><li>直接将字符串常量 “abc” 存储在字符串常量池中。如果字符串常量池中已经存在相同内容的字符串，它会被重用，不会创建新的对象。</li></ul></li></ul></li><li>引用：<ul><li><code>String str1 = new String(&quot;abc&quot;);</code> 中的 <code>str1</code> 引用指向在堆内存中创建的新字符串对象。</li><li><code>String str2 = &quot;abc&quot;;</code> 中的 <code>str2</code> 引用指向字符串常量池中的 “abc” 对象。</li></ul></li><li>比较：<ul><li><code>str1</code> 和 <code>str2</code> 是两个不同的字符串对象，它们的引用不相等，即 <code>str1 != str2</code>。</li><li>但是，由于字符串常量池的存在，它们的内容是相同的，即 <code>str1.equals(str2)</code> 会返回 <code>true</code>。</li></ul></li></ul><h4 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h4><ul><li><p><code>String</code>是不可变化的</p></li><li><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，并且有一些方法</p></li><li><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p></li><li><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p></li><li><p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的,性能比<code>StringBuffer</code>高10%- 15%</p></li><li><p><strong>使用</strong></p><ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul></li></ul><h4 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变</li></ul><p><strong>不可变的好处？</strong></p><ul><li>缓存hash值<ul><li>String类型的hash值经常被使用，如果String不可变，那么他的hash值也不可变，因此String只需要在第一次计算hash值，然后缓存起来，以后就可以一直重复使用</li></ul></li><li>安全性<ul><li>多线程安全</li></ul></li><li>字符串常量池的需要<ul><li>“String Pool”（字符串池）是指一个保存着字符串对象的缓存区域，用于避免创建相同内容的字符串对象的重复内存分配。</li><li>如果String可以改变，那么字符串池中的字符也可能受到改变，其他指向该字符的String就会受到影响，可能会出问题</li></ul></li></ul><h4 id="字符串的拼接-“-”-StringBuilder"><a href="#字符串的拼接-“-”-StringBuilder" class="headerlink" title="字符串的拼接 “+” &#x2F; StringBuilder"></a>字符串的拼接 “+” &#x2F; StringBuilder</h4><ul><li>字符串对象通过 “+” 的字符串拼接实际上是通过 <code>StringBuilder</code>调用<code>append()</code>方法实现的</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><ul><li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</li><li>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？<ul><li>会创建1或者2个对象</li><li>当常量池中没有”abc”的引用时，那么会先在字符串常量池创建”abc”，然后再在堆空间创建。</li><li>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”</li></ul></li></ul><h4 id="String-intern"><a href="#String-intern" class="headerlink" title="String intern()"></a>String intern()</h4><ul><li>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul></li></ul><h4 id="String-类和常量做-“-”-运算"><a href="#String-类和常量做-“-”-运算" class="headerlink" title="String 类和常量做 “+” 运算"></a>String 类和常量做 “+” 运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为是常量字符串，jvm会在编译阶段就将其放入字符串常量池（str1，str2，str3）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-comment">//常量折叠：</span><br><span class="hljs-comment">//String str3 = &quot;str&quot; + &quot;ing&quot;; </span><br><span class="hljs-comment">//因为是常量编译器会给你优化成 String str3 = &quot;string&quot;;</span><br><span class="hljs-comment">//String str4 = new StringBuilder().append(str1).append(str2).toString(); 对于对象引用 + 的拼接其实是通过StringBuilder调用append()然后再调用toString()产生了一个新的String对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-comment">//str3是一个新对象，由StringBuilder产生</span><br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="异常-浅层"><a href="#异常-浅层" class="headerlink" title="异常(浅层)"></a>异常(浅层)</h2><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code> 块：用于处理 <code>try</code> 捕获到的异常。</li><li><code>finally</code> <code>块：无论是否捕获或处理异常，finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> <code>语句时，finally</code> 语句块将在方法返回之前被执行。<br>-<strong>不要在 finally 语句块中使用 return!</strong>  当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="什么是泛型，作用是什么？"><a href="#什么是泛型，作用是什么？" class="headerlink" title="什么是泛型，作用是什么？"></a>什么是泛型，作用是什么？</h4><ul><li><p>泛型允许我们在类或方法的定义中使用类型参数，以便在使用时指定具体的类型。</p></li><li><p>使用泛型参数，可以增强代码的可读性以及稳定性。</p></li><li><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。</p></li></ul><h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><ul><li><p>在Java中，泛型的类型信息<strong>在编译时会被擦除掉</strong>，转换为原始类型。这是为了保持与旧版本Java的兼容性（让泛型代码在不支持泛型的老版本环境中正常运行），并且在运行时<strong>没有泛型类型的开销</strong>。</p></li><li><p>为什么需要？</p><ul><li>向后兼容</li><li>减少虚拟机复杂性，使虚拟机可以新老版本（有无泛型）都正常运行，无需额外修改</li></ul></li><li><p><strong>过程</strong>：</p><ul><li><strong>类型参数擦除</strong>：泛型类、接口或方法中的类型参数会被擦除为它们的上限或默认类型。例如，<code>List&lt;T&gt;</code> 中的 <code>T</code> 会被擦除为 <code>Object</code> 类型。</li><li><strong>替换类型变量</strong>：在泛型类或接口中，类型变量会被替换为它们的上限类型或默认类型。例如，<code>List&lt;T extends Number&gt;</code> 中的 <code>T</code> 会被替换为 <code>Number</code>。</li><li><strong>插入类型转换</strong>：在需要确保类型安全的地方，编译器会自动生成插入类型转换的代码，以保证正确的类型操作。这是为了在擦除类型后恢复类型安全性。</li></ul></li></ul><h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><ul><li>反射是一种在运行时获取、检查和操作类、对象、方法和属性等信息的能力。</li><li>反射机制允许程序在运行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性以及方法</li></ul><h3 id="反射的内部原理"><a href="#反射的内部原理" class="headerlink" title="反射的内部原理"></a>反射的内部原理</h3><ul><li>加载完类后，堆内存的方法区中就会产生一个Class类型的对象（一个Class实例），这个对象会包含完整的类信息，我们可以通过这个Class实例来获取类的信息。<ul><li>例如我有一个Person类，Person类加载完成后，堆内存方法区会产生一个Class的实例，不妨就叫personClass，personClass包含了原来Person的所有类信息</li></ul></li></ul><h3 id="Class的理解"><a href="#Class的理解" class="headerlink" title="Class的理解"></a>Class的理解</h3><ul><li><p>Class是一个类的类，所有的类都可以看作是Class类的一个实例来理解<br><img src="/../img/Class%E7%BB%93%E6%9E%84.png"></p><ul><li>Class本身也是类</li><li>Class对象只能由系统建立</li><li>一个加载的类在JVM之中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，想要对某类进行反射的相关操作，必须先获取其相应的Class对象<br><img src="/../img/Class%E4%B8%8E%E7%B1%BB%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE.png"></li></ul></li><li><p><strong>获取Class类的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据类型获取</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> String.class;<br><br><span class="hljs-comment">//根据运行时的类获取（实例）</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>.getClass();<br><br><span class="hljs-comment">//根据全类名获取</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><br><span class="hljs-comment">//根据类加载器获取</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz4</span> <span class="hljs-operator">=</span> cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>哪些类型可以有Class对象</p><ul><li>基本所有类</li><li>只要元素类型与维度一样，就是一个Class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">Class</span> <span class="hljs-variable">c10</span> <span class="hljs-operator">=</span> a.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c11</span> <span class="hljs-operator">=</span> b.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c12</span> <span class="hljs-operator">=</span> c.getClass();<br><span class="hljs-comment">// 只要元素类型与维度一样，就是同一个 Class</span><br>System.out.println(c10 == c11); <span class="hljs-comment">//true</span><br>System.out.printlin(c10 == c12); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="反射实现的功能"><a href="#反射实现的功能" class="headerlink" title="反射实现的功能"></a>反射实现的功能</h3><h3 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h3><ul><li>相关API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.实现的全部接口</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt;[] getInterfaces() <br><span class="hljs-comment">//确定此对象所表示的类或接口实现的接口。</span><br><span class="hljs-comment">//2.所继承的父类</span><br><span class="hljs-keyword">public</span> Class&lt;? Super T&gt; getSuperclass()<br><span class="hljs-comment">//返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</span><br><span class="hljs-comment">//3.全部的构造器</span><br><span class="hljs-keyword">public</span> Constructor&lt;T&gt;[] getConstructors()<br><span class="hljs-comment">//返回此 Class 对象所表示的类的所有 public 构造方法。</span><br><span class="hljs-keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()<br><span class="hljs-comment">//返回此 Class 对象表示的类声明的所有构造方法。</span><br><span class="hljs-comment">//Constructor 类中：</span><br><span class="hljs-comment">//取得修饰符: </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//取得方法名称: </span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//取得参数的类型：</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt;[] getParameterTypes();<br><span class="hljs-comment">//4.全部的方法</span><br><span class="hljs-keyword">public</span> Method[] getDeclaredMethods()<br><span class="hljs-comment">//返回此 Class 对象所表示的类或接口的全部方法</span><br><span class="hljs-keyword">public</span> Method[] getMethods() <br><span class="hljs-comment">//返回此 Class 对象所表示的类或接口的 public 的方法</span><br><span class="hljs-comment">//Method 类中：</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getReturnType()<br><span class="hljs-comment">//取得全部的返回值</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt;[] getParameterTypes()<br><span class="hljs-comment">//取得全部的参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span><br><span class="hljs-comment">//取得修饰符</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()<br><span class="hljs-comment">//取得异常信息</span><br><span class="hljs-comment">//5.全部的 Field</span><br><span class="hljs-keyword">public</span> Field[] getFields()<br><span class="hljs-comment">//返回此 Class 对象所表示的类或接口的 public 的 Field。</span><br><span class="hljs-keyword">public</span> Field[] getDeclaredFields()<br><span class="hljs-comment">//返回此 Class 对象所表示的类或接口的全部 Field。</span><br><span class="hljs-comment">//Field 方法中：</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span><br><span class="hljs-comment">//以整数形式返回此 Field 的修饰符</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getType() <br><span class="hljs-comment">//得到 Field 的属性类型</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//返回 Field 的名称。</span><br><span class="hljs-comment">//6. Annotation 相关</span><br>get <span class="hljs-title function_">Annotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span><br>getDeclaredAnnotations()<br><span class="hljs-comment">//7.泛型相关</span><br><span class="hljs-comment">//获取父类泛型类型：</span><br>Type <span class="hljs-title function_">getGenericSuperclass</span><span class="hljs-params">()</span><br><span class="hljs-comment">//泛型类型：ParameterizedType</span><br><span class="hljs-comment">//获取实际的泛型类型参数数组：</span><br>getActualTypeArguments()<br><span class="hljs-comment">//8.类所在的包</span><br>Package <span class="hljs-title function_">getPackage</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure></li><li>动态性案例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br> <span class="hljs-comment">//体会反射的动态性：动态的创建指定字符串对应类的对象，并调用指定的方法</span><br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(String className,String methodName)</span> <span class="hljs-keyword">throws</span><br>Exception &#123;<br>  <span class="hljs-comment">//根据全类名获取Class对象</span><br> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br> <span class="hljs-comment">//获取构造器</span><br> <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br> <span class="hljs-comment">//setAccessible ：让其可被访问</span><br> constructor.setAccessible(<span class="hljs-literal">true</span>);<br> <span class="hljs-comment">//动态的创建指定字符串对应类的对象</span><br> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance();<br> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(methodName);<br> method.setAccessible(<span class="hljs-literal">true</span>);<br> <span class="hljs-keyword">return</span> method.invoke(obj);<br> &#125;<br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> (String) invoke(<span class="hljs-string">&quot;com.atguigu.java1.Person&quot;</span>, <span class="hljs-string">&quot;sh</span><br><span class="hljs-string">ow&quot;</span>);<br> System.out.println(<span class="hljs-string">&quot;返回值为：&quot;</span> + info);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>流的方向<ul><li>输入流(Input)</li><li>输出流(Output)</li></ul></li><li>流的内容<ul><li>字节流(Stream)</li><li>字符流(Read,Write)</li></ul></li><li>流的作用<ul><li>节点流<ul><li>进行数据传输的，从一个节点到另一个节点的流</li><li>可以从或向一个特定的地方（节点）读写数据</li></ul></li><li>处理流<ul><li>进行流的处理的流</li></ul></li></ul></li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>  InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>read()：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。</li><li>read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。</li><li>read(byte b[], int off, int len)：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。</li><li>close()：关闭输入流释放相关的系统资源。</li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>作用：实现更加简洁，紧凑的代码风格，可用于创建函数式接口的实例。<ul><li>函数式接口：只包含一个抽象方法的接口</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无参的Lambda表达式</span><br>() -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">//多参的Lambda表达式</span><br>(x,y) -&gt; x + y;<br></code></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream是数据渠道，用于操作数据源（集合，数组）所生成的元素序列。</p><ul><li>与Collection的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong></li></ul><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul><li>Stream 自己不会存储元素</li><li>Stream 不会修改源对象，相反，他们会返回一个持有结果的新Stream</li><li>Stream 操作是延迟执行的，只有在需要结果的时候才执行，即执行终止操作时，再执行中间操作，并产生结果。</li><li>Stream 一旦执行了终止操作，就不能再调用其它中间操作或者终止操作了</li></ul><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><pre><code class="java">// 创建流Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5);//中间操作stream.filter(number -&gt; &#123;  number &gt; 3  //终止操作&#125;).forEach(number -&gt; &#123;  System.out.println(number)&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/14/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%86%8D%E5%A4%8D%E7%9B%98/"/>
    <url>/2023/10/14/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%86%8D%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="/2023/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2023/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><ul><li>进程间基于网络通信（<strong>运输层作用</strong>）<ul><li>物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了<strong>主机到主机的通信</strong>。</li><li>然而在计算机网络中<strong>实际进行通信的真正实体，是位于通信两端主机中的进程</strong>。</li><li>如何为<strong>运行在不同主机上的应用进程</strong>提供直接的逻辑通信服务，就是运输层的主要任务。运输层协议又称为端到端协议。</li><li>运输层向应用层实体<strong>屏蔽了下面网络核心的细节</strong>（例如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条<strong>端到端的逻辑通信信道</strong>。<br><img src="/../img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png"></li></ul></li><li>运输层端口号<ul><li>运行在计算机上的进程是使用进程标识符（Process Identification，PID）来标识的（每个PCB（进程控制块）由其唯一的PID标识）<ul><li>因特网也有其类似的实现，使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识</li></ul></li><li>TCP&#x2F;IP体系结构的运输层使用<strong>端口号</strong>来标识和区分应用层的不同应用进程。端口号的长度为16比特，取值范围是0~65535。<br><img src="/../img/%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D.png"></li><li>端口号应用举例<ul><li>用户端根据域名向DNS服务器发起请求（通过标识自己的端口号，以及目标端口号），申请获取该域名的IP地址<ul><li>DNS服务器：存储了域名和对应IP，类似于一个电话簿</li></ul></li><li>DNS返回IP地址</li><li>用户端根据IP地址发起请求访问Web服务器</li><li>Web服务器根据请求，返回内容</li><li>**上述交流信息的TCP首部均包含了”源端口”以及”目的端口”的信息</li></ul></li></ul></li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP基本概览"><a href="#TCP基本概览" class="headerlink" title="TCP基本概览"></a>TCP基本概览</h4><ul><li>什么是 TCP ？<ul><li>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。<ul><li><strong>面向连接：</strong>一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的：</strong>无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流传输：</strong>用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文</li></ul></li></ul></li></ul><h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><p>  <img src="/../img/tcp%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><h4 id="三报文握手-建立TCP连接"><a href="#三报文握手-建立TCP连接" class="headerlink" title="三报文握手 建立TCP连接"></a>三报文握手 建立TCP连接</h4><ul><li>“三报文握手”建立TCP连接的目的<ul><li>使TCP双方能够确知对方的存在。</li><li>使TCP双方能够协商一些参数（例如最大报文段长度、最大窗口大小、时间戳选项等）。</li><li>使TCP双方能够对运输实体资源进行分配和初始化。运输实体资源包括缓存大小、各状态变量、连接表中的项目等。</li></ul></li><li>流程<br>  <img src="/../img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></li><li>为何不能省去第三次<ul><li>避免资源的浪费<ul><li>当客户端的一个请求阻塞时，会重新发送请求，然后和服务端建立连接。</li><li>再传输数据后，会关闭连接</li><li>此时之前阻塞的请求又发送到了服务端，因为服务端是被动打开的，所以服务端根据请求会发送确认报文。</li><li>但是此时的客户端已经关闭，而且无法被服务端给唤醒，所以不会理财服务端的请求</li><li>此时服务端会一直开启并且等待客户端响应，浪费了资源<br><img src="/../img/%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></li></ul></li></ul></li><li>第一次握手丢失：<ul><li>第一次握手（告诉服务端，我想和你进行连接）</li><li>如果丢失，客户端发送后未得到服务端的确认请求，那么会进行超时重传，达到一定次数后，会等待一定时间，如果还是没有收到确认（第二次握手）那么会断开连接（主动方：客户端）</li></ul></li><li>第二次握手丢失：<ul><li>第二次握手（服务端发送确认通知）</li><li>此时客户端等待服务端的确认（第二次握手），服务端等待客户端的确认（第三次握手）</li><li>客户端没有得到第二次握手，会进行超时重传（上限一次），然后等待一段时间，如果没有收到，客户端断开连接</li><li>服务端没有收到第三次握手也会进行超时重传（上限两次），然后再等待一段时间，如果还是没有收到，那么服务端会断开连接</li></ul></li><li>第三次握手丢失：<ul><li>第三次握手（客户端接收到服务端的确认通知之后，会向其返回第三次握手，此时，客户端进入ESTABLISHED状态）</li><li>服务端发起确认（第二次握手）后会进行重传（上限两次），达到上限会进行一段时间等待，如果还是没有收到第三次握手，服务端断开连接。</li></ul></li></ul><h4 id="四报文挥手-释放TCP连接"><a href="#四报文挥手-释放TCP连接" class="headerlink" title="四报文挥手 释放TCP连接"></a>四报文挥手 释放TCP连接</h4><p><img src="/../img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ul><li>小问题<ul><li>不进行时间等待会怎么样？<ul><li>如果不进行时间等待，在客户端发送确认报文并加入关闭阶段时，服务端无法收到，因此无法关闭，而此时客户端已经关闭，无法进行超时重传<br><img src="/../img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85%E4%BD%9C%E7%94%A8.png"></li></ul></li></ul></li><li>第一次挥手丢失：<ul><li>第一次挥手（客户端让自己与服务端断开，并且自己不再传输数据给服务端）</li><li>如果丢失的话，客户端无法收到服务端发来的确认报文，这会触发客户端的重传机制</li><li>如果重传到了一定次数，那么会直接关闭连接</li></ul></li><li>第二次挥手丢失：<ul><li>第二次挥手（就是服务端对客户端的关闭请求的确认）</li><li>如果丢失，客户端无法收到确认报文，那么会触发客户端的超时重传机制</li><li>如果客户端重传到了一定次数还没有收到第二次挥手（确认），则会直接关闭连接</li></ul></li><li>第三次挥手丢失：<ul><li>第二次挥手之后，服务端可能还会有数据需要传输，所以会进入关闭等待状态。当服务端的数据传输完毕，就会进行第三次挥手，对服务端进行关闭。</li><li>服务端发起第三次挥手，但是没有收到确认之后，会进行超时重传</li><li>当重传达到一定的次数之后，再进行最后的一段时间的等待，还未收到确认，那么就会直接关闭。</li></ul></li><li>第四次挥手丢失：<ul><li>第四次挥手（确认收到服务端的关闭请求，并返回确认）</li><li>如果第四次挥手丢失，那么服务端会进行第三次挥手的超时重传，达到一定次数后，再等待一定时间后，如果还是没有收到确认，那么会直接关闭</li></ul></li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li>流量控制的基本概念<br><img src="/../img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"><ul><li>因为服务端应用程序可能正忙于其他任务，并不一定能够立刻取走数据。如果不根据此时服务接收方的接收缓存情况来进行流量控制的话，会造成数据的溢出丢失</li></ul></li><li>流量控制的方法<ul><li>首先在建立tcp连接时，接收方会告诉发送方：我的接收窗口大小为400，此时，发送方会将自己的发送窗口大小也设为400</li><li>发送方解析接收方的响应数据包，根据接收方的接收窗口大小调整自己的发送窗口大小</li><li>发送方通过向前滑动发送窗口的方式移除已确认被正确接收的数据，并将他们从缓冲区删除</li><li>发送方只发送自己发送窗口内的数据</li><li>发送窗口向前滑动的前提是发送窗口的数据确认被正确接收</li></ul></li><li>问题<ul><li>如果接收窗口为0，那么此时发送窗口也会相应变为0，此时该如何破解这个局面呢？<ul><li>当发送方的发送窗口变为0后，会启动一个持续计时器， 当计时结束，发送方会主动发送一个零窗口探测报文，接收方必须接收该报文</li></ul></li><li>如果零窗口探测报文丢失呢？<ul><li>零窗口探测报文段也有设置的有重传计时器，如果丢失，等待该计时器超时，然后重传零窗口探测报文段</li></ul></li><li>为什么接收方接收窗口为0时还能接收零窗口探测报文<ul><li>TCP规定，就算接收窗口为0，也必须接受零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段</li></ul></li></ul></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li>拥塞控制的基本概念<ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞（congestion）。</li></ul></li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。<br><img src="/../img/%E6%8B%A5%E5%A1%9E%E5%90%9E%E5%90%90%E9%87%8F.png"></li><li>流量控制与拥塞控制的区别<ul><li>流量控制是服务器可能正忙于其他任务，当接收缓存满了之后并一定能及时的取走数据，导致新来的数据会被丢弃</li><li>拥塞控制是指防止过多的数据注入到网络之中，使网络能够承受现有的网络负荷</li></ul></li><li>方法概念<ul><li>为了防止cwnd（发送方的拥塞窗口，决定了发送窗口）增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意。</li></ul></li><li>如何确定网络拥塞？<ul><li>其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理</li></ul></li></ul></li><li>拥塞控制的四种方法<ul><li>慢开始<ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加倍</li></ul></li><li>拥塞避免<ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</li></ul></li><li>快重传<ul><li>快重传就是要求接收方在收到一个失序的报文段后就立即发出重复确认，而不是等到主机发送数据时捎带确认。</li><li>快重传规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li></ul></li><li>快恢复<ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="/../img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"></li></ul></li></ul></li></ul><h4 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h4><ul><li>以字节为单位的滑动窗口</li><li>超时重传（超时时间主要为加权平均往返时间）</li><li>选择确认</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ul><li>连接<ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul></li><li>服务对象<ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul></li><li>可靠性<ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul></li><li>拥塞控制，流量控制<ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li><li>首部开销<ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li><li>传输方式<ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul></li><li>应用场景<ul><li>TCP<ul><li>FTP 文件传输</li><li>HTTP &#x2F; HTTPS</li></ul></li><li>UDP<ul><li>包总量较少的通信</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2023/10/13/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/13/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>什么是01背包问题呢？<br>就是每个物品最多只能使用1次，故为01</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>动规五部曲<ul><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例实验</li></ul></li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>二维实现<ul><li>二维dp数组:dp[i][j]，其中i代表 0-i的物品中选取，j代表此时的最大容量，dp[i][j]则代表此情况下包的最大价值</li><li>递推公式：要是能放下，则<br> <code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i])</code><br> 放不下则<code>dp[i][j] = dp[i-1][j]</code></li><li>初始化：画二维表来理解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; i &lt;= target; i++)&#123;<br><span class="hljs-comment">//从背包此时最大尺寸大于等于第一个背包的重量起，</span><br><span class="hljs-comment">//依次向后填充，填充到背包空间最大的情况</span><br>dp[<span class="hljs-number">0</span>][i] = nums[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li><li>遍历顺序无所谓，因为每次的取值都来自于左上方</li></ul></li><li>一维实现<ul><li>一维数组省去了i,直接就是dp[j]，j仍然代表此时最大容量</li><li>递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></li><li>初始化：如果物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了，便于后续取最大值进行覆盖</li><li><strong>遍历顺序</strong>：必须逆序，不然会出现物品多次使用的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br><span class="hljs-comment">//此情况不放物品就是dp[j]，放了就是 dp[j - weight[i]] + value[i]</span><br><span class="hljs-comment">//就是之前二维数组不放物品的拷贝：之前二维数组不放物品的为dp[i-1][j]</span><br>    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>分割等和子集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-comment">// 背包的体积为sum / 2</span><br><span class="hljs-comment">// 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</span><br><span class="hljs-comment">// 背包如果正好装满，说明找到了总和为 sum / 2 的子集。</span><br><span class="hljs-comment">// 背包中每一个元素是不可重复放入。</span><br><span class="hljs-comment">// 为什么可以用背包问题来判断呢？背包问题不是求包里能放的最大价值吗？</span><br><span class="hljs-comment">// 因为此题的物品价值 == 物品重量，所以无论你怎么放，放到最好的情况就是物品价值为sum/2，如果有这个情况那么true，否则false</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//sum/2有小数，不可能由整数构成</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][target+<span class="hljs-number">1</span>]; <span class="hljs-comment">//i代表从0-i号物品中取，j代表此时最大剩余量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; i &lt;= target; i++)&#123;<br>            <span class="hljs-comment">//从背包此时最大尺寸大于等于第一个背包的重量起，依次向后填充，填充到背包空间最大的情况</span><br>            dp[<span class="hljs-number">0</span>][i] = nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i])&#123;<span class="hljs-comment">//能放下</span><br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-nums[i]] + nums[i]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i][target] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最后一块石头的重量Ⅱ</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-comment">//转换为动态规划</span><br>        <span class="hljs-comment">//理解题意，关键在于一堆重量为a的石头和一堆重量为b的石头碰撞后会剩下|a-b|的石头</span><br>        <span class="hljs-comment">//所以此时转换为01背包问题，将给定的石头分为两堆最接近的大小即可</span><br>        <span class="hljs-comment">//即给定一个承重sum/2的背包，最大的放置重量为多少</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stone:stones)&#123;<br>            sum += stone;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stones[i]; j--)&#123;<br>                <span class="hljs-comment">//此时是stones[i]</span><br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM类加载</title>
    <link href="/2023/10/12/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/10/12/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="类字节码"><a href="#类字节码" class="headerlink" title="类字节码"></a>类字节码</h3><h4 id="多语言编译为字节码在JVM运行"><a href="#多语言编译为字节码在JVM运行" class="headerlink" title="多语言编译为字节码在JVM运行"></a>多语言编译为字节码在JVM运行</h4><ul><li>为什么需要字节码：<ul><li>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。</li></ul></li><li>为什么jvm不能直接运行java代码：<ul><li>这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的</li><li>所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。<br><img src="/../img/java%E5%9C%A8jvm%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></li></ul></li></ul><h4 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h4><ul><li>编译后形成的class到底是个啥<ul><li>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。</li><li>jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</li></ul></li><li>Class文件结构属性<br>  <img src="/../img/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%B1%9E%E6%80%A7.png"></li></ul><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><blockquote><p>类的生命周期包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段<br><img src="/../img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p></blockquote><ul><li><strong>加载: 查找并加载类的二进制数据</strong><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。<blockquote><p>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></blockquote></li><li>加载方式<ul><li>本地系统直接加载</li><li>网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul></li><li><strong>验证: 确保被加载的类的正确性</strong><ul><li>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:<ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，如是否以<code>0xCAFEBABE</code>开头<ul><li>字节码文件魔数0xCAFEBABE，每一个java字节码文件(.class)都是以相同的4字节内容开始的——十六进制的CAFEBABE，用来判断是否是java字节码文件（文件名后缀+魔数等）</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求，例如: 这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行</li></ul></li></ul></li><li><strong>准备: 为类的静态变量分配内存，并将其初始化为默认值</strong><ul><li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong><ul><li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。</li></ul></li></ul></li><li><strong>解析: 把类中的符号引用转换为直接引用</strong><ul><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</li><li>符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul></li><li><strong>初始化：为类的静态变量赋予正确的初始值</strong><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li><li><strong>初始化步骤</strong><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li><strong>类初始化时间</strong><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul></li></ul></li><li><strong>使用</strong><ul><li>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</li></ul></li><li><strong>卸载</strong><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul></li></ul><h4 id="类加载器、JVM类加载机制"><a href="#类加载器、JVM类加载机制" class="headerlink" title="类加载器、JVM类加载机制"></a>类加载器、JVM类加载机制</h4><ul><li><p>类加载器的层次<br><img src="/../img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1.png"> </p></li><li><p>启动类加载器（Bootstrap ClassLoader）：</p><ul><li>负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><p>扩展类加载器（Extension ClassLoader）：</p><ul><li>该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li></ul></li><li><p>应用程序类加载器（Application ClassLoader）：</p><ul><li>该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><p>类的加载</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>JVM类加载机制</p><ul><li><code>全盘负责</code><ul><li>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul></li><li><code>父类委托</code><ul><li>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li></ul></li><li><code>缓存机制</code><ul><li>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</li><li><strong>这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</strong></li></ul></li><li><code>双亲委派机制</code><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上</li><li>因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul></li><li><strong>双亲委派优势</strong><ul><li>系统类防止内存中出现多份同样的字节码，即<strong>避免重复加载</strong></li><li>保证Java程序安全稳定运行，即<strong>避免篡改核心类</strong></li><li>例如，有一个你写了一个Object类，放在ClassPath下去给应用程序加载器加载，此时应用程序加载器会让一层一层往上传递信息，如果父类有Object类，则会加载父类的Object，而不会加载子类的。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring回顾</title>
    <link href="/2023/10/11/Spring%E5%9B%9E%E9%A1%BE/"/>
    <url>/2023/10/11/Spring%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<hr><ul><li>Bean的作用域<ul><li>单例模式<ul><li>只能有一个实例</li></ul></li><li>原型模式<ul><li>能有多个实例，可用来代替new</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾收集与内存分配</title>
    <link href="/2023/10/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2023/10/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><ul><li>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</li><li>垃圾收集主要针对<strong>堆和方法区</strong>进行，程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，只存在于线程的生命周期内，线程结束后就会消失，因此不需要进行垃圾回收</li></ul><h4 id="如何判断可以进行垃圾回收"><a href="#如何判断可以进行垃圾回收" class="headerlink" title="如何判断可以进行垃圾回收"></a>如何判断可以进行垃圾回收</h4><ul><li>引用计数算法 <ul><li>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。<ul><li>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；</li><li>当引用失效时，引用计数器就减 1；</li><li>当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</li></ul></li><li>优点：<ul><li>回收没有延迟性，无需等到内存不够时才开始回收</li></ul></li><li>缺点：<ul><li>每次对象被引用时，都需要更新计数器，有时间开销</li><li>浪费cpu资源，内存够用时，计数器统计仍在进行</li><li><strong>无法解决循环引用问题，会引发内存泄漏</strong>（即互相引用的对象永远也无法被回收）</li></ul></li></ul></li><li>可达性分析算法<ul><li>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</li><li>GC Roots 对象：<ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li><li>GC Roots <strong>是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</li></ul></li><li>工作原理：<ul><li>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象<ul><li>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li></ul></li></ul></li></ul></li><li>finalization<ul><li>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</li><li>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</li><li><strong>finalize()只能被调用一次</strong></li></ul></li><li>引用分析<ul><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致内存泄漏<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//使用 new 一个新对象的方式来创建强引用</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>配合引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li></ul></li><li><p>弱引用：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li></ul></li><li><p>虚引用：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，监测对象是否存活</li></ul></li><li><p>终结器引用（finalization）</p></li><li><p>引用队列作用：</p></li></ul></li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ol><li>标记-清除法<ul><li>先标记，再清除 </li><li><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></li><li><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li><li>缺点：<ul><li>因为没有整理，所以会产生不连续的内存碎片</li></ul></li></ul></li><li>标记-整理法<ul><li>与标记-清除法一样，不过清除之后将存活对象都移动到了内存的一端，解决了内存碎片问题</li><li>缺点：<ul><li>需要遍历移动对象，处理效率低</li></ul></li></ul></li><li>标记-复制法<ul><li>前提：每次新生代都会回收大量的垃圾（90%？） </li><li>将内存空间划分成两个部分，一个from，一个to</li><li>当回收垃圾时，会将非垃圾的对象复制到另一块区域（将from区非垃圾复制到to区），并在复制的时候保证了内存的连续性。</li><li>清空from区，将from指针和to指针互换（即from又指向了非垃圾对象区，to又指向了空区）<br><img src="/../img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"> </li><li>缺点：<ul><li>需要占用双倍内存</li></ul></li></ul></li></ol><h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><ul><li><strong>新生代</strong><ul><li>是用来<strong>存放新生的对象</strong>。一般占据堆的1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾 回收。新生代又分为Eden 区、ServivorFrom、 ServivorTo 3个区。</li></ul></li><li><strong>老年代</strong><ul><li>主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以MajorGC（fullGC）不会频繁执行。在进行MajorGC 前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。<br><img src="/../img/%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E7%94%9F%E4%BB%A3.png"></li></ul></li><li><strong>分代回收过程</strong>：<ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc</li></ul></li><li><strong>永久代</strong><ul><li>指内存的永久保存区域，主要存放Class 和Meta (元数据)的信息,Class在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class 的增多而胀满，最终抛出OOM异常。</li><li>在Java8 中，永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代。</li><li>元空间的本质和永久代类似，元空间与永久代之间最大的区别在于:<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，<strong>元空间的大小仅受本地内存限制</strong>。</li><li>类的元数据放入native memory,字符串池和类的静态变量放入java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</li></ul></li><li><strong>回收策略</strong><ul><li>部分收集：不是进行整个java堆的垃圾收集<ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集（很多时候不区分Full GC和Major GC）</li></ul></li><li>整堆收集：<ul><li>Full GC</li></ul></li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器<br><img src="/../img/serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>又叫串行收集器，以串行方式执行</li><li>是单线程收集器，只会使用一个线程进行垃圾收集</li><li>简单高效</li></ul></li><li><p>ParNew收集器<br><img src="/../img/parnew%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>是Serial收集器的多线程版本</li><li>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</li><li>默认开启线程数量与cpu数量相同</li><li>单核下性能绝不会比serial收集器好</li></ul></li><li><p>Parallel Scavenge收集器</p><ul><li>与ParNew一样是多线程收集器，目标是尽可能缩短垃圾收集时用户线程停顿的时间，达到一个可控制的吞吐量，也被称为：吞吐量优先 收集器</li><li>这里的吞吐量指：cpu运行用户代码时间 &#x2F; 总时间</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。（当新生代空间变少，自然用于停顿标识垃圾的时间也就减少了）</li></ul></li><li><p>Serial Old收集器<br><img src="/../img/serialold%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p><ul><li>与Serial收集器对比，回收区域不同，回收方式也不同</li><li>serial收集器的老年代版本</li></ul></li><li><p>Parallel Old收集器<br><img src="/../img/parallelold%E6%94%B6%E9%9B%86%E5%99%A8.jpg">  </p><ul><li>是 Parallel Scavenge 收集器的老年代版本。</li></ul></li><li><p>CMS收集器<br><img src="/../img/cms%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</li><li>流程：<ul><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。（不影响用户线程的运行）</li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除: 不需要停顿。</li></ul></li><li>缺点；<ul><li>吞吐量低，低停顿时间是以牺牲吞吐量为代价，导致cpu利用率不高<ul><li>（为什么呢？因为其并发标记时占用了线程，使用户线程执行的时间变少了）</li></ul></li><li>无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程仍在继续而产生的垃圾，这部分垃圾只能在下一次GC才能进行回收。<ul><li>意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li></ul></li><li>使用的标记-清除算法会导致空间碎片</li></ul></li></ul></li><li><p>Garbage First收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html">G1详解</a><br><img src="/../img/g1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"> </p><ul><li>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</li><li>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</li><li>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li><li>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</li><li>步骤<ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</li></ul></li><li>使用标记-整理算法，不会产生内存碎片</li><li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul></li><li><p>ZGC收集器:  <a href="https://pdai.tech/md/java/jvm/java-jvm-gc-zgc.html">ZGC详解</a><br><img src="/../img/zgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png">  </p><ul><li>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：<ul><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；</li><li>支持8MB~4TB级别的堆（未来支持16TB）。</li></ul></li><li>使用关键技术<ul><li>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。<ul><li>染色指针是一种将信息存储在指针中的技术</li></ul></li><li>在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。<ul><li>读屏障类似于aop的环绕方法，在事件发生的前后进行指定的操作</li></ul></li></ul></li></ul></li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul><li>分配流程<ul><li>对象一般在堆上分配</li><li>对象优先在Eden分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-链路层</title>
    <link href="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><ul><li>链路层<ul><li>它的主要功能是在物理介质上<strong>可靠地传输数据帧</strong>，并提供一些基本的<strong>错误检测</strong>和<strong>纠正机制</strong>。</li><li>它负责在物理层提供的传输介质上实现可靠的数据传输，同时进行地<strong>址解析</strong>、<strong>错误检测</strong>和<strong>流量控制</strong>等操作，以确保数据正确、高效地传输。</li></ul></li><li>与物理层的联动<ul><li>物理层和链路层共同协同工作，以实现端到端的数据传输。</li><li>物理层提供了将比特从一台计算机传输到另一台计算机的物理手段，而链路层在这些物理媒体上创建了数据帧，并确保这些数据帧能够准确无误地从一个节点传输到另一个节点。</li></ul></li><li>链路，数据链路，帧<ul><li>链路<ul><li>链路（Link）是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</li></ul></li><li>数据链路<ul><li>数据链路（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li></ul></li><li>帧<ul><li>帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。<br><img src="/../img/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%A7%E7%A4%BA%E6%84%8F.png"></li></ul></li></ul></li></ul><h3 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h3><ul><li>封装成帧和透明传输<ul><li>封装成帧<ul><li>封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加一个首部和一个尾部，使之成为帧。</li><li>帧是数据单元，那么传输的时候是以一连串的比特流进行传输，一次可能传输若干个帧，所以我们如何确定帧呢？<ul><li>我们可以在帧的首部和尾部添加标识进行定界<br><img src="/../img/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png"></li></ul></li><li>此时会面临一些问题<ul><li>当我们传输的数据里面有和定界标识符一样的数据怎么办呢？接收方如何确定该帧的界限呢？</li></ul></li><li>透明传输<ul><li>透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在一样。<ul><li>如何理解呢？<ul><li>首先，我们为什么要使用帧呢？<ul><li>前面已经说了，将数据封装成帧后，可以在链路层实现错误的检测，纠正以及地址的解析。</li></ul></li><li>但是有了帧就会出现一些负面问题，如我们上面所说的，对帧的界限识别出现差错。<ul><li>所以为了得到帧的好处消除帧的坏处，我们就要实现透明传输：实现链路层的功能，但是好像数据链路层不存在一样（消除副作用）。</li></ul></li></ul></li><li>解决帧的界限问题<ul><li>面向字节的物理链路使用字节填充的方法实现透明传输<ul><li>我们发送时对数据进行扫描，在界限符前面，以及转义符前面添加转义符。</li></ul></li><li>面向比特的物理链路使用比特填充的方法实现透明传输<ul><li>即挑选比较特别的码作为帧的界限符（如0111110），我们发送时对数据进行扫描，每5个1就在其中插入一个0，由此实现了数据区不会出现帧的界限符的情况，在接收时，我们再按照指定的方法将数据区的0删除即可还原为原数据。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/source/img/%E8%A7%A3%E5%86%B3%E5%B8%A7%E7%95%8C%E9%99%90%E9%97%AE%E9%A2%98.png"> </p><ul><li><p>差错检测</p><ul><li>误码的相关概念<ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为比特差错）。<ul><li>比特0 -&gt; 比特1，比特1 -&gt; 比特0</li></ul></li><li>使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul></li><li>如何检验呢？<ul><li>奇偶校验<ul><li>奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。</li><li>偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。</li><li>但是此方法容易出现漏检。</li></ul></li><li>循环冗余校验<ul><li>数据链路层广泛使用漏检率极低的循环冗余校验（Cyclic Redundancy Check，CRC）检错技术。<ul><li>收发双方约定好一个生成多项式G(X)。</li><li>发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码（冗余码），将冗余码添加到待发送数据的后面一起传输。</li><li>接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。</li></ul></li></ul></li></ul></li></ul></li><li><p>可靠传输</p><ul><li>可靠传输的相关概念<ul><li>使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特差错）。</li><li>出现差错之后该怎么办呢？<ul><li>数据链路层为上层提供服务有两种情况<ul><li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li><li>可靠传输服务：通过某种机制实现：发送方发送什么，接收方就接收什么。</li></ul></li></ul></li><li>传输差错<ul><li>误码</li><li>分组丢失</li><li>分组失序</li><li>分组重复</li></ul></li><li>可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。</li><li>可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求。</li></ul></li><li>可靠传输的实现<ul><li>停止-等待协议<ul><li>发送方发送数据给接收方 -&gt; 接收方进行差错检测，无差错，则接收，并且返回确认接收了该分组。如果有误码，接收方则丢弃，并且返回否认接收了该分组。</li><li>此时存在问题<ul><li>接收方若未接到数据，会进行无限制的等待<ul><li>所以在发送方添加超时计时器，每当发送一组数据后就启动计时器，长时间未返回结果，则重新发送</li></ul></li><li>传输可能出现重复，接收返回请求也可能出现错乱<ul><li>对发送方的数据分组进行编号</li><li>对接收方返回的接收或者否认进行编号<br><img src="/../img/%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png"></li></ul></li></ul></li></ul></li><li>回退N帧协议<ul><li>是对停止等待协议的优化：回退N帧协议采用流水线传输方式，并且利用发送窗口来限制发送方连续发送数据分组的数量<br><img src="/../img/%E5%9B%9E%E9%80%80n%E5%B8%A7%E4%BC%98%E5%8C%96.png">  </li><li>简单来说就是： 允许发送方连续发送多个数据包，而不需要等待每个数据包的确认。接收方使用一个窗口大小来指示可以接收的下一个期望的数据包序号。这种方法可以提高传输效率。</li><li>具体见高军老师ppt<br><img src="/../img/%E5%9B%9E%E9%80%80n%E5%B8%A7%E7%A4%BA%E6%84%8F.png"> </li><li>回退N帧协议的接收方采用累积确认方式。<ul><li>接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。</li><li>接收方何时发送累积确认分组，由具体实现决定。</li><li>确认分组ACKn表明序号为n及之前的所有数据分组都已正确接收。</li><li>优点：<ul><li>减少向网络中注入确认分组的数量。</li><li>即使确认分组丢失，也可能不必重传数据分组。</li></ul></li><li>缺点：<ul><li>不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。</li></ul></li></ul></li><li>发送窗口𝑾_𝑻的取值范围是𝟏&lt;𝑾_𝑻≤ 2的n次方 - 1 ，如果超出范围，可能会出现分清楚此时传输的比特是新传输的还是重新传输的</li></ul></li><li>选择重传协议<ul><li>是对回退N帧协议的优化</li><li>为了使发送方仅重传出现差错的数据分组，接收方不再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。<br><img src="/../img/%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F.png">  </li><li>发送窗口和接收窗口的最大值为：2的（n-1）次方，若故意取𝑾_𝑻&#x3D;𝟓，使得𝑾_𝑻+𝑾_𝑹≥𝟐^𝟑，接收方将无法分辨新旧数据分组</li></ul></li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>以太网（Ethernet）是一种计算机网络技术，用于在局域网（LAN）中传输数据。它是最常见和广泛应用的局域网技术之一。</li><li>以太网使用一种称为CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection，具有载波侦听和冲突检测的多路访问）的协议来控制多台计算机同时访问网络时的数据冲突问题。</li><li>它采用了一种总线拓扑或星型拓扑的物理结构，允许多台计算机通过共享相同的传输媒介（通常是电缆或光纤）来进行通信。</li></ul><h4 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h4><ul><li>网络适配器和MAC地址<ul><li>网络适配器<ul><li>要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），网络适配器一般简称为“网卡”。</li><li>网络适配器是计算机与网络之间的桥梁，它负责管理数据在计算机和网络之间的传输，确保网络通信的顺畅和可靠性。</li><li>作用：<ul><li>连接计算机到网络</li><li>数据封装和解封</li><li>MAC地址管理：MAC地址用于在局域网中识别计算机和其他设备。网络适配器负责管理和维护这个地址。</li><li>网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换。<ul><li>在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I&#x2F;O总线以并行传输方式进行。</li><li>网卡与外部以太网（局域网）之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以串行方式进行的。</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/../img/%E7%BD%91%E5%8D%A1%E7%9A%84%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.png"></p><ul><li>MAC地址(物理地址，硬件地址)<ul><li>作用：使信息可以被准确的发送和接收</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li><li>在每个主机发送的帧的首部中，都携带有发送主机（源主机）和接收主机（目的主机）的数据链路层地址。由于这类地址是用于媒体接入控制（Medium Access Control，MAC）的，因此被称为MAC地址<br><img src="/../img/mac%E5%9C%B0%E5%9D%80%E4%BD%9C%E7%94%A8.png"> </li><li>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。（如一个交换机有多个接口，所以可能会有多个MAC地址）</li><li>网卡从网络上每收到一个帧，就检查帧首部的目的MAC地址，进行如下的操作：<ol><li>如果目的MAC地址是广播地址（FF-FF-FF-FF-FF-FF），则接受该帧。</li><li>如果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。</li><li>如果目的MAC地址是网卡支持的多播地址，则接受该帧。</li><li>其他情况丢弃该帧</li></ol></li></ul></li><li>CSMA&#x2F;CD协议<ul><li>引出<ul><li>由于共享型以太网有着天然广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点。</li><li>当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。<br><img src="/../img/%E4%BF%A1%E5%8F%B7%E7%A2%B0%E6%92%9E.png"></li></ul></li><li>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA&#x2F;CD，它是载波监听多址接入&#x2F;碰撞检测（Carrier Sense Multiple Access Collision Detection）的英文缩写词。<ul><li>多址接入MA<ul><li>多个站点连接在一条总线上，竞争使用总线。</li></ul></li><li>载波监听CS<ul><li>每个站点在发送帧之前，先要检测一下总线上是否有其他站点在发送帧（“先听后说”）<ul><li>若检测到总线空闲96比特时间（发送96比特所耗费的时间，也称为帧间最小间隔），则发送这个帧；</li><li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。</li></ul></li></ul></li><li>碰撞检测CD<ul><li>每个正在发送帧的站点边发送边检测碰撞（“边说边听”）：<ul><li>一旦发现总线上出现碰撞，立即停止发送，退避一段随机时间后再次从载波监听开始进行发送（“一旦冲突，立即停说，等待时机，重新再说”）。</li></ul></li></ul></li></ul></li><li>共享式以太网的争用期<ul><li>站点从发送帧开始，最多经过时长𝟐𝝉 （即𝜹→𝟎）就可检测出所发送的帧是否遭遇了碰撞。</li><li>共享总线以太网的端到端往返时间𝟐𝝉被称为争用期（Contention Period）或碰撞窗口（Collision Window）</li></ul></li><li>最小帧长和最大帧长<ul><li>最小帧长<ul><li>最小帧长是指以太网数据帧（Ethernet Frame）在物理层上必须具备的最小长度。以太网的最小帧长是64字节（包括64字节的数据和4字节的帧校验序列）。</li><li>这个最小帧长度是为了确保在网络中的数据帧在传输过程中具有足够的时间，以便其他设备能够检测到帧的存在，避免碰撞和丢失数据。</li></ul></li><li>最大帧长<ul><li>最大帧长是指以太网数据帧在物理层上允许的最大长度。以太网的最大帧长是1518字节（包括数据、帧头、帧校验序列和帧间隙）。</li><li>这个最大帧长度限制是为了确保在网络中传输的数据帧不会过大，从而防止网络拥塞和数据丢失。</li></ul></li></ul></li><li>共享式以太网的退避算法<ul><li>在使用CSMA&#x2F;CD协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。</li><li>共享总线以太网中的各站点采用截断二进制指数退避（Truncated Binary Exponential Backoff）算法来选择退避的随机时间。</li></ul></li></ul></li><li>使用集线器的共享式以太网<ul><li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器（Hub）。<br><img src="/../img/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BB%A5%E5%A4%AA%E7%BD%91.png"></li></ul></li><li>物理层扩展以太网<ul><li>扩展传输距离：<ul><li>在10BASE-T星型以太网中，可使用光纤和一对光纤调制解调器来扩展站点与集线器之间的距离。<br><img src="/../img/%E5%85%89%E7%BA%A4%E6%89%A9%E5%B1%95%E8%B7%9D%E7%A6%BB.png"></li></ul></li><li>扩展覆盖范围和数量<ul><li>以太网集线器一般具有8~32个接口，如果要连接的站点数量超过了单个集线器能够提供的接口数量，就需要使用多个集线器，这样就可以连接成覆盖更大范围、连接更多站点的多级星型以太网。<br><img src="/../img/%E9%9B%86%E7%BA%BF%E5%99%A8%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E5%92%8C%E6%95%B0%E9%87%8F.png"> </li><li>碰撞域<ul><li>指的是共享同一物理网络媒介的设备集合，它们在发送数据时可能会发生碰撞<br><img src="/../img/%E6%89%A9%E5%B1%95%E8%8C%83%E5%9B%B4%E7%9A%84%E7%A2%B0%E6%92%9E%E5%9F%9F.png"> </li><li>在物理层扩展的共享式以太网仍然是一个碰撞域，不能连接太多的站点，否则可能会出现大量的碰撞，导致平均吞吐量太低。</li></ul></li></ul></li></ul></li><li>数据链路层扩展以太网</li><li>网桥<ul><li>网桥是计算机网络中的网络设备，通常用于连接两个或多个局域网（LAN）或网络段，以便在它们之间传输数据</li><li>作用：<ul><li>网桥可以识别帧的结构。</li><li>网桥可以根据帧首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃所收到的帧。<br><img src="/../img/%E7%BD%91%E6%A1%A5%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></li></ul></li><li>网桥的自学习和转发帧<ul><li>转发表是如何建立的呢？<ul><li>透明网桥（Transparent Bridge）通过自学习算法建立转发表。</li><li>透明网桥中的“透明”，是指以太网中的各站点并不知道自己所发送的帧将会经过哪些网桥的转发，最终到达目的站点。也就是说，<strong>以太网中的各网桥对于各站点而言是看不见的</strong>。</li></ul></li><li>自学习和转发流程 ：<ol><li>网桥收到帧后进行登记（即自学习），登记的内容为帧的源MAC地址和进入网桥的接口号。</li><li>网桥根据帧的目的MAC地址和网桥的转发表对帧进行转发，包含以下三种情况：<ol><li><strong>明确转发：</strong>网桥知道应当从哪个接口转发帧。</li><li><strong>盲目转发：</strong>网桥不知道应当从哪个接口转发帧，只能将其通过除进入网桥的接口外的其他所有接口转发。</li><li><strong>丢弃：</strong>网桥知道不应该转发该帧，将其丢弃。</li></ol></li></ol></li></ul></li></ul></li></ul><h4 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h4><ul><li>以太网交换机（以下简称交换机）本质上就是一个多接口的网桥：<ul><li>交换机自学习和转发帧的流程与网桥是相同的</li><li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机。</li><li>当交换机的接口与计算机或交换机连接时，可以工作在全双工方式，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞地传输数据，这样就不需要使用CSMA&#x2F;CD协议了。<br><img src="/../img/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C.png"></li></ul></li></ul><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><ul><li>诞生背景：<ul><li>将多个站点通过一个或多个以太网交换机连接起来就构建出了交换式以太网。</li><li>交换式以太网中的所有站点都属于同一个广播域。</li><li>随着交换式以太网规模的扩大，广播域也相应扩大，<strong>巨大的广播域会带来一系列问题</strong><ul><li>广播风暴：广播风暴会浪费网络资源和各主机的CPU资源</li><li>难以管理和维护，带来潜在安全问题</li></ul></li></ul></li><li>分割广播域可以解决广播域太大导致的问题<ul><li>使用路由器可以隔离广播域（成本高）</li><li>虚拟局域网技术</li></ul></li><li>虚拟局域网（Virtual Local Area Network，VLAN）是一种将<strong>局域网内的站点划分成与物理位置无关的逻辑组的技术</strong>，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求。<ul><li>属于同一VLAN的站点之间可以直接进行通信，而不同VLAN中的站点之间不能直接通信。</li><li>连接在同一交换机上的多个站点可以属于不同的VLAN，而属于同一VLAN的多个站点可以连接在不同的交换机上。</li></ul></li><li>实现机制<ul><li>Access端口（默认）<ul><li>给“未打标签”的MAC帧打标签（根据端口自己的PVID），将PVID存入帧的VID中</li><li>若帧中的VID和接口的PVID值相同，则给帧去除标签，再进行转发，否则不转发</li></ul></li><li>Trunk端口<ul><li>既可以接收“未打标签”的MAC帧，也可以接收“已打标签”的802.1Q帧。若接收到普通以太网MAC帧时，根据接收帧的接口的PVID给帧“打标签”，这与Access接口的处理相同。</li><li>对于帧的VID值等于接口的PVID值的802.1Q帧，将其“去标签”转发；对于<strong>帧的VID值不等于接口的PVID值802.1Q帧</strong>，将其<strong>直接转发</strong>。因此，从Trunk接口转发出的帧，可能是普通以太网MAC帧，也可能是802.1Q帧。</li></ul></li></ul></li></ul><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><ul><li>802.11无线局域网使用CSMA&#x2F;CA协议的原因<ul><li>对于802.11无线局域网，其使用无线信道传输数据，这与共享总线以太网使用有线传输介质不同。因此，802.11无线局域网<strong>不能简单照搬共享总线以太网使用的CSMA&#x2F;CD协议</strong>。<ul><li>由于无线信道的<strong>传输环境复杂且信号强度的动态范围非常大</strong>，在802.11无线网卡上接收到的信号强度一般都<strong>远远小于发送信号的强度</strong>，信号强度甚至相差百万倍。因此，如果要在802.11无线网卡上实现碰撞检测，对硬件的要求非常高。</li><li>即使能够在硬件上实现碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），还会<strong>出现无法检测到碰撞</strong>的情况，因此实现碰撞检测并没有意义。</li></ul></li></ul></li><li>无线局域网不能简单照搬共享总线以太网（有线局域网）使用的CSMA&#x2F;CD协议，而是不再实现碰撞检测CD功能，但在<strong>CSMA的基础上增加碰撞避免CA功能</strong>，即使用CSMA&#x2F;CA协议。<ul><li>CSMA&#x2F;CA协议<ul><li>若站点最初有数据要发送(而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA&#x2F;CA协议的退避算法。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器时间减少到零时(这时信道只可能是空闲的)，站点就发送整个的帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的步骤(2)开始，执行CSMA&#x2F;CA协议的退避算法，随机选定一段退避时间。</li><li>若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间)，就必须重传此帧(再次使用CSMA&#x2F;CA协议争用接入信道)，直到收到确认为止，或者经过若干次的重传失败后放弃发送。<br><img src="/../img/CSMACA%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存结构</title>
    <link href="/2023/10/07/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2023/10/07/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作<br>特点：</p><ul><li>Java 虚拟机基于二进制字节码执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><p>Java代码执行流程：Java 程序 –（编译）–&gt; 字节码文件 –（解释执行）–&gt; 操作系统（Win，Linux）</p><p>JVM、JRE、JDK对比：</p><ul><li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li><li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件<br><img src="/../img/jdk%EF%BC%8Cjre%EF%BC%8Cjvm%E5%AF%B9%E6%AF%94.png"></li></ul><h4 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h4><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡</p><ul><li><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</li><li><strong>运行</strong>：<ul><li>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</li><li>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，JVM 使用的是守护线程，main() 和其他线程使用的是用户线程，守护线程会随着用户线程的结束而结束<ul><li>用户线程是由应用程序代码创建和管理的线程，它们通常用于执行应用程序的业务逻辑和任务。</li><li>守护线程是一种特殊类型的线程，它的存在不会阻止JVM退出。它们通常用于<strong>执行后台任务和服务</strong>，如垃圾回收、定时任务等。</li><li>守护线程在用户线程结束后，如果没有其他用户线程继续运行，它们会自动退出，以确保JVM正常关闭。</li></ul></li><li>执行一个 Java 程序时，真真正正在执行的是一个 Java 虚拟机的进程</li><li>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</li><li>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</li></ul></li><li><strong>死亡</strong>：<ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h4><ul><li>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</li><li>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行<br><img src="/../img/java1.8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></li></ul><h4 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h4><ol><li><p>程序计数器</p><ul><li>作用，记住下一条jvm指令的执行地址</li><li>特点<ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul></li><li>原理<ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul></li></ul></li><li><p>虚拟机栈</p><ul><li>每个线程运行所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存（存储局部变量表，操作数栈，动态链接，方法出口等信息）<ul><li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的定义</li><li>操作数栈或表达式栈和其他一些附加信息</li></ul></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li><li>虚拟机栈特点：<ul><li>栈内存不需要进行GC，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</li><li>方法内的局部变量是否线程安全：<ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul></li></ul></li><li><p>本地方法栈</p><ul><li>本地方法栈是为虚拟机执行本地方法时提供服务的</li></ul></li><li><p>堆<br>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题<br>存放：</p><ul><li>对象实例：类初始化生成的对象，基本数据类型的数组也是对象实例，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放在方法区，JDK7开始存放于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率<br>堆内存诊断工具：</li></ul><ol><li>jps：查看当前系统中有哪些 Java 进程</li><li>jmap：查看堆内存占用情况 jhsdb jmap –heap –pid 进程id</li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测、</li></ol></li><li><p>方法区</p><ul><li>方法区：<ul><li>是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</li><li>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</li></ul></li><li>为了避免方法区出现 OOM(OutOfMemoryError)，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，静态变量和字符串常量池等放入堆中</li><li>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了类在编译期间生成的字面量、符号引用，JVM 为每个已加载的类维护一个常量池<ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul></li><li>运行时常量池是方法区的一部分<ul><li>常量池：<ul><li>常量池是位于Java类文件（.class文件）中的一部分，用于存储各种常量信息，包括字符串常量、类名、方法名、字段名、常量值等。</li><li>常量池中的常量信息在编译期间被收集和生成，并在运行时被加载到内存中供JVM使用。</li><li>常量池中的常量是不可修改的，一旦定义，就不能被更改。</li><li>常量池中的字符串常量通常是被共享的，即多个字符串变量可以引用相同的字符串对象，以减少内存占用。</li></ul></li><li>StringTable<ul><li>StringTable是JVM内部的数据结构，用于管理和存储字符串对象。</li><li>具体请看：<a href="https://blog.csdn.net/cd546566850/article/details/105353791">JVM内存结构之浅析常量池、运行时常量池、StringTable</a><br><img src="/../img/%E5%88%9B%E5%BB%BAJava%E5%AF%B9%E8%B1%A1.png"></li></ul></li></ul></li></ul></li><li><p>直接内存</p><ol><li>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯问题笔记</title>
    <link href="/2023/10/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><ul><li>回溯算法可以解决如下问题：<ul><li>组合问题</li><li>排列问题</li><li>切割问题</li><li>子集问题</li></ul></li><li>回溯模板：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意事项：<ul><li>去重问题<ul><li><p>有重复元素情况的去重：此时元素的值可能重复，但是元素不能重复，答案也不能重复，例如[1,1,2] 中组合 [1,2],[1,2]，两个1来自不同元素，但是因为结果重复，所以需要去重</p><ul><li>对数组排序</li><li>添加全局标识数组used[]</li><li>进行条件判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex;i &lt; candidates.length; i++)&#123;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-comment">//注意是used[i-1]，进行当前元素处理的时候肯定是要判断是否之前有重复元素的访问。</span><br>    <span class="hljs-comment">//树枝可以使用，但是树层间不能使用</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.add(candidates[i]);<br>    helper(candidates,target,currentSum+candidates[i],i+<span class="hljs-number">1</span>);<span class="hljs-comment">//不是startindex + 1，而是i + 1，因为每次遍历都是向自己身后的元素进行搜索</span><br>    used[i] = <span class="hljs-literal">false</span>;<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树层去重：当前层for循环时进行去重</p><ul><li>在for循环之前定义一个set，存储此次for循环之前遍历过的元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;Integer&gt; used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++)&#123;<br>    <span class="hljs-keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="hljs-number">1</span>) &gt; nums[i] || used.contains(nums[i]))&#123;<span class="hljs-comment">//因为不能排序，所以无法像之前的used数组来进行标记</span><br>    <span class="hljs-comment">//这里使用集合来进行同层的判断</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used.add(nums[i]);<br>    path.add(nums[i]);<br>    helper(nums,i+<span class="hljs-number">1</span>);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树枝去重：向下递归时进行去重</p><ul><li>使用used数组进行全局的标识<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>    <span class="hljs-keyword">if</span>(used[i])&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.add(nums[i]);<br>    helper(nums,i+<span class="hljs-number">1</span>);<br>    used[i] = <span class="hljs-literal">false</span>;<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>for遍历去重：递归函数添加starIndex参数，每次迭代时从自身后一个元素进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n; i++)&#123;<span class="hljs-comment">//对根节点开始到最大结点进行组合</span><br>    path.add(i);<span class="hljs-comment">//组合</span><br>    traverse(n,k,i+<span class="hljs-number">1</span>);<span class="hljs-comment">//继续向下组合</span><br>    path.removeLast();<span class="hljs-comment">//回溯</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重复元素组合（不能重复结果）的求和</title>
    <link href="/2023/10/04/%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%9C%EF%BC%89%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/04/%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%9C%EF%BC%89%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p></blockquote><ul><li><p>难点：</p><ul><li>因为本题中的输入可以有相同的元素，所以[1,1,2]是合理的，而本题又不允许重复的结果，所以尽管[1,3]和[1,3]中的1来自不同的元素，但也是不允许的</li><li>因此，我们画图可以得出在树层的添加的时候，是可以允许重复，树间的添加是不允许重复</li><li>参考下图：<img src="/./../img/%E7%BB%84%E5%90%88%E6%B1%82%E5%92%8C%EF%BC%88%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89.jpg" alt="组合"></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-comment">//使用used数组来记录是否元素被访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> currentSum,<span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(currentSum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(currentSum == target)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex;i &lt; candidates.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-comment">//难点在此，因为本题中的输入可以有相同的元素，所以[1,1,2]是合理的，而本题又不允许重复的结果，所以尽管[1,3]和[1,3]中的1来自不同的元素，但也是不允许的</span><br>                <span class="hljs-comment">//因此，我们画图可以得出在树层的添加的时候，是可以允许重复，树间的添加是不允许重复</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(candidates[i]);<br>            helper(candidates,target,currentSum+candidates[i],i+<span class="hljs-number">1</span>);<span class="hljs-comment">//又出现了这个问题，不是startindex + 1，而是i + 1，因为每次遍历都是向自己身后的元素进行搜索</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<span class="hljs-comment">//记录访问过的元素</span><br>        Arrays.fill(used,<span class="hljs-literal">false</span>);<br>        Arrays.sort(candidates);<br>        helper(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {      font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;      font-size: 20px;  }  </style></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列笔记</title>
    <link href="/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/03/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><ul><li><p>消息队列（Message Queue）是一种用于在应用程序之间传输异步消息的通信模式。它是一种在分布式系统中广泛应用的通信机制，用于解耦应用程序的组件，实现松耦合和可伸缩性。</p></li><li><p>同步和异步通讯</p><ul><li>同步通讯：类似打电话，实时响应，但通讯期间无法干其他事情<ul><li>缺点：<ul><li>耦合度高，不便于修改</li><li>资源浪费，调用链中的每个服务都需要等待相关前置服务的响应，浪费资源</li><li>级联问题：一个服务出现问题，相关调用服务都会出现问题</li></ul></li></ul></li><li>异步通讯：类似发短信，不是实时，但是可以支持多线程操作<ul><li>优点：<ul><li>耦合度低，服务双方并不是直接通信，而是由一个中间人来代理，发布者发布事件到中间人，订阅者从中间人接收事件。同时也便于修改更新</li><li>增加吞吐量，快服务不会被慢服务耽误，发布事件后即可去继续执行自己的业务。如：一个支付服务只需要向Broker（中间人）发布一个支付成功的事件，剩下的就不用它管了</li><li>故障隔离，无级联问题，服务之间都是去中间人接受事件，一个服务出故障和另一个服务之间并没有直接关系</li><li>流量削峰：不管发布事件流量波动多大，都由中间人接收，进行缓冲，订阅者可以按照自己的速度处理事件</li></ul></li><li>缺点：<ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂时，业务没有明确的流程线，不好追踪管理（出了bug都不好找）</li></ul></li></ul></li></ul></li><li><p>常见MQ对比:</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p></li></ul><h3 id="MQ的基本使用"><a href="#MQ的基本使用" class="headerlink" title="MQ的基本使用"></a>MQ的基本使用</h3><ul><li>SpringAMQP<ul><li><p>它是基于RabbitMQ封装的一套模板，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现，并且利用SpringBoot对其实现了自动装配，使用起来十分方便</p></li><li><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul></li><li><p>消息的发送 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br>~~~java<br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<span class="hljs-comment">//用于发送消息</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, SpringAMQP! &quot;</span>;<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>消息的接收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><span class="hljs-comment">//注解要监听的队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>发布订阅<br>  <img src="/../img/%E5%B8%A6%E6%9C%89exchange%E7%9A%84mq.png" alt="exchangemq"><ul><li>增加了exchange角色<ul><li>Exchange：交换机。一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或者是将消息对其。到底如何操作，取决于Exchange的类型。Exchange有以下三种类型<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key的队列</li><li>Topic：通配符，把消息交给符合routing pattern(路由模式)的队列</li></ul></li></ul></li></ul></li><li>消息转换器<ul><li>Spring会把发送的消息序列化为字节发送给MQ，接收消息的时候，会将字节反序列化为Java对象</li><li>但是默认情况下，Spring采用的序列化方式是JDK序列化，众所周知，JDK序列化存在以下问题<ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul></li><li>使用jackson代替原来的jdk的序列化<ul><li>引入依赖</li><li>在publisher和comsumer启动类添加bean，对原来的序列化进行覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>publis MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>consumer和publisher的序列化器需保持一致，同时consumer中接收数据的类型，也需要和发送数据的类型保持一致</li></ul></li></ul></li></ul><pre><code class="hljs">&lt;style&gt;  /* 只设置 markdown 字体 */  .markdown-body &#123;    font-family: KaiTi,&quot;Microsoft YaHei&quot;,Georgia, sans, serif;    font-size: 20px;  &#125;&lt;/style&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker笔记</title>
    <link href="/2023/10/03/docker%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/03/docker%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><ul><li>docker是一个用go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所需要的依赖打包进docker container。</li><li>image：<ul><li>Docker镜像是容器的模板，它包含了应用程序和其依赖项的快照。镜像是只读的，可用于创建运行中的容器实例。</li></ul></li><li>container：<ul><li>Docker容器是一个轻量级的可执行单元，包括应用程序及其运行时环境、依赖项和配置。容器隔离了应用程序和底层操作系统，确保容器在不同环境中具有一致的行为。</li></ul></li><li>dockerhub：<ul><li>类似于github，是官方的一个镜像托管平台，类似的平台有很多，如阿里云镜像库等，这样的平台统称为：docker registry</li><li>我们可以将自己的镜像上传到dockerhub，也可以直接从dockerhub拉取镜像</li></ul></li><li>docker架构：<ul><li>服务端：负责处理docker命令，管理镜像，容器等</li><li>客户端：通过api向docker服务端发送指令</li><li><img src="/./../img/docker%E6%9E%B6%E6%9E%84.jpg" alt="docker架构"></li></ul></li></ul><h3 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h3><ul><li>docker可以解决依赖兼容问题<ul><li>docker打包应用的依赖，配置等，并且进行了隔离</li></ul></li><li>docker可以解决操作系统环境的差异<ul><li>docker不仅打包应用的依赖，也打包了系统的库函数</li><li>所以docker可以解决不同的系统上的环境问题，但是必须底层都是一个系统（如都是linux的Ubuntu，Centos等）</li></ul></li><li>docker和虚拟机的区别：<ul><li>Docker容器非常轻量级，与传统虚拟机相比，它们更快速启动、占用更少的系统资源，并允许在同一物理主机上运行更多的容器。</li><li>Docker便于移植</li></ul></li></ul><h3 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h3><ul><li>建议自行查看docker文档，或者询问chatgpt</li><li>推荐一篇文章<a href="https://zhuanlan.zhihu.com/p/187505981">什么是docker</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//使用docker前记得先开启docker<br>//拉取指定版本的镜像<br>docker pull mysql:8.0.26<br><br>//运行镜像，根据不同的镜像有不同的参数<br>docker run --name hmmysql -e MYSQL_ROOT_PASSWORD = 123 -d mysql:8.0.26<br><br>//使用镜像<br>docker <span class="hljs-built_in">exec</span> -it hmmysql mysql -uroot -p<br><br>//windows中连接linux的mysql<br>//获取mysql容器的ip地址<br>docker inspect -f <span class="hljs-string">&quot;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&quot;</span> hmmysql<br></code></pre></td></tr></table></figure><style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修剪二叉搜索树</title>
    <link href="/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2023/10/02/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树</a></p></blockquote><ul><li><p>与删除结点思路不同</p><ul><li>我们应该利用特性，来递归遍历</li><li>即当根结点值小于low，那么所有左子树可以抛弃，将右子树返回给上层接收即可，此操作删除了根节点也删除了根节点的左子树（大于high同理）</li><li>然后每次递归操作需要递归返回，以及递归完后需要        <ul><li>root.left &#x3D; trimBST(root.left,low,high);</li><li>root.right &#x3D; trimBST(root.right,low,high);</li></ul></li><li>这就是上层接收与下层返回的实现</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment">* public class TreeNode &#123;</span><br><span class="hljs-comment">*     int val;</span><br><span class="hljs-comment">*     TreeNode left;</span><br><span class="hljs-comment">*     TreeNode right;</span><br><span class="hljs-comment">*     TreeNode() &#123;&#125;</span><br><span class="hljs-comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment">*         this.val = val;</span><br><span class="hljs-comment">*         this.left = left;</span><br><span class="hljs-comment">*         this.right = right;</span><br><span class="hljs-comment">*     &#125;</span><br><span class="hljs-comment">* &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; low)&#123;<span class="hljs-comment">//此时越界了，删除所有左子树以及根节点（即让上层接收右子树）</span><br>            <span class="hljs-keyword">return</span> trimBST(root.right,low,high);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &gt; high)&#123;<span class="hljs-comment">//此时越界了，删除所有右子树以及根节点</span><br>            <span class="hljs-keyword">return</span> trimBST(root.left,low,high);<br>        &#125;<br>        <span class="hljs-comment">//上层的接收发起</span><br>        root.left = trimBST(root.left,low,high);<br>        root.right = trimBST(root.right,low,high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除二叉搜索树的结点</title>
    <link href="/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <url>/2023/10/02/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></p></blockquote><ol><li>思路分析</li></ol><ul><li>整体思路：<ul><li>依然使用二叉搜索树的性质来查找需要删除的节点</li><li>当找到时执行相应的删除逻辑</li></ul></li><li>在二叉搜索树中删除节点比插入节点难，因为删除节点的时候涉及到了结构的调整。</li><li>所以我们在删除的时候得分情况来进行讨论<ul><li>当找到的节点是叶子节点时，直接返回null，即代表删除（原理是返回null给上层的递归调用的节点来进行接受）</li><li>当只有单个子节点时，直接返回单个子节点，给上层接受</li><li>当有两个节点时（包括有两颗子树），我们需要思考如何调整结构，我们画图后可以很容易想明白，我们可以按照二叉搜索树规则来进行结构调整。<ul><li>比如我们可以选择将待删除的节点的右节点作为新的根节点，于是我们应该将待删除的节点的左子树迁移到右子树上。</li><li>但是迁移到哪里呢？我们知道二叉搜索树是左节点小于根节点，右节点大于根节点，所以右子树全部节点都大于左子树，我们应该将左子树拼接到右子树中最小的节点之中。</li><li>所以我们应该将左子树拼接到右子树的最最左节点上</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<span class="hljs-comment">//找到删除节点</span><br>            <span class="hljs-comment">//分类讨论</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//找到右子树中最小的节点，将左子树拼接上去</span><br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root.val)&#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; root.val)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习笔记</title>
    <link href="/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h3><ul><li>单体架构：将所有的功能集中在一个项目之中开发，打包部署<ul><li>优点<ul><li>架构简单</li><li>部署成本低</li></ul></li><li>缺点<ul><li>耦合度高，维护困难，升级困难</li></ul></li></ul></li><li>分布式架构：根据功能对系统做拆分，每个业务功能模块作为独立的项目进行开发，成为一个服务<ul><li>优点<ul><li>耦合度低</li><li>利于服务的升级拓展</li></ul></li><li>缺点<ul><li>调用关系复杂</li></ul></li></ul></li><li>微服务<ul><li>架构特点：<ul><li>单一职责，每一个服务对应唯一的业务能力，做到单一职责</li><li>自治，团队独立，技术独立，数据独立</li><li>面向服务，服务提供统一标准接口，与语言和技术无关</li><li>隔离性强，服务调用做好隔离，容错，降级，避免出现级联问题（即一个服务挂了影响到另一个服务）<br><img src="/../img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微服务"></li></ul></li></ul></li><li>SpringCloud<ul><li>SpringCloud 集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验</li><li>常见的组件包括：<ul><li>微服务注册与发现<ul><li>Eureka</li><li>Nacos</li><li>Consul</li></ul></li><li>服务远程调用<ul><li>OpenFeign</li><li>Dubbo</li></ul></li><li>服务链路监控<ul><li>Zipkin</li><li>Sleuth</li></ul></li><li>统一配置管理<ul><li>SpringCloudConfig</li><li>Nacos</li></ul></li><li>统一网关路由<ul><li>SpringCloudGateway</li><li>Zuul</li></ul></li><li>流控，降级，保护<ul><li>Hystix</li><li>Sentinel</li></ul></li></ul></li></ul></li></ul><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><ul><li>假如我们的服务提供者user-service提供了三个实例，占用的分别是8081、8082、8083端口</li><li>我们思考三个问题：<ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时，该如何选择？</li><li>order-service如何得知某个user-service实例是否健康，是不是已经宕机？</li></ul></li><li>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下<br><img src="/./../img/eureka%E7%BB%93%E6%9E%84.jpg" alt="eureka结构"></li><li>我们回答上述问题：<ul><li>order-service如何得知user-service实例地址？<ul><li>user-service服务启动后，会将自己的信息注册到eureka服务端</li><li>eureka保存 服务名称 - 服务实力的地址 的映射</li><li>order-service根据服务名称拉取实例的地址列表</li></ul></li><li>order-service如何从多个user-service实例中选择具体的实例？<ul><li>利用负载均衡的算法进行判断（随机，轮询等）</li></ul></li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？<ul><li>被注册的服务（userservice）会定时向eureka-server发起请求（心跳），报告自己的状态</li><li>当eureka-server一定时间 没有接收到已经注册的服务的请求（心跳）时，eureka-server会认为该服务实例故障，会从服务列表剔除。</li></ul></li></ul></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>为什么要用负载均衡<ul><li>解决单体架构无法应对高请求的问题</li><li>将客户端请求均匀的分发到多台目标服务器</li><li>检测出目标服务器的健康状态，使得客户端不向已经宕机的服务器发送请求。</li></ul></li><li>实现方案<ul><li>基于DNS实现负载均衡</li><li>基于硬件实现负载均衡</li><li>基于软件实现负载均衡</li></ul></li><li>基于软件实现负载均衡<ul><li>SpringCloud底层利用Ribbon组件来实现负载均衡功能<br><img src="/../img/ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="ribbon实现负载均衡"></li><li>ribbon调用详情如下：<br><img src="/../img/ribbon%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt="ribbon调用详情"><ol><li>拦截RestTemplate请求：<a href="http://user-service/user/1">http://user-service/user/1</a></li><li>RibbonLoadBalanceClient会从请求中获取服务名称，即user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost8081，localhost8082</li><li>IRule根据负载均衡规则，选择一个实例</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代user-service，得到<a href="http://localhost:8081/user/1%EF%BC%8C">http://localhost:8081/user/1，</a> 发起真实请求</li></ol></li></ul></li><li>负载均衡策略：<ul><li>随机，轮询等</li><li>默认的是ZoneAvoidanceRule，是一种轮询方案</li><li>自定义实现：<ul><li>代码方式：在order-service中的OrderApplication类中，定义一个IRule，此种方式定义的负载均衡规则，对所有微服务均有效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>配置文件实现：在order-service中的application.yml文件中，添加新的配置也可以修改规则<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是user-service服务</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure></li></ul></li><li>饥饿加载：饥饿加载是一种在获取主要数据的同时，立即获取相关联的数据的策略。</li><li>懒加载：懒加载是一种在需要数据时才加载的策略。</li><li>Ribbon默认是采用懒加载，即第一次访问时，才回去创建LoadBalanceClient，第一次请求时间会很长</li><li>而饥饿加载在则会在项目启动时创建，降低第一次访问的耗时，可以在配置文件中调整加载方案。</li></ul></li></ul><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><ul><li>认识Nacos<ul><li>Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件，相比于Eureka，功能更加丰富，在国内受欢迎程度较高</li><li>Nacos是SpringCloudAlibaba的组件，而SpringCloud Alibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos与使用Eureka对于微服务来说，依赖不同，服务地址不同，其他基本类似。</li><li>nacos集群：将服务实例分布于全国各地，在一个地方的实例划分为一个集群，增加容灾能力。</li><li>nacos服务分级存储模型：<ol><li>服务：userservice</li><li>集群，杭州的userservice</li><li>实例，杭州的机房的部署了userservice的服务器</li></ol></li><li>nacos在实现负载均衡的时候会优先同集群的实例</li><li>权重配置<ul><li>对于老差设备分配更少的权重</li><li>nacos可以进行权重的配置（设为0，该实例永远不会被访问）</li></ul></li><li>环境隔离：Nacos提供了namespace来实现环境隔离功能<ul><li>nacos中可以有多个namespace</li><li>namespace下可以由group、service等</li><li>不同的namespace之间相互隔离，例如不同的namespace的服务互相不可见</li></ul></li><li>nacos实例分类<ul><li>临时实例（默认类型），宕机超过一定时间，会从服务列表中剔除。</li><li>非临时实例（可手动设置），宕机后不会被剔除。</li></ul></li><li>Nacos与Eureka的共同点<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康监测</li></ul></li><li>Nacos与Eureka的不同点<ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当急群众存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul></li></ul><h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><ul><li>为什么需要配置管理：<ul><li>当服务器部署的实例越来越多时，逐个修改微服务的配置很麻烦，并且容易出错，所以此时需要一个统一的配置管理方案，集中管理所有实例的配置。</li><li>Nacos可以将配置集中管理，也可以在配置变更时，及时通知微服务，实现配置的热更新。</li></ul></li><li>从微服务拉取配置：<ul><li>微服务要拉取Nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动</li><li>既然要拉取nacos中的配置，再读取application.yml，那么如何获取nacos的地址呢？<ul><li>Spring引入了一种新的配置文件：bootstrap.yml文件，会在application.yml之前被读取<ol><li>项目启动</li><li>加载bootstrap.yml,获取nacos地址，配置文件的id（服务名-服务环境-后缀名）</li><li>根据配置文件id，读取nacos中的配置文件</li><li>读取本地的application.yml，与nacos中的配置合并</li><li>创建spring容器</li><li>加载bean</li></ol></li></ul></li></ul></li><li>配置的热更新<ul><li>在@Value注入的变量类上添加注解@RefreshScope（刷新作用域）</li><li>使用@ConfigurationProperties注解代替@Value注解，在user-service服务中，添加一个类，读取pattern.dateformat属性</li></ul></li><li>配置共享：<ul><li>其实微服务启动时，回去Nacos读取多个配置文件，例如<ul><li>[spring.application.name]-[spring.profiles.active].yaml，例如：user-service-dev.yaml</li><li>[spring.application.name].yaml，例如：userservice.yaml</li></ul></li><li>而[spring.application.name].yaml不包含环境，因此可以被多个环境共享</li><li>配置共享优先级<ul><li>服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置<ul><li>user-service-dev.yaml &gt; user-service.yaml &gt; application.yaml</li></ul></li></ul></li></ul></li></ul><h3 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h3><ul><li>为什么要使用feign远程调用：<ul><li>以前的RestTemplate存在以下问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://user-service/user/&quot;</span> + order.getUserId();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, User.class);<br></code></pre></td></tr></table></figure><ul><li>可读性差，编程体验不统一</li><li>对于参数复杂的url难以维护</li></ul></li></ul></li><li>feign的使用<ul><li>使用步骤：引入依赖-&gt;添加注解-&gt;编写feign客户端<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;user-service&quot;)</span><span class="hljs-comment">//服务名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><span class="hljs-comment">//请求方式以及路径</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<span class="hljs-comment">//请求参数以及返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserClient userClient;<span class="hljs-comment">//注入feign客户端</span><br><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-comment">// 1. 查询订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.findById(orderId);<br>        <span class="hljs-comment">// 2. 利用Feign发起http请求，查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.findById(order.getUserId());<br>        <span class="hljs-comment">// 3. 封账user到order</span><br>        order.setUser(user);<br>        <span class="hljs-comment">// 4. 返回</span><br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>feign的使用优化<ul><li>feign的最佳实践<ul><li>继承：<ol><li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserAPI</span>&#123;<br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>Feign客户端和Controller都继承该接口</li></ol><ul><li>实现了代码共享，但是紧耦合</li></ul></li><li>抽取：<ul><li>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</li><li>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用<br><img src="/../img/feign%E7%9A%84%E6%8A%BD%E5%8F%96%E5%AE%9E%E7%8E%B0.jpg" alt="feign的抽取实现">   </li><li>解决包扫描问题：<ul><li>指定Feign应该扫描的包</li><li>指定需要加载的Client接口</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h3><ul><li>为什么需要网关<ul><li>Gateway网关是我们服务的守门神，是所有微服务的统一入口</li></ul></li><li>网关的核心功能为：<ul><li>请求路由:一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫路由。当然路由的目标服务有多个时，还需要做负载均衡</li><li>权限控制:网关作为微服务的入口，需要校验用户是否有请求资格，如果没有则拦截</li><li>限流:当请求量过高时，在网关中按照微服务能够接受的速度来放行请求，避免服务压力过大<br><img src="/../img/%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="网关架构图"> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">## 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment">## 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment">## nacos地址（我这里还是用的nginx反向代理，你们可以启动一个单体的nacos，用8848端口）</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment">## 路由id，自定义，只需要唯一即可</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span> <span class="hljs-comment">## 路由的目标地址，lb表示负载均衡，后面跟服务名称</span><br>          <span class="hljs-comment">## uri: http://localhost:8081 ## 路由的目标地址，http就是固定地址</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">## 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment">## 这个是按照路径匹配，只要是以/user开头的，就符合规则</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span> <span class="hljs-comment">## 按照上面的写法，再配置一下order-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-service</span> <br>          <span class="hljs-attr">predicates:</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span> <br></code></pre></td></tr></table></figure></li></ul></li><li>过滤器：<ul><li>作用：<ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由请求生效</li></ul></li><li>default-filters：<ul><li>对所有路由都生效的过滤器</li></ul></li><li>全局过滤器：<ul><li>使用自己的业务逻辑进行实现的过滤器</li></ul></li><li>过滤器执行顺序<ul><li>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</li><li>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器<br><img src="/../img/%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt="过滤器"> </li><li>排序规则为：<ul><li>每个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前（默认值为2147483647，即int最大值）</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul></li></ul></li></ul></li><li>跨域问题：<ul><li>什么是跨域：域名不一致就是跨域，主要包括<ul><li>域名不同：<a href="http://www.baidu.com和www.baidu.org,www.js.com和miaosha.js.com/">www.baidu.com和www.baidu.org，www.js.com和miaosha.js.com</a></li><li>域名相同，端口不同：localhost:8080和localhost:8081</li><li>请求协议不同，如http:baidu.com和https:baidu.com</li></ul></li><li>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</li><li>解决方案：CORS<ul><li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</li><li>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<style>/* 只设置 markdown 字体 */.markdown-body {font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;font-size: 20px;}</style></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-30记事</title>
    <link href="/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/30/2023-9-30%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>放假以来一直有点颓废，已经浪费接近三天了。原因有二：</p><ul><li>主要原因还是自己浮躁，懒惰，没能走出宿舍去教室自习。</li><li>在宿舍人容易有惰性，并且还会容易沉迷无限火力。</li><li>还有就是自己的焦虑问题<ul><li>总是想一口吃成大胖子，导致学习不扎实，自己也喜欢幻想自己变成编程大佬的开心生活。</li><li>明明知道自己该做什么，但还是焦虑自己是不是该做这，该做那，然后又去刷点短视频，水点群，真是浪费时间，还极度的影响到了我的睡眠。</li></ul></li><li>解决对策：<ul><li>早上起来，迅速洗漱，走出宿舍去教室自习。</li><li>制定学期计划，月计划，周计划，日计划，并且贯彻执行。</li><li>禁止胡思乱想，一旦胡思乱想请立马查看自己的胡思乱想对策，开始进行自我的提升和学习。</li><li>保持良好的运动习惯，蹲推拉不能少，晚上的有氧也不能少，跑步，骑车都可以。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归回溯解决二叉树所有路径问题】</title>
    <link href="/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/30/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径</a></p></blockquote><ul><li>关键在于如何进行所有路径的记录以及遍历。<ul><li>首先肯定是要利用前序遍历的思想的，因为题目要求的顺序和前序遍历的顺序一致，即 根-&gt;子 </li><li>利用回溯来实现非暴力的遍历，此题来说遍历就是向paths加节点，回溯就是向paths删节点。</li></ul></li><li>具体实现参照代码以及自己画图理解</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-comment">//前序遍历进行加入</span><br>        paths.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到达叶子节点</span><br>            <span class="hljs-comment">//构建符合题意的字符串</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; paths.size() - <span class="hljs-number">1</span>; i++) &#123;<br>                sb.append(paths.get(i)+<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>            sb.append(paths.get(paths.size()-<span class="hljs-number">1</span>));<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.left, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//进行回溯,节点指针回退一步，并且让paths重新变为回退的状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>)&#123;<br>            traversal(root.right, paths, res);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        traversal(root,paths,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-附近商户，签到，uv统计</title>
    <link href="/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/09/30/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E9%99%84%E4%BB%B6%E5%95%86%E6%88%B7%EF%BC%8C%E7%AD%BE%E5%88%B0%EF%BC%8Cuv%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h3><ul><li>实现根据当前位置搜索附近商户，并排序。</li></ul><h4 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h4><ul><li>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。</li><li>根据商铺类型为key，写入类型相同的商铺的经度纬度信息，保存在一个ZSet中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取所有shop，并且根据shop类型进行分组，保存在Map中（shopid，shops）</span><br>    List&lt;Shop&gt; shopList = shopService.list();<br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">//map.entrySet()：获取所有的键值对集合</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        List&lt;Shop&gt; shops = entry.getValue();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(shops.size());<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            <span class="hljs-comment">//将当前type的商铺都添加到locations集合中</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())));<br>        &#125;<br>        <span class="hljs-comment">//批量写入</span><br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>具体实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">//1. 判断是否需要根据距离查询</span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br>    <span class="hljs-comment">//2. 计算分页查询参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>    <span class="hljs-comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span><br>    <span class="hljs-comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span><br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(key,<br>            GeoReference.fromCoordinate(x, y),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));<br>    <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//4. 解析出id</span><br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    <span class="hljs-keyword">if</span> (list.size() &lt; from) &#123;<br>        <span class="hljs-comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    HashMap&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        ids.add(Long.valueOf(shopIdStr));<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>        distanceMap.put(shopIdStr, distance);<br>    &#125;);<br>    <span class="hljs-comment">//5. 根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        <span class="hljs-comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span><br>        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>    &#125;<br>    <span class="hljs-comment">//6. 返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>如何高效少内存的进行签到统计：<ul><li>使用31位bitMap来统计一个用户的一个月的签到情况，1为签到，0为未签到。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 写入Redis  BITSET key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>如何获取本月连续签到的数据<ul><li>获取签到数据（从当前日期直到月初）</li><li>从末尾往前计算看有多少个连续的1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//2. 获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">//3. 拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">//4. 获取今天是当月第几天(1~31)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()<br>            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            count++;<br>        <span class="hljs-comment">//数字右移，抛弃最后一位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="uv统计"><a href="#uv统计" class="headerlink" title="uv统计"></a>uv统计</h3>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/09/29/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数</a></p></blockquote><ul><li>简单方法就是直接遍历<ul><li>可以使用递归</li><li>可以是用迭代（利用队列）</li></ul></li><li>难点在于根据题目条件进行优化，即使用完全二叉树性质。<ul><li>完全二叉树：只有最底层的节点不是满的，并且最底层的节点从左到右必须是连续的。</li><li>一颗满二叉树（所有节点都是满的）的节点个数是2^deep - 1个，所以我们可以判断出满二叉树的个数，然后进行叠加计算。</li><li>完全二叉树是由许多的满二叉树组成的（可画图分析）</li><li>所以使用递归进行计算，如何判断是否是满二叉树呢<ul><li>一个根节点，对其进行左遍历以及右遍历（一直左遍历，一直右遍历）来进行判断， 当其左遍历深度&#x3D;&#x3D;右遍历深度时，其为一棵满二叉树。</li></ul></li></ul></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDeepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left!=<span class="hljs-literal">null</span>)&#123;<br>            left = left.left;<br>            leftDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>            right = right.right;<br>            rightDeepth ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(rightDeepth==leftDeepth)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>&lt;&lt;leftDeepth) -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> countNodes(root.right) + countNodes(root.left)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-达人探店，好友关注</title>
    <link href="/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/"/>
    <url>/2023/09/29/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%EF%BC%8C%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能实现"><a href="#点赞功能实现" class="headerlink" title="点赞功能实现"></a>点赞功能实现</h4><ol><li><p>基本功能实现</p><ul><li>要求：<ul><li>同一个用户只能对同一篇笔记点赞一次，再点赞即取消点赞</li><li>当前用户若点赞则显示高亮（前端页面会根据是否点赞决定是否高亮），根据isLike属性判断</li></ul></li><li>实现：<ul><li>使用redis中的set集合来进行判断是否点赞过（下文会具体介绍）。</li><li>点赞判断使用blog实体中的isliked进行判断，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注解通常用于实体类属性上，表示该属性不对应数据库表中的列。</span><br><span class="hljs-comment">//在这里，属性 isLike 被标记为 exist = false，</span><br><span class="hljs-comment">//意味着这个属性不会映射到数据库表的任何列。</span><br><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span>&#123;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//防止空指针</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;blog:liked&quot;</span>+blog.getId();<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key,userId.toString());<br>    blog.setIsLike(score != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>点赞排行榜实现</p><ul><li>要求：根据时间顺序展示点赞用户。</li><li>目前的问题：我们之前的点赞是放入set集合，无法进行时间的判断，所以我们此时可以使用Sortset（Zset），包含分数作为优先级。<br> <img src="/../img/list%EF%BC%8Cset%EF%BC%8Csortedset%E5%AF%B9%E6%AF%94.png" alt="对比"></li><li>解决方案：<ul><li>点赞使用zset保存，key是：”blog:liked”+id;（id是被点赞blogid），存储的元素是（userid（点赞人），分数（当前毫秒时间戳））<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br><br>       <span class="hljs-comment">// 获取当前登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>       <span class="hljs-type">Double</span> <span class="hljs-variable">haveScore</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>       <span class="hljs-keyword">if</span> (haveScore==<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//未点赞，可点赞</span><br>           <span class="hljs-comment">//数据库点赞数据+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//保存用户到redis的set集合</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().add(key,userId.toString(),System.currentTimeMillis());<span class="hljs-comment">//点赞榜单，使用sortedSet进行优化，以时间戳作为优先级排序</span><br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//已点赞，取消点赞</span><br>           <span class="hljs-comment">//数据库-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>           <span class="hljs-comment">//将用户从redis的set集合移除</span><br>           <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>               stringRedisTemplate.opsForZSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>排行榜实现：根据博客查询redis集合（点赞人）-&gt; 按照指定顺序返回点赞人集合</li><li>关注点：如何在in的情况下按照指定顺序返回数据：见注释<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">//查询top5的点赞用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked&quot;</span>+id;<br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//解析出用户id</span><br>    <span class="hljs-keyword">if</span> (top5==<span class="hljs-literal">null</span>||top5.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">//in查询数据库是按照默认id顺序，所以需要进行指定顺序，order by field(id,5,1)#根据id按照5，1进行返回</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>    List&lt;User&gt; users = userService.query().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br>            .last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>)<br>            .list();<br>    List&lt;UserDTO&gt; userDTOS = users.stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">//返回userdto</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><h4 id="关注功能实现"><a href="#关注功能实现" class="headerlink" title="关注功能实现"></a>关注功能实现</h4><ul><li>简单实现 <ul><li>建立数据库表tb_follow，有userid，followUserid字段来实现关注功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">//获取当前登录的userId</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//查询当前用户是否关注了该笔记的博主</span><br>        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>        <span class="hljs-comment">//只查询一个count就行了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count(queryWrapper);<br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFellow)</span> &#123;<br>        <span class="hljs-comment">//获取当前用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//判断是否关注</span><br>        <span class="hljs-keyword">if</span> (isFellow) &#123;<br>            <span class="hljs-comment">//关注，则将信息保存到数据库</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//取关，则将数据从数据库中移除</span><br>            LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>            remove(queryWrapper);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>共同关注功能实现<ul><li>利用redis的set集合存储用户的关注对象，对两个用户的关注对象集合求交集即可求出共同关注。下面为修改之后的关注功能实现，即将关注的对象加入redis中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>     <span class="hljs-comment">//获取用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userDTO.getId();<br>     <span class="hljs-comment">//判断是否关注</span><br>     <span class="hljs-keyword">if</span> (isFollow)&#123;<br>         <span class="hljs-comment">//关注则新增数据</span><br>         <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>         follow.setUserId(userId);<br>         follow.setFollowUserId(followUserId);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注的用户的id，放进redis的set集合 ： sadd userId followerUserId</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().add(key,followUserId.toString());<br>         &#125;<br>     &#125;<span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//取关，删除数据</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                 .eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId)<br>                 .eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>,followUserId));<br>         <span class="hljs-keyword">if</span> (isSuccess)&#123;<br>             <span class="hljs-comment">//把关注用户的id从redis移除</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span>+userId;<br>             stringRedisTemplate.opsForSet().remove(key,followUserId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="推送功能实现"><a href="#推送功能实现" class="headerlink" title="推送功能实现"></a>推送功能实现</h4><ul><li>feed流<ul><li>当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂。</li><li>feed流有两种模式：<ul><li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等)</li><li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</li></ul></li></ul></li><li>Timeline三种模式：<ul><li>推</li><li>拉</li><li>推拉结合</li></ul></li><li>我们使用推模式进行实战<ul><li>需求：<ul><li>修改新增博客的业务，在博客保存到数据库的时候，也推送到粉丝的收件箱。</li><li>收件箱按时间戳排序</li><li>收件箱实现分页查询</li></ul></li><li>难点：<ul><li>传统情况下分页查询是根据角标进行，但是因为我们的feed数据会更新，同时脚标也会更新，所以不能使用脚标。<ul><li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页<br><img src="/../img/%E8%A7%92%E6%A0%87%E5%8F%98%E5%8C%96.png" alt="角标变化"></li></ul></li><li>使用score来进行分页可以解决问题<ul><li>score使用时间戳来进行记录</li><li>根据集合名（当前登录id的关注集合），最小分数，最大分数，开始偏移量，查询个数 reverseRangeByScoreWithScores(key, 0, max, offset, 2);</li><li>每次查询完毕后需要返回最小时间戳，作为下次查询条件</li><li>偏移量的作用是防止出现相同时间戳的情况，为上次查询返回的相同最小时间戳的个数，关键，1最小时间戳（即最后一个），2相同</li><li>封装返回</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">//获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//查询用户收件箱（set(key（feed:userid),粉丝的id）)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;feed:&quot;</span>+userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>            <span class="hljs-comment">//查询的集合，最小分数值，最大分数值，起始偏移，查询数量</span><br>            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples==<span class="hljs-literal">null</span>||typedTuples.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//解析数据</span><br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple:typedTuples)&#123;<br>        <span class="hljs-comment">//获取id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> typedTuple.getValue();<br>        ids.add(Long.valueOf(id));<br>        <span class="hljs-comment">//获取score（时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (time==minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//解决sql in无法排序问题，手动指定顺序为传入的ids</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idsStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);              <span class="hljs-comment">//&quot;order by field(id,&quot; + &quot;3,4,5&quot; + &quot;)&quot;</span><br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>,ids).last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+ idsStr +<span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog:blogs)&#123;<br>        <span class="hljs-comment">//查询发布blog的用户信息</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">//查询当前用户是否给该blog点过赞</span><br>        isBlogLiked(blog);<br>    &#125;<br>    <span class="hljs-comment">//封装结果并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">scrollResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    scrollResult.setList(blogs);<br>    scrollResult.setOffset(os);<br>    scrollResult.setMinTime(minTime);<br>    <span class="hljs-keyword">return</span> Result.ok(scrollResult);<br>&#125;<br></code></pre></td></tr></table></figure> <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-优惠券秒杀</title>
    <link href="/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/"/>
    <url>/2023/09/28/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="全局id"><a href="#全局id" class="headerlink" title="全局id"></a>全局id</h4><ul><li>原因：<ul><li>抢购商品时，订单保存到订单表之中，如果将订单id设置为数据库的自增id的话，规律性太明显，并且单表数据量有限制。</li></ul></li><li>实现：<ul><li>符号位 + 时间戳 + 序列号 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span>&#123;<br>        <span class="hljs-comment">//生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">//生成序列号</span><br>        <span class="hljs-comment">//获取当前日期，精确到天（将key以天分组，方便管理，并且解决redis自增上限问题）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">//自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">//拼接并且返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<span class="hljs-comment">//先左移32位，再或运算将count补上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="实现秒杀"><a href="#实现秒杀" class="headerlink" title="实现秒杀"></a>实现秒杀</h4><ul><li>秒杀券和其他普通优惠券类似，普通优惠券可以任意购买，而秒杀券需要在特定时间并且一人一单的方式进行抢购。券在一张表，包含所有的券，其中用一个字段标明其是否是秒杀券，并且还有一张秒杀券表，可采用类似于外键进行关联，其中包含的是秒杀券的一些特定信息（抢购时间，结束时间，库存等）。</li><li>抢秒杀券：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5. 扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>,voucherId)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6. 创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">//6.1 设置订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">//6.2 设置用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">//6.3 设置代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(id);<br>    <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>    save(voucherOrder);<br>    <span class="hljs-comment">//8. 返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><ul><li>上面代码有很明显的问题，就是在高并发场景下会出现超卖现象。原因就在于，在库存判断和库存扣除两步中并没有锁来约束。</li><li>我们可以进行加锁来解决：<ul><li>悲观锁<ul><li>悲观锁认为线程安全一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock等，都是悲观锁。</li></ul></li><li>乐观锁：<ul><li>乐观锁认为线程安全问题不一定发生，因此不加锁，只在数据更新的时候再去判断有没有其他线程对数据就进行了修改。<ul><li>如果没有修改，则认为自己是安全的，自己可以更新数据。</li><li>如果被其他线程进行了修改，则说明发生了安全问题，此时继续重试或者异常。</li></ul></li></ul></li><li>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</li><li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。</li></ul></li><li>在本项目中，并不需要指定版本号，可以使用stock进行替代，比较查询时的stock数据和修改时的数据库中的stock数据是否一致（因为stock只会减少，不会增加，因此不会出现aba问题，所以可以代替版本号）。</li></ul><h4 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h4><ul><li>操作逻辑，进行库存判断之后，根据订单表中的数据，判断用户是否已经购买过。<ul><li>购买过则不能下单</li></ul></li><li>初步逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一人一单逻辑</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果在多线程情况下，在执行一人一单的逻辑之前，在这个区间如果进来了多个线程，仍然能抢多张优惠券。即 线程1:库存充足-&gt;判断一人一单（此时该优惠券中并没有写入userid）-&gt;此时线程2：库存充足-&gt;优惠券无userid-&gt;线程2写入userid-&gt;线程1写入userid</li><li>解决办法<ul><li>添加悲观锁<ul><li>将一人一单后的逻辑写入一个方法createVouherOrder，并对该方法加锁。</li><li>但是此时的粒度太粗，当该方法有锁时，所有用户都无法进行此方法，而我们的目的是一人一单，所以这个锁，应该加在单个用户上，使用userid来标识。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 一人一单逻辑</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<span class="hljs-comment">//需要根据userid的字面量来进行加锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).count();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;你已经抢过优惠券了哦&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//5. 扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//6. 创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">//6.1 设置订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">//6.2 设置用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//6.3 设置代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setUserId(id);<br>        <span class="hljs-comment">//7. 将订单数据保存到表中</span><br>        save(voucherOrder);<br>        <span class="hljs-comment">//8. 返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>    <span class="hljs-comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用AopContext.currentProxy()来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去IVoucherOrderService中创建createVoucherOrder方法</li><li>并且导入依赖aspectjweaver，以及在启动类加上注解@EnableAspectJAutoProxy(exposeProxy &#x3D; true)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h4><ul><li>通过加锁可以解决在单机情况下的一人一单问题，但是在集群模式下就不行了。<br><img src="/../img/jvm%E9%94%81.png" alt="jvm锁"></li><li>如上图所示，jvm中的锁都是按照单机为域划分的，所以在集群模式下我们需要使用分布式锁，即让锁不在jvm内部，而是让锁在jvm外，为公用的锁。</li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><ul><li>分布式锁：满足分布式系统或者集群模式下的多线程可见的并且可以互斥的锁。<br><img src="/./../img/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="分布式锁"></li><li>分布式锁应该满足的条件：<ul><li>可见性：每个线程，每个服务器都能看到锁</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全</li></ul></li><li>常见的分布式锁：<ul><li>mysql</li><li>redis</li><li>zookeeper<br><img src="/../img/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="常见分布式锁"></li></ul></li><li>redis实现分布式锁：<ul><li>核心思路：利用redis的SETNX方法，当多个线程进入时，利用该方法获取锁，第一个线程进入时，redis则有这个key，返回1，表示他抢到了锁，那么他去执行业务，完成后，再删除锁，退出锁，没有抢到锁的线程则等待重试。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">//锁的前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//自动拆箱可能会出现null，这样写更稳妥</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//通过DEL来删除锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br><span class="hljs-comment">// 获取锁对象</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock(<span class="hljs-number">120</span>);<br><span class="hljs-comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许抢多张优惠券&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取代理对象</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    redisLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>redis分布式锁误删问题：<ul><li>逻辑说明：<ul><li>如果持有锁的线程1在内部出现了阻塞，导致锁ttl过期，自动释放。</li><li>此时线程2来获取锁，因为线程1已经释放了锁，所以线程2拿到了锁</li><li>现在线程1阻塞结束，继续执行业务，再释放锁。&#x2F;</li><li>此时会将线程2的锁释放。</li></ul></li><li>解决办法<ul><li>在线程释放锁的时候判断该锁是否是自己的。</li><li>实现：存入锁的时候放入自己的线程标识，释放的时候再对锁进行判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标识</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标识是否一致</span><br>    <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>分布式锁的原子性问题：<ul><li>更为极端的误删逻辑说明</li><li>假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制）</li><li>于是锁的TTL到期了，自动释放了</li><li>那么现在线程2趁虚而入，拿到了一把锁</li><li>但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑</li><li>但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了</li><li>那么就相当于判断标识那行代码没有起到作用</li><li>这就是删锁时的原子性问题</li><li>因为线程1的拿锁，判断标识，删锁，不是原子操作，所以我们要防止刚刚的情况</li></ul></li><li>使用lua脚本解决多条命令的原子性问题<ul><li>Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;其他参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure></li></ul></li><li>但是此时分布式锁仍然存在问题：锁不住。<ul><li>因为当锁的ttl快到期的时候，我们并没有实现续期功能。</li><li>所以得依赖redisson来解决续期问题。</li></ul></li></ul><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><ul><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题<br><img src="/../img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="可重入锁"></li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h4><ul><li>我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br><img src="/../img/%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96.png" alt="异步优化"></li><li></li></ul><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在力扣中有许多层序遍历相关的题目，但基本都是以下面这题为基础进行修改的，所以记录一下，加强理解。</p><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p></blockquote><p>  [TOC]</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>类似于图的广度优先遍历，利用队列的性质，每次先入队一个节点，然后对其进行出队，出队后判断其是否还有子节点，有子节点则再次入队，并且用for循环进行当前层级的遍历，因为当前每次进行节点出队前的deque的size就是当前层次的节点数量。</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//存储列表的列表</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//为空则返回空列表</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.add(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<span class="hljs-comment">//定义个数，用来分层</span><br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//定义每个层次的节点列表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">//用来对当前层进行操作</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                level.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <url>/2023/09/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><ol><li>前后序遍历：<br>前序遍历和后续遍历比较简单，类似于图的广度优先遍历。前序遍历利用栈来保存节点，当栈不为空，弹出节点，进行左右节点的判断，有的话将左右节点入栈。需要考虑一下的就是入栈和出栈的顺序问题，因为栈先进后出的特点，所以需要逆向存储，前序遍历中，本该是中左右，但是由于栈的特性，我们应该先中，右，左。而后续遍历考虑一下左右顺序并将list反转一下即可。</li><li>中序遍历：利用栈存储已经浅层次访问的节点（未进行遍历，以及右节点的判断），再利用cur指针，进行遍历，cur先深入最左底部，并存储访问的节点，如果该节点的左节点访问完全，则输出根节点，再进行右节点的访问。有点绕，具体见代码：</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;            <br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-comment">//cur!=null代表的是向左还没走完，stack!=null代表的是已经走过的节点还未完全判断访问（例如右节点）</span><br>            <span class="hljs-comment">//左节点访问：</span><br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//到了最左</span><br>                stack.push(cur);<span class="hljs-comment">//存储访问过的元素</span><br>                cur = cur.left;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = stack.pop();<br>                result.add(cur.val);<span class="hljs-comment">//进行左的遍历</span><br>                cur = cur.right;<span class="hljs-comment">//这一步就决定上面需要使用else</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//先判断有无左右节点，有则反方向放入节点，如右左根</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-商户缓存</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="缓存的基本知识"><a href="#缓存的基本知识" class="headerlink" title="缓存的基本知识"></a>缓存的基本知识</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><ol><li>缓存是数据交换的缓冲区，一般从数据库中获取，存储在本地。</li><li>redis缓存:由于其被static修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被final修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build();<br></code></pre></td></tr></table></figure></li></ol><h4 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h4><ol><li>速度快</li><li>缓存数据存储在代码之中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户并发访问给服务器带来的读写压力。</li><li>实际开发之中，数据量往往很大，如果没有缓存作为“减震器”，系统很难支撑。</li><li>缓存会增加代码复杂度和运营成本。</li><li>降低后端负载，提高读写速度。</li><li>数据一致性成本，代码维护成本，运维成本。</li></ol><h4 id="商户缓存的使用"><a href="#商户缓存的使用" class="headerlink" title="商户缓存的使用"></a>商户缓存的使用</h4><ol><li>缓存作用模型：<br><img src="/../img/%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg" alt="缓存作用模型"></li></ol><h3 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h3><ol><li>什么是缓存更新<ul><li>缓存更新就是为了节约内存而设计的，因为内存数据宝贵，当向redis插入太多数据时，可能会导致缓存中数据过多，所以需要对redis中的数据进行更新，或者淘汰。</li><li>内存淘汰：当redis数据大过我们设定的max_memory时，会自动触发淘汰机制，淘汰不重要的数据（可以自己设置策略）。</li><li>超时剔除：给redis数据设置ttl（time to live），redis会将超时的数据进行删除。</li><li>主动更新：手动调用方法删除缓存，通常用来解决缓存和数据库不一致的问题。</li></ul></li><li>业务场景<ul><li>低一致需求：使用内存淘汰机制，如店铺类型的查询缓存。</li><li>高一致需求：主动更新，以超时剔除兜底，如店铺详情查询。</li></ul></li><li>缓存不一致的解决方案：<ol><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li><li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li><li>目前采用的方案：方案一<ol><li>如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来</li><li>因为更新缓存读写操作麻烦，所以直接删除缓存，等有新数据再直接写入缓存，完成更新。</li></ol></li><li>保证数据库和缓存同时成功和失败：</li></ol><ul><li>单体系统：将缓存和数据库操作放在一个事务之中。</li><li>分布式系统：利用TCC等分布式事务方案</li></ul><ol start="6"><li>数据库 缓存：<ul><li>出现问题的原因就在于，在数据库操作和缓存更新中间的时间里，可能会有其他线程进行操作。比如当线程1进行删除操作时，在更新数据库完成前，另一个线程2进来查询，发现此时缓存未命中，于是查询未更新完的数据库，写入缓存。然后线程1的更新完成了，但是此时缓存中已经被线程2以脏数据写入，此时的缓存等于并没有更新，所以此时数据库和缓存仍然不一致。<br> <img src="/../img/%E5%85%88%E7%BC%93%E5%AD%98%E5%86%8D%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="先缓存再数据库"></li><li>因为数据库操作时间长，所以先删除缓存再更新数据库，在数据操作和删除缓存之间的危险时间更长。</li><li>先操作数据库，再删除缓存<br> 线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题。<br><img src="/../img/%E5%85%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E7%BC%93%E5%AD%98.png" alt="先数据库再缓存"></li></ul></li></ol></li></ol><h3 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透： 缓存穿透是指客户请求的数据在缓存和数据库之中都不存在，这样的请求会导致频繁的访问数据库。</p><pre><code class="hljs">1. 解决方案：缓存空对象  - 优点：实现简单，维护方便  - 缺点：额外的内存消耗，造成短期的不一致2. 布隆过滤  - 优点：内存占用少，没有多余key  - 实现复杂，可能误判</code></pre><ul><li><p>缓存空对象：当数据库和redis都没有该数据时，直接生成该数据&lt;key-“”&gt;存储到redis之中。所以有了额外的内存消耗，短期不一致是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过（因为这是插入语句，一般来说插入语句就是直接插入到数据库，然后通过key查询缓存，发现没有缓存再查询数据库，将key-value保存到redis，此时因为又存在redis，所以并不会对redis进行更新，得等到ttl过才会更新），所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了。</p></li><li><p>布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突</p></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul><li>缓存雪崩：是指在同一时间段，大量缓存的key同时失效，或者redis服务器宕机，导致大量的请求到达数据库，带来巨大的压力。</li><li>解决方案<ul><li>给不同的key添加不同的TTL，让其分批失效。</li><li>使用熔断机制，给流量设置一定阈值。</li><li>搭建redis集群（防止redis宕机）</li></ul></li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul><li>缓存击穿：与缓存雪崩类似，缓存雪崩是大规模的key失效，而缓存击穿是 一个 热点的Key（高并发访问，缓存业务重建业务复杂），有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。例如：一件抢购中的商品的key失效。</li><li>解决方案：<ul><li>互斥锁</li><li>逻辑过期</li></ul></li><li>互斥锁：利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题，线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。<br><img src="/../img/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"><ul><li>逻辑过期：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案<br>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据<br>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据。<br><img src="/../img/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png" alt="逻辑过期"></li></ul></li><li>互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响</li><li>逻辑过期方案：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦。<style>/* 只设置 markdown 字体 */.markdown-body {  font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;  font-size: 20px;}</style></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评-登录注册实现</title>
    <link href="/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/09/27/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="整体思维框架"><a href="#整体思维框架" class="headerlink" title="整体思维框架"></a>整体思维框架</h3><h3 id="基于Redis优化session来进行短信登陆"><a href="#基于Redis优化session来进行短信登陆" class="headerlink" title="基于Redis优化session来进行短信登陆"></a>基于Redis优化session来进行短信登陆</h3><h4 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h4><ol><li>发送验证码<br>首先根据用户的手机号进行判断，是否合法，合法则可以进行发送验证码。通过session进行保存。</li><li>通过验证码进行登录，注册<br>通过实体LoginFormDTO，封装手机号，验证码，密码（暂时只考虑手机号和验证码），先进行手机号合法性的判断，合法再判断手机号和验证码是否与session中存储的一致。</li></ol><hr><ul><li><h5 id="什么是cookie？"><a href="#什么是cookie？" class="headerlink" title="什么是cookie？"></a>什么是cookie？</h5><ul><li>简单定义：cookie是一些数据信息，类型为小型文本文件，存储在电脑的文本文件中。</li><li>作用：浏览器可以保存我们的cookie（记录了一些信息），让我们重新访问网站的时候无需再次登录。</li><li>表示形式：一般情况下都是以键值对（key-value）形式来表示。</li><li>工作原理：当客户端访问某一个地址时，会将请求交给服务器进行处理，在发送请求的时候，浏览器会将页面的头部信息一并发送给服务器进行处理，在服务器处理的过程中，会在服务器端生成cookie，随着http响应会在响应头中带上cookie信息，浏览器在接受响应后会按照cookie信息在客户端简历cookie，并在下次客户端进行请求的时候，附带本地的cookie发送到服务器。</li><li>缺点：<ul><li>不安全，明文暴露</li><li>移动端无法使用</li><li>无法跨域使用<ul><li><img src="/../img/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE.png" alt="Alt text"></li></ul></li></ul></li></ul></li><li><h5 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h5><ul><li>session定义:session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。</li><li>作用：因为cookie中无法存放，所以使用session进行代替，session存储于服务端（cookie保存在客户端），服务端回味每一个客户端创造一个唯一的session，session是服务端共享，客户端独享。<img src="/../img/session%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alt text"></li><li>表现形式：类似于一个map，存放多个键值对，key必须为字符串，value是一个对象。</li></ul></li><li>cookie和session的比较：<ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。<br><img src="/../img/cookie%EF%BC%8Csession%EF%BC%8C%E4%BB%A4%E7%89%8C%E5%AF%B9%E6%AF%94.png" alt="Alt text"></li></ul></li></ul><hr><ol><li>校验登陆状态，实现拦截<br>用户在进行请求时，会从cookie中携带JsessionId到服务端，服务端通过JsessionId从session中获取信息，没有session信息则进行拦截，有session信息则将用户信息保存到threadLocal中，并放行。<br>拦截器的实现：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2. 获取session中的用户信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//4. 不存在，则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br>        UserHolder.saveUser(user);<br>        <span class="hljs-comment">//6. 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Redis优化登录注册"><a href="#Redis优化登录注册" class="headerlink" title="Redis优化登录注册"></a>Redis优化登录注册</h4><ol><li>为什么需要优化？<br>因为session是存储在服务器之中的，所以当有多台tomcat时，会出现session共享问题，比如用户第一次访问了tomcat1，第二次访问了tomcat2，那么tonmcat2中肯定没有存放用户的session信息，所以此时登录拦截会出现问题。不改变session存储的解决方案有：将完整session拷贝到每一台tomcat中，并且及时同步，这就带来了两个问题：<ol><li>每个tomcat都有完整session，会造成服务器压力过大。</li><li>拷贝session数据时，可能会出现延迟。</li><li>所以我们使用redis进行实现，因为redis本身就是可以共享的。</li></ol></li><li>redis实现</li><li>设计key</li></ol><ul><li>由于redis全局共享，所以我们需要设计不重复，不暴露信息的key。可以直接让后台生成token进行业务。</li></ul><ol><li>登录后，根据手机号查询判断是否有用户信息 ，无则新建，将用户数据保存到redis，生成token作为key。有则进行校验，根据token判断数据是否存在。不存在则拦截，存在则将用户信息保存到threadLocal，并放行（token也存在请求头中）。</li><li>拦截器通过判断threadLocal是否为空进行判断拦截还是放行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-comment">//校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//校验验证码（从redis中）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<span class="hljs-comment">//获取用户输入的code</span><br>    <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>        <span class="hljs-comment">//不一致则报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建新用户并保存</span><br>        user = createUserWithPhone(phone);<span class="hljs-comment">//(user接收，便于保存)</span><br>    &#125;<br>    <span class="hljs-comment">//保存信息到redis</span><br>    <span class="hljs-comment">//随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> RedisConstants.LOGIN_USER_KEY + token;<br>    <span class="hljs-comment">//将user对象转为hash存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));<br>    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);<br>    <span class="hljs-comment">//设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//返回token</span><br>    <span class="hljs-comment">//session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>登录刷新问题<ul><li>通过拦截器查看用户是否在操作，如果没有操作超过30分钟，删除token，用户重新登录</li><li>通过查看请求，如果请求头中有token，那么我们刷新token存活时间。</li><li>拦截器优化：在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br><img src="/../img/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96.png" alt="Alt text"></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//获取请求头之中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//基于token获取redis中的用户（get是根据key以及字段取值，entries是根据key取值）</span><br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash()<br>            .entries(token);<br>    <span class="hljs-comment">//判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//将查询到的hash数据转为userDTO</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap,<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(),<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//将userDTO信息保存到threadLocal</span><br>    UserHolder.saveUser(userDTO);<br>    <span class="hljs-comment">//刷新token的有效期</span><br>    stringRedisTemplate.expire(token,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);<br>    <span class="hljs-comment">//放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023-9-26记事</title>
    <link href="/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/"/>
    <url>/2023/09/26/2023-9-26%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：闲来无聊，本应该是记单词的时间，但是又想练习打字，于是开始用电脑码一下今天的日记吧</p><h3 id="学习状态总结"><a href="#学习状态总结" class="headerlink" title="学习状态总结"></a>学习状态总结</h3><p>总体可以给自己打分80吧，今天又没去上课，在宿舍学习，效率一般，任务完成度还行，但是吸收的并不多，也进行了运动，下面是今日的统计情况，累计时长接近9小时</p><h4 id="23年09月26日"><a href="#23年09月26日" class="headerlink" title="23年09月26日"></a>23年09月26日</h4><blockquote><p><strong>08:00至09:58 【redis学习】  1小时58分钟</strong></p></blockquote><p>&emsp;redisson 联锁，可重用锁，</p><blockquote><p><strong>10:20至11:31 【redis学习】  1小时11分钟</strong></p></blockquote><p>&emsp;秒杀优化 异步下单，阻塞队列</p><blockquote><p><strong>14:30至15:50 【redis学习】  1小时20分钟</strong></p></blockquote><p>&emsp;调傻逼bug，总算解决了，但是不知道原因</p><blockquote><p><strong>15:50至17:30 【leetcode刷题】  1小时40分钟</strong></p></blockquote><p>&emsp;一道半力扣，小颓废唉</p><blockquote><p><strong>19:15至20:42 【redis学习】  1小时27分钟</strong></p></blockquote><p>&emsp;redis消息队列看完，不过没咋吸收全是api，语法</p><blockquote><p><strong>20:42至20:55 【leetcode刷题】  13分钟</strong></p></blockquote><p>&emsp;三道sql</p><blockquote><p><strong>20:55至22:00 【运动健身】  1小时5分钟</strong></p></blockquote><p>&emsp;引体，弯举，划船，卷腹</p><h3 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h3><p>自己这段时间还是太焦虑和着急了，基于求成进度，想快速的学完java进行实习，这样使自己草草的看完视频，码一下代码就安慰自己是学完了，说实话这真的是致命毒药，因为做项目的关键在于去面试找工作，面试官拷打你的项目的时候就是直接根据项目的技术栈来进行询问的，如果你回答不上来那么等于是没做，所以我现在的改变我的心态，必须吃透项目，并且看完一章节后根据网上资料以及ppt进行总结归纳，不要急于求成，每天起码画两三个小时去总结。<br>关于自己实习的问题也不能着急，你现在如果去一个垃圾小厂实习的话，一是可能学不到东西，赚不到钱，还有挂科的风险，并且最主要的是浪费了时间，这学期应该好好静下心来，学习java（redis，mq，sprincloud等），学习计网，还有备战六级，并且反复刷leetcode，最后一两个月，差不读学习完springcloud课程之后再进行八股，准备面试以及期末考试。<br>好吧就这样吧，加油，睡觉了！</p><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配下标-KMP算法</title>
    <link href="/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/25/%E5%8C%B9%E9%85%8D%E4%B8%8B%E6%A0%87-KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><p>前言：尽管之前大二学数据结构我就学过kmp，但是由于这个算法比较复杂，并且自己划水一年，所以基本上是新学差不多，今天花了接近三个小时，重新梳理一下kmp的思路，以及注意事项。</p><p>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><ol><li>根据前后缀来进行快速匹配，使得不需要使用两个for循环来进行匹配，如图 <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="使用前后缀匹配" title="Magic Gardens"></li><li>如何进行匹配呢，我们借助next数组，next数组是一个和字串长度相等的int数组，相应的存储以该节点为后缀的最大公共前后缀长度，什么是公共前后缀呢？例如：aabaa字串的公共前后缀就是a,aa，所以其最大长度为2。</li><li>那么next数组如何发挥作用呢，我们依次匹配串，当有冲突时，我们利用next进行回溯，回溯到的位置就是 next[冲突位置索引-1] ，为什么呢，我们可以举一个例子，比如 串 a a b a a f，对应的next数组为0 1 0 1 2 0，当父串为：a a b a a b a a f,我们可以知道当匹配到父串的第二个b时会有冲突，所以回溯，根据next，父串指针不动，字串指针回溯到next[indexOf(‘f’)-1]即2，所以我们再次从子串的第一个b开始匹配。</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next,String s)</span>&#123;<br>    <span class="hljs-comment">//初始化 j 以及 next数组</span><br>    <span class="hljs-comment">//i：后缀末尾   j：前缀末尾</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; s.length();i++)&#123;<span class="hljs-comment">//对于每一个后缀的结尾</span><br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))&#123;<span class="hljs-comment">//判断是否前后缀相等</span><br>            j = next[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//不匹配则 j 回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>    <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>    getNext(next,needle);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++) &#123;<br>        <span class="hljs-comment">//关键此处的 while和下面的if不能交换顺序！！</span><br>        <span class="hljs-comment">//反例如 父串 sads 子串 sad</span><br>        <span class="hljs-comment">//若是if(==)在前，当第一个匹配 s时，j++，此时i还没有++，所以在进行接下来的while时会进入while导致bug</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) <span class="hljs-comment">//不匹配则查找不匹配字符的前一个位置的next值，进行回溯</span><br>            j = next[j - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) <span class="hljs-comment">//匹配则两个指针同时后移，进行下一个的匹配</span><br>            j++;<br>        <span class="hljs-keyword">if</span> (j == needle.length()) <br>            <span class="hljs-keyword">return</span> i - needle.length() + <span class="hljs-number">1</span>;<span class="hljs-comment">//返回子字符串在父字符串中的匹配位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的单词</title>
    <link href="/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/09/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体思路为：整体的字符反转，字符中额外空格的删除，字符单词反转</p><p>字符反转很简单，使用双指针即可<br>删除字符中的额外空格有点麻烦，可以使用双指针（参考之前的数组移除元素），具体思路如下：定义快慢指针，用快指针遍历数组，当快指针指向非目标值时，将快指针的内容拷贝到慢指针处，然后fast++，slow++。主要留心中间空格以及两端空格的处理。<br>字符单词反转不麻烦但是得考虑全。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">char</span>[] sChars = s.toCharArray();<br>      <span class="hljs-comment">//字符串整体反转</span><br>      reverse(sChars,<span class="hljs-number">0</span>,sChars.length-<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//去除额外空格</span><br>      sChars = removeExtraSpace(sChars);<br>      <span class="hljs-comment">//单词内反转</span><br>      reverseEachWord(sChars);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sChars);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt;= chars.length; end++) &#123;<span class="hljs-comment">//便于让end总是指向每一个单词的末尾</span><br>          <span class="hljs-keyword">if</span>(end == chars.length || chars[end] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>              reverse(chars,start,end-<span class="hljs-number">1</span>);<br>              start = end + <span class="hljs-number">1</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] removeExtraSpace(<span class="hljs-type">char</span>[] chars)&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; chars.length; fast++) &#123;<br>          <span class="hljs-keyword">if</span> (chars[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<span class="hljs-comment">//整体为去除空格模板</span><br>              <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在非首位的每个单词后面添加一个空格</span><br>                  chars[slow] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                  slow ++;<br>              &#125;<br>              <span class="hljs-keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] !=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                  <span class="hljs-comment">//删除所有空格</span><br>                  <span class="hljs-comment">//将快指针的内容（非空格的字母）赋值给慢指针</span><br>                  chars[slow] = chars[fast];<br>                  slow++;<br>                  fast++;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//同时slow也就是到达了最后的有效位置，slow的大小就是处理完后的数组大小。</span><br>      <span class="hljs-type">char</span>[] newChar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[slow];<br>      <span class="hljs-comment">//数组拷贝，System.arraycopy(拷贝数组, 起始索引, 新数组, 起始索引, 拷贝长度); </span><br>      System.arraycopy(chars, <span class="hljs-number">0</span>, newChar, <span class="hljs-number">0</span>, slow); <br>      <span class="hljs-keyword">return</span> newChar;<br>  &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> end)</span>&#123;<br>      <span class="hljs-type">char</span> tmp;<br>      <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>          tmp = chars[start];<br>          chars[start] = chars[end];<br>          chars[end] = tmp;<br>          start ++;<br>          end --;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><style>  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }</style>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
